# Shell functions for the scripts in /etc/init.d

# If $DAEMON is defined before including this file, some additional preparations is performed
# other environment variables:
# DAEMON_LONG_NAME	service name to display in start/stop message, default $DAEMON
# PID_FILE		pid-file for DAEMON, default /var/run/$DAEMON.pid
# CONF_NAME		config is in /mod/etc/conf/${CONF_NAME}.cfg instead of /mod/etc/conf/${DAEMON}.cfg

export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/mod/sbin:/mod/bin:/mod/usr/sbin:/mod/usr/bin
export LD_LIBRARY_PATH=/mod/lib:/mod/usr/lib


# modlib_addgroup:
#   check for group name, create group if not found.
#   No check is done for a change in the optional arguments!
#	$1: group name
#	$2-n: optional arguments for addgroup
modlib_addgroup()
{
	local group="$1"
	shift
	if grep -q "^$group:" /etc/group; then
		return 0
	fi
	echo -n "Looking for group '$group' ... "
	if addgroup "$@" $group; then
		echo -n "created - now saving to data buffer ... "
		modusers save && echo "done" || echo "failed"
	else
		echo "not created - error occurred"
	fi
}

# modlib_adduser:
#   check for user name, create user if not found.
#   No check is done for a change in the optional arguments!
#	$1: user name
#	$2-n: optional arguments for adduser
modlib_adduser()
{
	local user="$1"
	shift
	if grep -q "^$user:" /etc/passwd; then
		return 0
	fi
	echo -n "Looking for user '$user' ... "
	local msg=$(adduser "$@" $user 2>&1)
	if [ "$?" = 0 ]; then
		echo -n "created - now saving to data buffer ... "
		modusers save && echo "done" || echo "failed"
	else
		echo "not created - error occurred: $msg"
		exit 1
	fi
}

# modlib_reload_inetd
# check whether /etc/init.d/rc.inetd exists.
# reloads inetd. return status
modlib_reload_inetd()
{
	local inetd_rc_script="/etc/init.d/rc.inetd"
	if [ -x ${inetd_rc_script} ]
	then
		${inetd_rc_script} reload
	else
		killall -HUP inetd
	fi
	return $?
}

# modlib_check_port
#   check whether a port is busy and by which daemon. return status
#	$1: port number
#	$2: daemon name
#	$3: [optional] command: check(default), stop, kill
#	$4: [optional] socket: t: TCP(default) u: UDP w: RAW
#   returns: 0 free; 1 oneself; 2 inetd; 3 other daemon; 4 stop command failed; 5 kill command failed 
modlib_check_port()
{
	[ -z "$1" ] && local netport=21 || local netport="$1"
	[ -z "$2" ] && local daemonname="daemon" || local daemonname="$2"
	[ -z "$3" ] && local docommand="check" || local docommand="$3"
	[ -z "$4" ] && local sockettype="t" || local sockettype="$4"
	local pidname="$(netstat -lnp"$sockettype" | sed -nre "s/^.*:$netport .* ([^ ]+) *\$/\\1/p")"
	local inetdconf="/var/mod/etc/inetd.conf"
	if [ -z "$pidname" ]
	then
		return 0 # port is free
	else
		local myname=${pidname#*/}
		local mypid=${pidname%/*}
		if [ "$myname" == "inetd" ]
		then
			local inetddaemon=""
			[ -e "$inetdconf" ] && inetddaemon="$(cat $inetdconf | grep ^$netport | sed -e '/^#/d;s/\t/ /g;s/  */ /g;s/^[^ ]*\ [^ ]* [^ ]* [^ ]* [^ ]* [^ ]* \([^ ]*\) .*/\1/;s/.*\///g')"
			[ -z "$inetddaemon" ] && inetddaemon="inetd"
		fi
		case $docommand in
			stop)
				[ "$myname" != "inetd" ] && inetddaemon="$myname"
				if [ "$inetddaemon" == "inetd" ]
				then
					echo "$inetddaemon"
					return 4 # stopping of inetd permitted
				fi
				if [ -x "/etc/init.d/rc.$inetddaemon" ]
				then
					/etc/init.d/rc.${inetddaemon} stop
					local status=$?
					if [ "$status" -eq 0 ]
					then
						return 0 # stopping successful
					else
						echo "$inetddaemon"
						return 4 # stopping failed	
					fi
				fi
			;;
			kill)
				if [ "$myname" == "inetd" ]
				then
					echo "$myname"
					return 5 # killing of inetd permitted	
				fi
				local cnt=9 
				while [ $cnt -ge 0 ] && kill -0 $mypid 2>/dev/null
				do 
					kill $mypid 2>/dev/null 
					sleep 1 
					let cnt=cnt-1 
				done 
				if kill -0 $mypid 2>/dev/null
				then 
					kill -9 $mypid 2>/dev/null 
					sleep 1
				fi 
				if kill -0 $mypid 2>/dev/null
				then
					echo "$myname"
					return 5 # killing failed
				else
					return 0 # killing successful
				fi
			;;
			*)
				if [ "$myname" == "$daemonname" ]
				then
					echo "$myname"
					return 1 # port is already used by this DAEMON
				fi
				if [ "$myname" == "inetd" ]
				then
					echo "$inetddaemon"
					return 2 # port is already used by inetd
				else
					echo "$myname"
					return 3 # port is already used by other DAEMON
				fi
			;;
		esac
	fi
}

# modlib_check_running
#   check whether daemon is running. return status
modlib_check_running()
{
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	[ ! -s "$fn" ] && return 1
	kill -0 $(cat "$fn") 2> /dev/null
	local status="$?"
	[ "$status" != "0" ] && rm -f "$fn"
	return "$status"
}

# modlib_stop
#   stop daemon
modlib_stop()
{
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	local id=$(cat "$fn" 2>/dev/null)
	echo -n "Stopping ${DAEMON_LONG_NAME-$DAEMON}..."
	if ! modlib_check_running; then
		echo 'not running.'
		return 0
	fi
	local cnt=9 
	while [ $cnt -ge 0 ] && kill -0 $id 2>/dev/null; do 
		kill $id 2>/dev/null 
		sleep 1 
		let cnt=cnt-1 
	done 
	if kill -0 $id 2>/dev/null; then 
		kill -9 $id 2>/dev/null 
		sleep 1
	fi 
	if ! kill -0 $id 2>/dev/null; then 
		rm -f "$fn" 
		echo 'done.'
		return 0
	else
		echo 'failed.'
		return 1
	fi
}

# modlib_reload
#   reload daemon (send signal SIGHUP)
modlib_reload()
{
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	echo -n "Reloading ${DAEMON_LONG_NAME-$DAEMON}..."
	if ! modlib_check_running; then
		echo 'not running.'
		return 0
	fi
	kill -HUP $(cat "$fn") 2> /dev/null
	local status=$?
	if [ "$status" -eq 0 ]; then
		echo 'done.'
		return 0
	else
		rm -f "$fn"
		echo 'failed.'
		return 1
	fi
}

# modlib_restart
#   restart daemon
#   function "start" must be defined in the calling script
modlib_restart()
{
	modlib_stop && start
}

# modlib_status
#   check whether daemon is running
modlib_status()
{
	if modlib_check_running; then
		echo 'running'
		return 0
	else
		echo 'stopped'
		return 3
	fi
}

# modlib_loadconfig
#    load configuration
modlib_loadconfig ()
{
	local CONF_FILE="/mod/etc/conf/${1-${CONF_NAME-$DAEMON}}.cfg"
	if [ -r "$CONF_FILE" ]; then
		. /mod/etc/conf/${1-${CONF_NAME-$DAEMON}}.cfg
	fi
}

# modlib_startdaemon
#    clear environment, start daemon
#    "$@": commandline tu execute
modlib_startdaemon()
{
	env - PATH="$PATH" "$@"
}

# modlib_start
#    decide if daemon is started in inetd mode
#    function "start" must be defined in the calling script
#    $1: value for DAEMON_ENABLED
modlib_start()
{
	local DAEMON_ENABLED="$1"
	if [ "$DAEMON_ENABLED" == "no" ] || [ "$DAEMON_ENABLED" == "inetd" -a -x /etc/init.d/rc.inetd ]; then
		if [ "$DAEMON_ENABLED" != "inetd" ]; then
			echo "$DAEMON is disabled" 1>&2
		else
			echo "$DAEMON is started via inetd" 1>&2
		fi
		exit 1
	fi
	
	start
}

# load config
[ -n "$DAEMON" ] && case $1 in
	""|config|load|reload|restart|start|status|stop)
		if [ ! -r "/mod/etc/conf/${CONF_NAME-$DAEMON}.cfg" ]; then
			echo "Error[$DAEMON]: not configured" 1>&2
			exit 1
		fi

		modlib_loadconfig
		;;
esac

