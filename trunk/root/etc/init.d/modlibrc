# Shell functions for the scripts in /etc/init.d

# If $DAEMON is defined before including this file, some additional preparations is performed
# other environment variables:
# DAEMON_LONG_NAME	service name to display in start/stop message, default $DAEMON
# PID_FILE		pid-file for DAEMON, default /var/run/$DAEMON.pid
# CONF_NAME		config is in /mod/etc/conf/${CONF_NAME}.cfg instead of /mod/etc/conf/${DAEMON}.cfg
# CONF_PREFIX	other prefix in .cfg-file than $DAEMON
# DAEMON_BIN	for other binary name than $DAEMON (pidof used in modlib_startdaemon)
# DAEMON_ENV	for additional environment settings (used in modlib_startdaemon)

export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/mod/sbin:/mod/bin:/mod/usr/sbin:/mod/usr/bin
export LD_LIBRARY_PATH=/mod/lib:/mod/usr/lib


# modlib_addgroup:
#   check for group name, create group if not found.
#   No check is done for a change in the optional arguments!
#	$1: group name
#	$2-n: optional arguments for addgroup
modlib_addgroup()
{
	local group="$1"
	shift
	if grep -q "^$group:" /etc/group; then
		return 0
	fi
	echo -n "Looking for group '$group' ... "
	if addgroup "$@" $group; then
		echo -n "created - now saving to data buffer ... "
		modusers save && echo "done" || echo "failed"
	else
		echo "not created - error occurred"
	fi
}

# modlib_adduser:
#   check for user name, create user if not found.
#   No check is done for a change in the optional arguments!
#	$1: user name
#	$2-n: optional arguments for adduser
modlib_adduser()
{
	local user="$1"
	shift
	if grep -q "^$user:" /etc/passwd; then
		return 0
	fi
	echo -n "Looking for user '$user' ... "
	local msg=$(adduser "$@" $user 2>&1)
	if [ "$?" = 0 ]; then
		echo -n "created - now saving to data buffer ... "
		modusers save && echo "done" || echo "failed"
	else
		echo "not created - error occurred: $msg"
		exit 1
	fi
}

# modlib_reload_inetd
# check whether /etc/init.d/rc.inetd exists.
# reloads inetd. return status
modlib_reload_inetd()
{
	local inetd_rc_script="/etc/init.d/rc.inetd"
	if [ -x ${inetd_rc_script} ]
	then
		${inetd_rc_script} reload
	else
		killall -HUP inetd
	fi
	return $?
}

# modlib_check_port
#   check whether a port is busy and by which daemon. return status
#	$1: port number
#	$2: daemon name
#	$3: [optional] command: check(default), stop, kill
#	$4: [optional] socket: t: TCP(default) u: UDP w: RAW
#   returns: 0 free; 1 oneself; 2 inetd; 3 other daemon; 4 stop command failed; 5 kill command failed 
modlib_check_port()
{
	[ -z "$1" ] && local netport=21 || local netport="$1"
	[ -z "$2" ] && local daemonname="daemon" || local daemonname="$2"
	[ -z "$3" ] && local docommand="check" || local docommand="$3"
	[ -z "$4" ] && local sockettype="t" || local sockettype="$4"
	local pidname="$(netstat -lnp"$sockettype" | sed -nre "s/^.*:$netport .* ([^ ]+) *\$/\\1/p")"
	local inetdconf="/var/mod/etc/inetd.conf"
	if [ -z "$pidname" ]
	then
		return 0 # port is free
	else
		local myname=${pidname#*/}
		local mypid=${pidname%/*}
		if [ "$myname" == "inetd" ]
		then
			local inetddaemon=""
			[ -e "$inetdconf" ] && inetddaemon="$(cat $inetdconf | grep ^[:0-9.]*$netport[[:blank:]] | sed -e '/^#/d;s/\t/ /g;s/  */ /g;s/^[^ ]*\ [^ ]* [^ ]* [^ ]* [^ ]* [^ ]* \([^ ]*\) .*/\1/;s/.*\///g')"
			[ -z "$inetddaemon" ] && inetddaemon="inetd"
		fi
		case $docommand in
			stop)
				[ "$myname" != "inetd" ] && inetddaemon="$myname"
				if [ "$inetddaemon" == "inetd" ]
				then
					echo "$inetddaemon"
					return 4 # stopping of inetd permitted
				fi
				if [ -x "/etc/init.d/rc.$inetddaemon" ]
				then
					/etc/init.d/rc.${inetddaemon} stop
					local status=$?
					if [ "$status" -eq 0 ]
					then
						return 0 # stopping successful
					else
						echo "$inetddaemon"
						return 4 # stopping failed	
					fi
				fi
			;;
			kill)
				if [ "$myname" == "inetd" ]
				then
					echo "$myname"
					return 5 # killing of inetd permitted	
				fi
				local cnt=9 
				while [ $cnt -ge 0 ] && kill -0 $mypid 2>/dev/null
				do 
					kill $mypid 2>/dev/null 
					sleep 1 
					let cnt=cnt-1 
				done 
				if kill -0 $mypid 2>/dev/null
				then 
					kill -9 $mypid 2>/dev/null 
					sleep 1
				fi 
				if kill -0 $mypid 2>/dev/null
				then
					echo "$myname"
					return 5 # killing failed
				else
					return 0 # killing successful
				fi
			;;
			*)
				if [ "$myname" == "$daemonname" ]
				then
					echo "$myname"
					return 1 # port is already used by this DAEMON
				fi
				if [ "$myname" == "inetd" ]
				then
					echo "$inetddaemon"
					return 2 # port is already used by inetd
				else
					echo "$myname"
					return 3 # port is already used by other DAEMON
				fi
			;;
		esac
	fi
}

# modlib_check_running
#   check whether daemon is running. return status:
#	0: running
#	3: stopped
#	5: inetd
# use CONF_PREFIX for other prefix in .cfg-file
modlib_check_running()
{
	[ "`env | grep -i "^${CONF_PREFIX-$DAEMON}_ENABLED=" | sed 's/.*=//'`" == "inetd" ] && return 5
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	[ ! -s "$fn" ] && return 3
	kill -0 $(cat "$fn") 2> /dev/null
	[ "$?" == "0" ] && return 0 
	rm -f "$fn"
	return 3
}

# modlib_stop
#   stop daemon
# optional: kills daemon with "stop" of rc.$DAEMON if available
modlib_stop()
{
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	local id=$(cat "$fn" 2>/dev/null)
	echo -n "Stopping ${DAEMON_LONG_NAME-$DAEMON}..."
	if ! modlib_check_running; then
		echo 'not running.'
		return 0
	fi
	stop 2>/dev/null
	if [ "$?" -ne 127 ]; then
		sleep 1
	else
		local cnt=9 
		while [ $cnt -ge 0 ] && kill -0 $id 2>/dev/null; do 
			kill $id 2>/dev/null 
			sleep 1 
			let cnt=cnt-1 
		done 
		if kill -0 $id 2>/dev/null; then 
			kill -9 $id 2>/dev/null 
			sleep 1
		fi
	fi 
	if ! kill -0 $id 2>/dev/null; then 
		rm -f "$fn" 
		echo 'done.'
		return 0
	else
	
		echo 'failed.'
		return 1
	fi
}

# modlib_reload
#   reload daemon (send signal SIGHUP)
#   if available runs "config" of rc.$DAEMON
modlib_reload()
{
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	echo -n "Reloading ${DAEMON_LONG_NAME-$DAEMON}..."
	if ! modlib_check_running; then
		echo 'not running.'
		return 0
	fi
	config 2>/dev/null
	kill -HUP $(cat "$fn") 2> /dev/null
	local status=$?
	if [ "$status" -eq 0 ]; then
		echo 'done.'
		return 0
	else
		rm -f "$fn"
		echo 'failed.'
		return 1
	fi
}

# modlib_restart
#   restart daemon
#   function "start" must be defined in the calling script
modlib_restart()
{
	modlib_stop
	modlib_start
}

# modlib_status
#   check whether daemon is running
#	returns:
#	0:			running
#	3:			stopped
#	5:			inetd
#	<other>:	unknown

modlib_status()
{
	modlib_check_running
	retval=$?
	case $retval in
		0)
			echo 'running'
			;;
		3)
			echo 'stopped'
			;;
		5)
			echo 'inetd'
			;;
		*)
			echo 'unknown'
			;;
	esac
	return $retval			
}

# modlib_loadconfig
#    load configuration
modlib_loadconfig ()
{
	local CONF_FILE="/mod/etc/conf/${1-${CONF_NAME-$DAEMON}}.cfg"
	if [ -r "$CONF_FILE" ]; then
		. /mod/etc/conf/${1-${CONF_NAME-$DAEMON}}.cfg
	fi
}

# modlib_startdaemon
#    clear environment, start daemon
#    "$@": commandline to execute
#    if available runs "config" of rc.$DAEMON
#    use DAEMON_BIN for other binary name	
#    use DAEMON_ENV for additional environment settings
modlib_startdaemon()
{
	echo -n "Starting $DAEMON..."
	config 2>/dev/null
	
	env - PATH="$PATH" $DAEMON_ENV "$@"
	local rv=$?
	
	if [ "$rv" -ne 0 ]; then
		echo 'failed.'
		exit $rv
	fi
	
	# even daemons without pid-support creates a .pid file:
	local fn=${PID_FILE-/var/run/$DAEMON.pid}
	if [ ! -s "$fn" ]; then
		local dp=`pidof -s ${DAEMON_BIN-$DAEMON}`
		[ -n "$dp" ] && echo "$dp" > $fn
	fi
	
	echo 'done.'
}

# modlib_start
#    decide if daemon is started in inetd mode
#    function "start" must be defined in the calling script
#    $1: value for DAEMON_ENABLED
#    returns: 0=success or 1=error
modlib_start()
{
	local DAEMON_ENABLED="$1"
	if [ "$DAEMON_ENABLED" == "no" ] || [ "$DAEMON_ENABLED" == "inetd" -a -x /etc/init.d/rc.inetd ]; then
		if [ "$DAEMON_ENABLED" != "inetd" ]; then
			echo "$DAEMON is disabled." 1>&2
		else
			echo "$DAEMON is started via inetd." 1>&2
		fi
		exit 1
	fi

	modlib_check_running
	case $? in
		0)
			echo "Starting $DAEMON...already running"
			;;
		3)
			start
			return $?
			;;
		5)
			echo "$DAEMON is started via inetd." 1>&2
			;;
		*)
			echo "$DAEMON start prohibited, status is uncertain!" 1>&2
			;;
	esac
	return 1
}

# load config
[ -n "$DAEMON" ] && case $1 in
	""|config|load|reload|restart|start|status|stop)
		if [ ! -r "/mod/etc/conf/${CONF_NAME-$DAEMON}.cfg" ]; then
			echo "Error[$DAEMON]: not configured" 1>&2
			exit 1
		fi

		modlib_loadconfig
		;;
esac

