#!/bin/bash

# DS-Mod patch tool with optional auto-fix feature
#
# This script can either be dot-included via '. tools/ds_patch' to get an
# in-process definition of the 'modpatch' shell function or executed directly.
# The execution mode will be determined by checking if $0 has the base name
# 'ds_patch'.
#
# The functionality has evolved from the original "modpatch" function in
# DS-Mod's 'fwmod' script (cf. copyright information there).
# The additional auto-fix feature for self-healing patches was developed by
# Alexander Kriegisch (kriegaex), 2007-06-25.


helpmsg()
{
cat >&2 << EOF

$ds_patch_name - DS-Mod patch tool with optional auto-fix feature

Usage: $ds_patch_name <target-dir> <patch-file> [ <strip-level> ]
    target-dir   - target directory to apply patch to
    patch-file   - patch file name (unified context diff)
    strip-level  - number of path name levels to strip via '-p' (default: 0)

Examples:
    $ds_patch_name source/my-package patches/my.patch
    $ds_patch_name another/package another.patch 2

Environment variables changing behaviour:
    DS_VERBOSITY_LEVEL  - verbose output, if >= 2
    VERBOSE             - verbose output, if == '-v'
    AUTO_FIX_PATCHES    - try to auto-fix fuzzy patches, if == 'y'

EOF
}


modpatch()
{
	if [ $# -lt 2 -o $# -gt 3 ]; then
		helpmsg
		return 1
	fi
	local level=0
	[ "$3" ] && level="$3"
	local is_verbose=""
	if [ "$DS_VERBOSITY_LEVEL" ] && [ "$DS_VERBOSITY_LEVEL" -ge 2 ] || [ "$VERBOSE" == "-v" ]; then
		is_verbose="y"
	fi
	local backup
	local do_fix
	local files
	if [ "$AUTO_FIX_PATCHES" == "y" ]; then
		local output=$(patch --dry-run -d "$1" -p${level} < "$2" 2> /dev/null)
		if [ $? -eq 0 ] && echo "$output" | grep -E '^Hunk ' > /dev/null 2>&1; then
			do_fix="y"
			backup="-b "
			files=$(echo "$output" | sed -n -r 's/^patching file (.*)/\1/p')
		fi
	fi
	local STATUS
	if [ "$is_verbose" ]; then
		echo2 "applying patch file $2"
		patch ${backup}-d "$1" -p${level} --no-backup-if-mismatch < "$2" 2>&1 | sed -e "s/^/${L2}/g"
		STATUS=${PIPESTATUS[0]}
		echo2 "----------------------------------------------------------------------"
	else
		patch ${backup}-d "$1" -p${level} --no-backup-if-mismatch < "$2" > /dev/null
		STATUS=$?
	fi
	if [ $STATUS -gt 0 ]; then
		error 2 "modpatch: Error in patch-file $2"
	elif [ "$AUTO_FIX_PATCHES" == "y" ] && [ "$do_fix" == "y" ]; then
		echo2 "auto-fixing fuzzy patch file $2"
		local patch_file=$(realpath "$2")
		mv -f "$patch_file" "$patch_file.orig"
		cd "$1"
		for file in $files; do
			diff -Naur "$file.orig" "$file" >> "$patch_file"
			rm -f "$file.orig"
		done
		cd - > /dev/null
		echo2 "----------------------------------------------------------------------"
	fi
}


# Declare unknown function 'echo2', if not dot-included by fwmod
if ! declare -F | awk '{print $3}' | grep -q echo2; then
	echo2()
	{
		if [ "$DS_VERBOSITY_LEVEL" ] && [ "$DS_VERBOSITY_LEVEL" -ge 2 ] || [ "$VERBOSE" == "-v" ]; then
			echo -e "$1"
		fi
	}
fi

# Declare unknown function 'error', if not dot-included by fwmod
if ! declare -F | awk '{print $3}' | grep -q error; then
	error()
	{
		if [ "$1" -gt 0 ]; then
			echo -e "ERROR: $2" 1>&2
			exit $1
		fi
	}
fi

# Direct script call? -> delegate parameters to shell function
if [ "$(basename "$0")" == "ds_patch" ]; then
	ds_patch_name="ds_patch"
	modpatch "$@"
else
	ds_patch_name="modpatch"
fi
