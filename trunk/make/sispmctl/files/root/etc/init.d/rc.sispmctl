#!/bin/sh

DAEMON=sispmctl
DAEMON_LONG_NAME="SIS-PM"

[ -n "$SISPMCTL_PORT" ] && DEFAULTPORT="$SISPMCTL_PORT" || DEFAULTPORT="2638"
MODSHAREDIR="/var/mod/usr/share"
SISPMCTL_DEFAULT_WEBDIR="/usr/share/$DAEMON"
SISPMCTL_WEBDIR="$MODSHAREDIR/$DAEMON"

. /etc/init.d/modlibrc

sis_pid()
{
	# detecting sispmctl pid for defined port number
	# $1: Port number for integrated web interface
	[ -n "$1" ] && sis_webport="$1" || sis_webport="$DEFAULTPORT" 
	sis_pid="$(ps | sed -n -e "/[[:space:]]sispmctl.* -p $1/s/^ *\([0-9]*\) .*/\1/p")"
	if [ -z "$sis_pid" ]
	then
		echo ""
		retval=1
	else
		echo "$sis_pid"
		retval=0
	fi
	return $retval
}


sispmctl_daemon()
{
	# daemon simulation for integrated webinterface
	# $1: device number (0...9) in freetz configuration (required for name conversion)  
	[ -n "$1" ] && out_number=$1 || out_number=1
	eval sis_id="\$SISPMCTL_D${jj}_ID"
	eval sis_name="\$SISPMCTL_D${out_number}_NAME"
	eval sis_webport="\$SISPMCTL_D${out_number}_PORT"
	[ -z "$sis_name" ] && sis_name="SIS-PM-$out_number" 
	[ -z "$sis_webport" ] && sis_webport="$DEFAULTPORT" 
	WEBDIR_PORT="$SISPMCTL_WEBDIR-$sis_webport"
	PID_FILE_PORT="${PID_FILE%.pid}-$sis_webport.pid" # separate PID file for current port

	echo -n "  Binding web interface for $sis_name [$sis_id] on port $sis_webport ... "
	config
	
	if [ -z "$sis_id" ]
	then
		sispmctl -q -p $sis_webport -u "$WEBDIR_PORT" -l 1>/dev/null 2>/tmp/sispmerror &
	else
		sispmctl -q -D "$sis_id" -p $sis_webport -u "$WEBDIR_PORT" -l 1>/dev/null 2>/tmp/sispmerror &
	fi
	sis_error="$(sed '/now comparing/d' /tmp/sispmerror)"
	if [ -n "$sis_error" ]
	then
		echo -n "$sis_error ... "
		echo 'failed.'
		return 1
	fi
	if sis_pid $sis_webport >${PID_FILE_PORT}
	then
		if [ -e ${PID_FILE} ]
		then
			old_pids="$(cat ${PID_FILE})"
			new_pid="$(cat ${PID_FILE_PORT})"
			echo "$old_pids $new_pid" > ${PID_FILE} 2>/dev/null # global PID file consists all the PIDs separated by spaces (like pidof)
		else
			cp ${PID_FILE_PORT} ${PID_FILE} >/dev/null 2>&1 
		fi
	else
		echo "failed."
		rm -f ${PID_FILE_PORT} >/dev/null 2>&1
		return 1
	fi
	echo "done."
	return 0
}

prepare_webdir()
{
	# preparation of web directories for internal integrated web interface
	# standard names for outlets are replaced with user defined values
	# $1: device number (0...9) in freetz configuration (required for name conversion)  
	[ -n "$1" ] && out_number=$1 || out_number=1
	eval sis_name="\$SISPMCTL_D${out_number}_NAME"
	eval sis_webport="\$SISPMCTL_D${out_number}_PORT"
	[ -z "$sis_name" ] && sis_name="SIS-PM-$out_number" 
	[ -z "$sis_webport" ] && sis_webport="$DEFAULTPORT" 
	kk=1
	while [ $kk -le 4 ]
	# Names for outlets 1...4
	do
		eval NAME_O_curr="\$SISPMCTL_D${out_number}_O${kk}"
		[ -z "$NAME_O_curr" ] && NAME_O_curr="Socket ${kk}"
		eval NAME_O${kk}="\$NAME_O_curr"
		kk=$(($kk + 1))
	done

	# Internal web interface will be run from /var/mod/usr/share/sispmctl-PORT
	WEBDIR_PORT="$SISPMCTL_WEBDIR-$sis_webport"
	[ -d "$WEBDIR_PORT" ] || mkdir "$WEBDIR_PORT" >/dev/null 2>&1
	retval=$?
	if [ $retval -eq 0 ]
	then
		[ -n "$WEBDIR_PORT" -a -d "$WEBDIR_PORT" ] && rm -R -f ${WEBDIR_PORT}/* >/dev/null 2>&1
		if [ -n "$SISPMCTL_SKIN" -a -d "/usr/share/sispmctl-$SISPMCTL_SKIN" ]
		then
			WEB_SOURCE_DIR="/usr/share/sispmctl-${SISPMCTL_SKIN}"
		else
			[ -d "$SISPMCTL_DEFAULT_WEBDIR" ] && WEB_SOURCE_DIR="$SISPMCTL_DEFAULT_WEBDIR" || WEB_SOURCE_DIR=""
		fi
		if [ -n "$WEB_SOURCE_DIR" ]
		then
			ls -1 "$WEB_SOURCE_DIR" | while read file_name
			do
				if [ "$file_name" = "index.html" ]
				then
					# index.html is parced for user defined name conversion
					cat /usr/share/sispmctl-${SISPMCTL_SKIN}/index.html \
					| sed -e "s/<title>\([^\<]*\)<\/title>/<title>*** \1 *** $sis_name ***<\/title>/" \
					| sed -e "s/<TITLE>sispmctl_http<\/TITLE>/<TITLE>*** $sis_name ***<\/TITLE>/" \
					| sed -e "s/<H1> Power Management <\/H1>/<H1> $sis_name <\/H1>/" \
					| sed -e "s/Power<BR>Management/$sis_name/" \
					| sed -e "s/Socket 1/$NAME_O1/g;s/Socket 2/$NAME_O2/g;s/Socket 3/$NAME_O3/g;s/Socket 4/$NAME_O4/g;" \
					> ${WEBDIR_PORT}/index.html
				else
					# all other files are symbolic linked
					ln -s /usr/share/sispmctl-${SISPMCTL_SKIN}/${file_name} ${WEBDIR_PORT}/${file_name}
				fi
			done 
		else
			echo "Starting ${DAEMON_LONG_NAME} ... web directory not found ... failed"
			retval=1
		fi
	else
		echo "Starting ${DAEMON_LONG_NAME} ... Can not create $SISPMCTL_WEBDIR ... failed"
	fi
	return $retval
}

pre_config()
{
	return 0
}

start()
{
	sispmss="$(sispmctl -s)"
	IDs="$(echo "$sispmss" | sed -n -e '/serial number/s/serial number\:[[:space:]]*//p')"
	if [ -n "$IDs" ]
	then
		echo "Starting ${DAEMON_LONG_NAME}:"
		NUMB_DEV=$(echo "$IDs" | wc -l)
		ii=1
		while [ $ii -le $NUMB_DEV ]
		do
			curr_id="$(echo "$IDs" | sed -n "${ii}p")"
			jj=1
			ll=0
			# search for found devices in freetz configuration
			while [ $jj -le $((SISPMCTL_NUMOFDEV)) ]
			do
				eval ID_GLOBAL=\$SISPMCTL_D${jj}_ID
				if [ "$curr_id" = "$ID_GLOBAL" ]
				then
					if [ $ll -eq 0 ]
					then
						ll=$jj
						prepare_webdir ${jj} && sispmctl_daemon ${jj}
						retval=$?
					fi
				fi
				jj=$(($jj + 1))
			done
			ii=$(($ii + 1))
		done
	else
		echo "Starting ${DAEMON_LONG_NAME} ... none SIS-PM device found! ... failed"
		retval=1
	fi
	return $retval
}

stop()
{
	retval=0
	echo ""
	ls -1 ${PID_FILE%.pid}-*| while read pid_file_port
	do
		# all internal web interfaces are killed separately using port-specific PID files
		pid_file_wo_pid="${pid_file_port%.pid}"
		curr_port="${pid_file_wo_pid##*-}"
		curr_pid="$(cat ${pid_file_port} 2>/dev/null)"
		echo -n "  Stopping internal web interface on port $curr_port ... "
		if kill $curr_pid >/dev/null 2>&1
		then
			rm -f ${pid_file_port} >/dev/null 2>&1
			echo "done."
		else
			retval=1
			echo "failed"
		fi
	done
	echo -n "Stopping operations ... "
	return $retval
}

case $1 in
	""|load)
		pre_config

		modreg cgi 'sispmctl' 'SIS-PM'
		modreg daemon $DAEMON

		modlib_start $SISPMCTL_ENABLED
		;;
	unload)
		modunreg daemon $DAEMON
		modunreg cgi 'sispmctl'
		modlib_stop
		;;
	start)
		modlib_start
		;;
	stop)
		modlib_stop
		;;
	restart)
		modlib_restart
		;;
	status)
		modlib_status
		;;
	*)
		echo "Usage: $0 [load|unload|start|stop|restart|status]" 1>&2
		exit 1
		;;
esac

exit 0
