diff -burN source/auth/auth_compat.c source/auth/auth_compat.c
--- source/auth/auth_compat.c	2006-04-20 04:29:20.000000000 +0200
+++ source/auth/auth_compat.c	2007-07-17 13:19:05.000000000 +0200
@@ -92,18 +92,25 @@
 check if a username/password pair is ok via the auth subsystem.
 return True if the password is correct, False otherwise
 ****************************************************************************/
+
 BOOL password_ok(char *smb_name, DATA_BLOB password_blob)
 {
 
 	DATA_BLOB null_password = data_blob(NULL, 0);
-	BOOL encrypted = (global_encrypted_passwords_negotiated && password_blob.length == 24);
+	BOOL encrypted = (global_encrypted_passwords_negotiated && (password_blob.length == 24 || password_blob.length > 46));
 	
 	if (encrypted) {
 		/* 
 		 * The password could be either NTLM or plain LM.  Try NTLM first, 
 		 * but fall-through as required.
-		 * NTLMv2 makes no sense here.
+		 * Vista sends NTLMv2 here - we need to try the client given workgroup.
 		 */
+		if (get_session_workgroup()) {
+			if (NT_STATUS_IS_OK(pass_check_smb(smb_name, get_session_workgroup(), null_password, password_blob, null_password, encrypted))) {
+				return True;
+			}
+		}
+
 		if (NT_STATUS_IS_OK(pass_check_smb(smb_name, lp_workgroup(), null_password, password_blob, null_password, encrypted))) {
 			return True;
 		}
@@ -119,5 +126,3 @@
 
 	return False;
 }
-
-
diff -burN source/auth/auth_util.c source/auth/auth_util.c
--- source/auth/auth_util.c	2007-02-04 19:59:14.000000000 +0100
+++ source/auth/auth_util.c	2007-07-17 13:19:05.000000000 +0200
@@ -2043,18 +2043,20 @@
 		/* The only other possible result is that winbind is not up
 		   and running. We need to update the trustdom_cache
 		   ourselves */
-		
+#ifndef AVM_SMALLER		
 		update_trustdom_cache();
+#endif
 	}
 
 	/* now the trustdom cache should be available a DC could still
 	 * have a transitive trust so fall back to the cache of trusted
 	 * domains (like a domain member would use  */
 
+#ifndef AVM_SMALLER
 	if ( trustdom_cache_fetch(dom_name, &trustdom_sid) ) {
 		return True;
 	}
-
+#endif
 	return False;
 }
 
diff -burN source/include/debug.h source/include/debug.h
--- source/include/debug.h	2006-04-20 04:29:39.000000000 +0200
+++ source/include/debug.h	2007-08-07 09:38:18.000000000 +0200
@@ -162,6 +162,26 @@
  * will remove the extra conditional test.
  */
 
+#if 1 /* AR7 */
+
+#define DEBUGLVL( level ) (0)
+#define DEBUGLVLC( dbgc_class, level ) (0)
+#ifndef SAMBA_DEBUG
+#define DEBUG( level, body ) (0)
+#define Log(x) (0)
+#else
+void _fDebug(char *fmt, ...);
+#define DEBUG( level, body ) _fDebug  body
+#define Log(x) _fLog x
+void _fLog(char *fmt, ...);
+#endif
+
+#define DEBUGC( dbgc_class, level, body ) (0)
+#define DEBUGADD( level, body ) (0)
+#define DEBUGADDC( dbgc_class, level, body ) (0)
+
+#else
+
 #define DEBUGLVL( level ) \
   ( ((level) <= MAX_DEBUG_LEVEL) && \
      ((DEBUGLEVEL_CLASS[ DBGC_CLASS ] >= (level))||  \
@@ -208,8 +228,13 @@
             DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \
        && (dbgtext body) )
 
+#endif /* AR7 */
+
+
 /* Print a separator to the debug log. */
 #define DEBUGSEP(level)\
 	DEBUG((level),("===============================================================\n"))
 
+
+
 #endif
diff -burN source/include/local.h source/include/local.h
--- source/include/local.h	2006-04-20 04:29:39.000000000 +0200
+++ source/include/local.h	2007-07-17 13:19:05.000000000 +0200
@@ -16,7 +16,8 @@
    only important messages. This gives *much* smaller binaries
 */
 #ifndef MAX_DEBUG_LEVEL
-#define MAX_DEBUG_LEVEL 1000
+/* AR7 #define MAX_DEBUG_LEVEL 1000 */
+#define MAX_DEBUG_LEVEL 0
 #endif
 
 /* This defines the section name in the configuration file that will contain */
@@ -49,7 +50,8 @@
 #define MAX_DIRECTORY_HANDLES 2048
 
 /* maximum number of file caches per smbd */
-#define MAX_WRITE_CACHES 10
+/* #define MAX_WRITE_CACHES 10 */
+#define MAX_WRITE_CACHES 2 /* AVM */
 
 /* define what facility to use for syslog */
 #ifndef SYSLOG_FACILITY
diff -burN source/include/smb.h source/include/smb.h
--- source/include/smb.h	2007-02-04 19:59:23.000000000 +0100
+++ source/include/smb.h	2007-08-07 09:38:18.000000000 +0200
@@ -1436,6 +1436,7 @@
 #define FLAGS2_LONG_PATH_COMPONENTS    0x0001
 #define FLAGS2_EXTENDED_ATTRIBUTES     0x0002
 #define FLAGS2_SMB_SECURITY_SIGNATURES 0x0004
+#define FLAGS2_UNKNOWN_BIT4            0x0010
 #define FLAGS2_IS_LONG_NAME            0x0040
 #define FLAGS2_EXTENDED_SECURITY       0x0800 
 #define FLAGS2_DFS_PATHNAMES           0x1000
@@ -1499,7 +1500,8 @@
 
 /* Remote architectures we know about. */
 enum remote_arch_types {RA_UNKNOWN, RA_WFWG, RA_OS2, RA_WIN95, RA_WINNT,
-			RA_WIN2K, RA_WINXP, RA_WIN2K3, RA_SAMBA, RA_CIFSFS};
+			RA_WIN2K, RA_WINXP, RA_WIN2K3, RA_VISTA,
+			RA_SAMBA, RA_CIFSFS};
 
 /* case handling */
 enum case_handling {CASE_LOWER,CASE_UPPER};
diff -burN source/include/smb_macros.h source/include/smb_macros.h
--- source/include/smb_macros.h	2006-04-20 04:29:39.000000000 +0200
+++ source/include/smb_macros.h	2007-08-07 09:38:18.000000000 +0200
@@ -310,7 +310,6 @@
 #if defined(PARANOID_MALLOC_CHECKER)
 
 #define PRS_ALLOC_MEM(ps, type, count) (type *)prs_alloc_mem_((ps),sizeof(type),(count))
-#define PRS_ALLOC_MEM_VOID(ps, size) prs_alloc_mem_((ps),(size),1)
 
 /* Get medieval on our ass about malloc.... */
 
@@ -354,7 +353,6 @@
 #define __location__ __FILE__ ":" __LINESTR__
 
 #define PRS_ALLOC_MEM(ps, type, count) (type *)prs_alloc_mem((ps),sizeof(type),(count))
-#define PRS_ALLOC_MEM_VOID(ps, size) prs_alloc_mem((ps),(size),1)
 
 /* Regular malloc code. */
 
diff -burN source/lib/charcnv.c source/lib/charcnv.c
--- source/lib/charcnv.c	2006-04-20 04:29:23.000000000 +0200
+++ source/lib/charcnv.c	2007-08-07 09:38:18.000000000 +0200
@@ -1398,5 +1398,5 @@
 	/* We're hosed - we don't know how big this is... */
 	DEBUG(10,("next_mb_char_size: unknown size at string %s\n", s));
 	conv_silent = False;
-	return 1;
+	return (size_t)-1;
 }
diff -burN source/lib/dummysmbd.c source/lib/dummysmbd.c
--- source/lib/dummysmbd.c	2006-04-20 04:29:23.000000000 +0200
+++ source/lib/dummysmbd.c	2007-08-07 09:38:18.000000000 +0200
@@ -38,3 +38,9 @@
 {
 	return False;
 }
+
+NTSTATUS can_delete_directory(struct connection_struct *conn,
+                                const char *dirname)
+{
+	return NT_STATUS_OK;
+}
diff -burN source/lib/fsusage.c source/lib/fsusage.c
--- source/lib/fsusage.c	2005-02-25 18:59:32.000000000 +0100
+++ source/lib/fsusage.c	2007-07-17 13:19:05.000000000 +0200
@@ -51,6 +51,8 @@
 #define CONVERT_BLOCKS(B) adjust_blocks ((SMB_BIG_UINT)(B), (SMB_BIG_UINT)fsd.f_fsize, (SMB_BIG_UINT)512)
 	struct statfs fsd;
 
+
+// #error STAT_STATFS3_OSF1
 	if (statfs (path, &fsd, sizeof (struct statfs)) != 0)
 		return -1;
 #endif /* STAT_STATFS3_OSF1 */
@@ -59,6 +61,7 @@
 #define CONVERT_BLOCKS(B) adjust_blocks ((SMB_BIG_UINT)(B), (SMB_BIG_UINT)1024, (SMB_BIG_UINT)512)	
 	struct fs_data fsd;
 	
+// #error STAT_STATFS2_FS_DATA
 	if (statfs (path, &fsd) != 1)
 		return -1;
 	
@@ -70,6 +73,7 @@
 #define CONVERT_BLOCKS(B) adjust_blocks ((SMB_BIG_UINT)(B), (SMB_BIG_UINT)fsd.f_bsize, (SMB_BIG_UINT)512)
 	struct statfs fsd;
 	
+// #error STAT_STATFS2_FS_BSIZE
 	if (statfs (path, &fsd) < 0)
 		return -1;
 	
@@ -93,6 +97,7 @@
 	
 	struct statfs fsd;
 	
+// #error STAT_STATFS2_FSIZE
 	if (statfs (path, &fsd) < 0)
 		return -1;
 #endif /* STAT_STATFS2_FSIZE */
@@ -114,6 +119,7 @@
 	
 	struct statfs fsd;
 
+// #error STAT_STATFS4
 	if (statfs (path, &fsd, sizeof fsd, 0) < 0)
 		return -1;
 	/* Empirically, the block counts on most SVR3 and SVR3-derived
@@ -127,9 +133,11 @@
 	adjust_blocks ((SMB_BIG_UINT)(B), fsd.f_frsize ? (SMB_BIG_UINT)fsd.f_frsize : (SMB_BIG_UINT)fsd.f_bsize, (SMB_BIG_UINT)512)
 
 #ifdef STAT_STATVFS64
+// #error STAT_STATVFS64
 	struct statvfs64 fsd;
 	if (statvfs64(path, &fsd) < 0) return -1;
 #else
+// #error STAT_STATVFS
 	struct statvfs fsd;
 	if (statvfs(path, &fsd) < 0) return -1;
 #endif
@@ -139,6 +147,7 @@
 #endif /* STAT_STATVFS */
 
 #ifndef CONVERT_BLOCKS
+#error no STAT_STATxxx defined - we have no dfree code!
 	/* we don't have any dfree code! */
 	return -1;
 #else
diff -burN source/lib/iconv.c source/lib/iconv.c
--- source/lib/iconv.c	2007-02-04 19:59:17.000000000 +0100
+++ source/lib/iconv.c	2007-07-17 13:19:05.000000000 +0200
@@ -388,7 +388,10 @@
 
 	while (*inbytesleft >= 2 && *outbytesleft >= 1) {
 		(*outbuf)[0] = (*inbuf)[0];
-		if ((*inbuf)[1]) ir_count++;
+		if ((*inbuf)[1]) {
+			ir_count++;
+			(*outbuf)[0] = '_'; // AR7
+		}
 		(*inbytesleft)  -= 2;
 		(*outbytesleft) -= 1;
 		(*inbuf)  += 2;
diff -burN source/lib/pidfile.c source/lib/pidfile.c
--- source/lib/pidfile.c	2007-02-04 19:59:17.000000000 +0100
+++ source/lib/pidfile.c	2007-07-17 13:19:05.000000000 +0200
@@ -82,19 +82,20 @@
 {
 	int     fd;
 	char    buf[20];
-	char    *short_configfile;
 	pstring name;
 	pstring pidFile;
 	pid_t pid;
 
+#if 0 /* AVM */
 	/* Add a suffix to the program name if this is a process with a
 	 * none default configuration file name. */
 	if (strcmp( CONFIGFILE, dyn_CONFIGFILE) == 0) {
 		strncpy( name, program_name, sizeof( name)-1);
 	} else {
-		short_configfile = strrchr( dyn_CONFIGFILE, '/');
+		char    *short_configfile = strrchr( dyn_CONFIGFILE, '/');
 		slprintf( name, sizeof( name)-1, "%s-%s", program_name, short_configfile+1);
 	}
+#endif
 
 	slprintf(pidFile, sizeof(pidFile)-1, "%s/%s.pid", lp_piddir(), name);
 
diff -burN source/lib/smbrun.c source/lib/smbrun.c
--- source/lib/smbrun.c	2006-04-20 04:29:23.000000000 +0200
+++ source/lib/smbrun.c	2007-08-07 09:38:18.000000000 +0200
@@ -55,7 +55,7 @@
 outfd (or discard it if outfd is NULL).
 ****************************************************************************/
 
-int smbrun(const char *cmd, int *outfd)
+static int smbrun_internal(const char *cmd, int *outfd, BOOL sanitize)
 {
 	pid_t pid;
 	uid_t uid = current_user.ut.uid;
@@ -173,13 +173,36 @@
 	}
 #endif
 
-	execl("/bin/sh","sh","-c",cmd,NULL);  
+	{
+		const char *newcmd = sanitize ? escape_shell_string(cmd) : cmd;
+		if (!newcmd) {
+			exit(82);
+		}
+		execl("/bin/sh","sh","-c",newcmd,NULL);  
+	}
 	
 	/* not reached */
-	exit(82);
+	exit(83);
 	return 1;
 }
 
+/****************************************************************************
+ Use only in known safe shell calls (printing).
+****************************************************************************/
+
+int smbrun_no_sanitize(const char *cmd, int *outfd)
+{
+	return smbrun_internal(cmd, outfd, False);
+}
+
+/****************************************************************************
+ By default this now sanitizes shell expansion.
+****************************************************************************/
+
+int smbrun(const char *cmd, int *outfd)
+{
+	return smbrun_internal(cmd, outfd, True);
+}
 
 /****************************************************************************
 run a command being careful about uid/gid handling and putting the output in
diff -burN source/lib/util.c source/lib/util.c
--- source/lib/util.c	2007-02-04 19:59:17.000000000 +0100
+++ source/lib/util.c	2007-08-07 09:38:18.000000000 +0200
@@ -300,7 +300,11 @@
 	char *p;
 	if ((p = getenv("TMPDIR")))
 		return p;
+#if 1 /* AR7 */
+	return "/var/tmp";
+#else
 	return "/tmp";
+#endif
 }
 
 /****************************************************************************
@@ -2182,6 +2186,9 @@
 	case RA_WIN2K3:
 		fstrcpy(remote_arch, "Win2K3");
 		break;
+	case RA_VISTA:
+		fstrcpy(remote_arch, "Vista");
+		break;
 	case RA_SAMBA:
 		fstrcpy(remote_arch,"Samba");
 		break;
diff -burN source/lib/util_sec.c source/lib/util_sec.c
--- source/lib/util_sec.c	2007-02-04 19:59:17.000000000 +0100
+++ source/lib/util_sec.c	2007-08-07 09:38:18.000000000 +0200
@@ -286,28 +286,6 @@
 }
 
 /****************************************************************************
- Lightweight become root - no group change.
-****************************************************************************/
-
-void become_root_uid_only(void)
-{
-	save_re_uid();
-	set_effective_uid(0);
-}
-
-/****************************************************************************
- Lightweight unbecome root - no group change. Expects we are root already,
- saves errno across call boundary.
-****************************************************************************/
-
-void unbecome_root_uid_only(void)
-{
-	int saved_errno = errno;
-	restore_re_uid_fromroot();
-	errno = saved_errno;
-}
-
-/****************************************************************************
  save the real and effective gid for later restoration. Used by the 
  getgroups code
 ****************************************************************************/
diff -burN source/lib/util_str.c source/lib/util_str.c
--- source/lib/util_str.c	2007-02-04 19:59:17.000000000 +0100
+++ source/lib/util_str.c	2007-08-07 09:38:18.000000000 +0200
@@ -680,14 +680,14 @@
 
 	for(i = 0; i < len; i++) {
 		int val = (src[i] & 0xff);
-		if (isupper_ascii(val) || islower_ascii(val) || isdigit(val) || strchr_m(other_safe_chars, val))
+		if (isupper_ascii(val) || islower_ascii(val) || isdigit(val) || strchr_m(other_safe_chars, val)) {
 			dest[i] = src[i];
-		else
+		} else {
 			dest[i] = '_';
 	}
+	}
 
 	dest[i] = '\0';
-
 	return dest;
 }
 
@@ -2426,3 +2426,165 @@
 	return True;
 }
 
+
+/*******************************************************************
+ Add a shell escape character '\' to any character not in a known list
+ of characters. UNIX charset format.
+*******************************************************************/
+
+#define INCLUDE_LIST "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_/ \t.,"
+#define INSIDE_DQUOTE_LIST "$`\n\"\\"
+
+char *escape_shell_string(const char *src)
+{
+	size_t srclen = strlen(src);
+	char *ret = SMB_MALLOC((srclen * 2) + 1);
+	char *dest = ret;
+	BOOL in_s_quote = False;
+	BOOL in_d_quote = False;
+	BOOL next_escaped = False;
+
+	if (!ret) {
+		return NULL;
+	}
+
+	while (*src) {
+		size_t c_size = next_mb_char_size(src);
+
+		if (c_size == (size_t)-1) {
+			SAFE_FREE(ret);
+			return NULL;
+		}
+
+		if (c_size > 1) {
+			memcpy(dest, src, c_size);
+			src += c_size;
+			dest += c_size;
+			next_escaped = False;
+			continue;
+		}
+
+		/*
+		 * Deal with backslash escaped state.
+		 * This only lasts for one character.
+		 */
+
+		if (next_escaped) {
+			*dest++ = *src++;
+			next_escaped = False;
+			continue;
+		}
+
+		/*
+		 * Deal with single quote state. The
+		 * only thing we care about is exiting
+		 * this state.
+		 */
+
+		if (in_s_quote) {
+			if (*src == '\'') {
+				in_s_quote = False;
+			}
+			*dest++ = *src++;
+			continue;
+		}
+
+		/* 
+		 * Deal with double quote state. The most
+		 * complex state. We must cope with \, meaning
+		 * possibly escape next char (depending what it
+		 * is), ", meaning exit this state, and possibly
+		 * add an \ escape to any unprotected character
+		 * (listed in INSIDE_DQUOTE_LIST).
+		 */
+
+		if (in_d_quote) {
+			if (*src == '\\') {
+				/* 
+				 * Next character might be escaped.
+				 * We have to peek. Inside double
+				 * quotes only INSIDE_DQUOTE_LIST
+				 * characters are escaped by a \.
+				 */
+
+				char nextchar;
+
+				c_size = next_mb_char_size(&src[1]);
+				if (c_size == (size_t)-1) {
+					SAFE_FREE(ret);
+					return NULL;
+				}
+				if (c_size > 1) {
+					/*
+					 * Don't escape the next char.
+					 * Just copy the \.
+					 */
+					*dest++ = *src++;
+					continue;
+				}
+
+				nextchar = src[1];
+
+				if (nextchar && strchr(INSIDE_DQUOTE_LIST, (int)nextchar)) {
+					next_escaped = True;
+				}
+				*dest++ = *src++;
+				continue;
+			}
+
+			if (*src == '\"') {
+				/* Exit double quote state. */
+				in_d_quote = False;
+				*dest++ = *src++;
+				continue;
+			}
+
+			/*
+			 * We know the character isn't \ or ",
+			 * so escape it if it's any of the other
+			 * possible unprotected characters.
+			 */
+
+	       		if (strchr(INSIDE_DQUOTE_LIST, (int)*src)) {
+				*dest++ = '\\';
+			}
+			*dest++ = *src++;
+			continue;
+		}
+
+		/* 
+		 * From here to the end of the loop we're
+		 * not in the single or double quote state.
+		 */
+
+		if (*src == '\\') {
+			/* Next character must be escaped. */
+			next_escaped = True;
+			*dest++ = *src++;
+			continue;
+		}
+
+		if (*src == '\'') {
+			/* Go into single quote state. */
+			in_s_quote = True;
+			*dest++ = *src++;
+			continue;
+		}
+
+		if (*src == '\"') {
+			/* Go into double quote state. */
+			in_d_quote = True;
+			*dest++ = *src++;
+			continue;
+		}
+
+		/* Check if we need to escape the character. */
+
+	       	if (!strchr(INCLUDE_LIST, (int)*src)) {
+			*dest++ = '\\';
+		}
+		*dest++ = *src++;
+	}
+	*dest++ = '\0';
+	return ret;
+}
diff -burN source/libads/authdata.c source/libads/authdata.c
--- source/libads/authdata.c	2006-02-23 17:29:34.000000000 +0100
+++ source/libads/authdata.c	2007-08-07 09:38:18.000000000 +0200
@@ -120,11 +120,15 @@
 		return False;
 
 	if (UNMARSHALLING(ps)) {
+		if (num) {
 		array->krb_sid_and_attrs = PRS_ALLOC_MEM(ps, KRB_SID_AND_ATTRS, num);
 		if (!array->krb_sid_and_attrs) {
 			DEBUG(3, ("No memory available\n"));
 			return False;
 		}
+		} else {
+			array->krb_sid_and_attrs = NULL;
+		}
 	}
 
 	for (i=0; i<num; i++) {
@@ -184,11 +188,15 @@
 		return False;
 
 	if (UNMARSHALLING(ps)) {
+		if (num) {
 		array->group_membership = PRS_ALLOC_MEM(ps, GROUP_MEMBERSHIP, num);
 		if (!array->group_membership) {
 			DEBUG(3, ("No memory available\n"));
 			return False;
 		}
+		} else {
+			array->group_membership = NULL;
+		}
 	}
 
 	for (i=0; i<num; i++) {
@@ -456,11 +464,15 @@
 		return False;
 
 	if (UNMARSHALLING(ps) && length) {
+		if (siglen) {
 		data->signature.buffer = PRS_ALLOC_MEM(ps, uint8, siglen);
 		if (!data->signature.buffer) {
 			DEBUG(3, ("No memory available\n"));
 			return False;
 		}
+		} else {
+			data->signature.buffer = NULL;
+		}
 	}
 
 	data->signature.buf_len = siglen;
diff -burN source/libsmb/clifile.c source/libsmb/clifile.c
--- source/libsmb/clifile.c	2007-02-04 19:59:20.000000000 +0100
+++ source/libsmb/clifile.c	2007-07-17 13:19:05.000000000 +0200
@@ -21,6 +21,8 @@
 
 #include "includes.h"
 
+#ifndef AVM_SMALLER
+
 /****************************************************************************
  Hard/Symlink a file (UNIX extensions).
  Creates new name (sym)linked to oldname.
@@ -71,6 +73,9 @@
 	return True;
 }
 
+#endif /* AVM_SMALLER */
+
+
 /****************************************************************************
  Map standard UNIX permissions onto wire representations.
 ****************************************************************************/
@@ -165,6 +170,9 @@
 	}
 }
 
+
+#ifndef AVM_SMALLER
+
 /****************************************************************************
  Do a POSIX getfacl (UNIX extensions).
 ****************************************************************************/
@@ -1759,3 +1767,6 @@
 
 	return cli_get_ea_list(cli, setup, param, 6, ctx, pnum_eas, pea_list);
 }
+
+#endif /* AVM_SMALLER */
+
diff -burN source/libsmb/namequery.c source/libsmb/namequery.c
--- source/libsmb/namequery.c	2007-02-04 19:59:20.000000000 +0100
+++ source/libsmb/namequery.c	2007-07-17 13:19:05.000000000 +0200
@@ -1024,6 +1024,7 @@
 static BOOL resolve_ads(const char *name, int name_type,
                          struct ip_service **return_iplist, int *return_count)
 {
+#ifdef HAVE_ADS
 	int 			i, j;
 	NTSTATUS  		status;
 	TALLOC_CTX		*ctx;
@@ -1100,6 +1101,9 @@
 		
 	talloc_destroy(ctx);
 	return True;
+#else 	/* HAVE_ADS */
+	return False;
+#endif
 }
 
 /*******************************************************************
diff -burN source/libsmb/namequery_dc.c source/libsmb/namequery_dc.c
--- source/libsmb/namequery_dc.c	2006-04-20 04:29:25.000000000 +0200
+++ source/libsmb/namequery_dc.c	2007-07-17 13:19:05.000000000 +0200
@@ -31,6 +31,9 @@
  
 static BOOL ads_dc_name(const char *domain, const char *realm, struct in_addr *dc_ip, fstring srv_name)
 {
+#if 1 /* AR7 */
+	return False;
+#else 
 	ADS_STRUCT *ads;
 
 	if (!realm && strequal(domain, lp_workgroup()))
@@ -63,6 +66,7 @@
 		 srv_name, inet_ntoa(*dc_ip)));
 	
 	return True;
+#endif /* AR7 */
 }
 
 /****************************************************************************
diff -burN source/locking/locking.c source/locking/locking.c
--- source/locking/locking.c	2007-02-04 19:59:23.000000000 +0100
+++ source/locking/locking.c	2007-08-07 09:38:18.000000000 +0200
@@ -1166,6 +1166,11 @@
 		return NT_STATUS_ACCESS_DENIED;
 	}
 
+	/* Don't allow delete on close for non-empty directories. */
+	if (fsp->is_directory) {
+		return can_delete_directory(fsp->conn, fsp->fsp_name);
+	}
+
 	return NT_STATUS_OK;
 }
 
diff -burN source/passdb/lookup_sid.c source/passdb/lookup_sid.c
--- source/passdb/lookup_sid.c	2007-02-04 19:59:21.000000000 +0100
+++ source/passdb/lookup_sid.c	2007-08-07 09:38:18.000000000 +0200
@@ -421,10 +421,10 @@
 			return False;
 		}
 
-		become_root_uid_only();
+		become_root();
 		result = pdb_lookup_rids(domain_sid, num_rids, rids,
 					 *names, *types);
-		unbecome_root_uid_only();
+		unbecome_root();
 
 		return (NT_STATUS_IS_OK(result) ||
 			NT_STATUS_EQUAL(result, NT_STATUS_NONE_MAPPED) ||
@@ -1085,9 +1085,9 @@
 		goto done;
 	}
 
-	become_root_uid_only();
+	become_root();
 	ret = pdb_uid_to_rid(uid, &rid);
-	unbecome_root_uid_only();
+	unbecome_root();
 
 	if (ret) {
 		/* This is a mapped user */
@@ -1131,9 +1131,9 @@
 		goto done;
 	}
 
-	become_root_uid_only();
+	become_root();
 	ret = pdb_gid_to_sid(gid, psid);
-	unbecome_root_uid_only();
+	unbecome_root();
 
 	if (ret) {
 		/* This is a mapped group */
@@ -1179,9 +1179,9 @@
 		union unid_t id;
 		BOOL ret;
 
-		become_root_uid_only();
+		become_root();
 		ret = pdb_sid_to_id(psid, &id, &type);
-		unbecome_root_uid_only();
+		unbecome_root();
 
 		if (ret) {
 			if (type != SID_NAME_USER) {
@@ -1259,9 +1259,9 @@
 	     sid_check_is_in_wellknown_domain(psid))) {
 		BOOL ret;
 
-		become_root_uid_only();
+		become_root();
 		ret = pdb_getgrsid(&map, *psid);
-		unbecome_root_uid_only();
+		unbecome_root();
 
 		if (ret) {
 			*pgid = map.gid;
@@ -1273,9 +1273,9 @@
 	if (sid_peek_check_rid(get_global_sam_sid(), psid, &rid)) {
 		BOOL ret;
 
-		become_root_uid_only();
+		become_root();
 		ret = pdb_sid_to_id(psid, &id, &type);
-		unbecome_root_uid_only();
+		unbecome_root();
 
 		if (ret) {
 			if ((type != SID_NAME_DOM_GRP) &&
diff -burN source/printing/nt_printing.c source/printing/nt_printing.c
--- source/printing/nt_printing.c	2007-02-04 20:09:01.000000000 +0100
+++ source/printing/nt_printing.c	2007-08-07 09:38:18.000000000 +0200
@@ -2984,11 +2984,15 @@
 	return True;
 }
 
+/*****************************************************************
+ ****************************************************************/
+
 static void store_printer_guid(NT_PRINTER_INFO_LEVEL_2 *info2, 
 			       struct uuid guid)
 {
 	int i;
 	REGVAL_CTR *ctr=NULL;
+	UNISTR2 unistr_guid;
 
 	/* find the DsSpooler key */
 	if ((i = lookup_printerkey(info2->data, SPOOL_DSSPOOLER_KEY)) < 0)
@@ -2996,8 +3000,18 @@
 	ctr = info2->data->keys[i].values;
 
 	regval_ctr_delvalue(ctr, "objectGUID");
-	regval_ctr_addvalue(ctr, "objectGUID", REG_BINARY, 
-			    (char *) &guid, sizeof(struct uuid));	
+
+	/* We used to store this as a REG_BINARY but that causes
+	   Vista to whine */
+
+	ZERO_STRUCT( unistr_guid );	
+	init_unistr2( &unistr_guid, smb_uuid_string_static(guid),
+		      UNI_STR_TERMINATE );
+
+	regval_ctr_addvalue(ctr, "objectGUID", REG_SZ, 
+			    (char *)unistr_guid.buffer, 
+			    unistr_guid.uni_max_len*2);
+	
 }
 
 static WERROR nt_printer_publish_ads(ADS_STRUCT *ads,
@@ -3254,6 +3268,7 @@
 	REGISTRY_VALUE *guid_val;
 	WERROR win_rc;
 	int i;
+	BOOL ret = False;
 
 	win_rc = get_a_printer(print_hnd, &printer, 2, lp_servicename(snum));
 
@@ -3267,12 +3282,36 @@
 		return False;
 	}
 
-	/* fetching printer guids really ought to be a separate function.. */
-	if (guid && regval_size(guid_val) == sizeof(struct uuid))
+	/* fetching printer guids really ought to be a separate function. */
+
+	if ( guid ) {	
+		fstring guid_str;
+		
+		/* We used to store the guid as REG_BINARY, then swapped 
+		   to REG_SZ for Vista compatibility so check for both */
+
+		switch ( regval_type(guid_val) ){
+		case REG_SZ:		
+			rpcstr_pull( guid_str, regval_data_p(guid_val), 
+				     sizeof(guid_str)-1, -1, STR_TERMINATE );
+			ret = smb_string_to_uuid( guid_str, guid );
+			break;			
+		case REG_BINARY:
+			if ( regval_size(guid_val) != sizeof(struct uuid) ) {
+				ret = False;
+				break;
+			}
 		memcpy(guid, regval_data_p(guid_val), sizeof(struct uuid));
+			break;
+		default:
+			DEBUG(0,("is_printer_published: GUID value stored as "
+				 "invaluid type (%d)\n", regval_type(guid_val) ));			
+			break;
+		}
+	}
 
 	free_a_printer(&printer, 2);
-	return True;
+	return ret;
 }
 #else
 WERROR nt_printer_publish(Printer_entry *print_hnd, int snum, int action)
@@ -3539,13 +3578,43 @@
 			break;
 		}
 		
-		/* add the new value */
+		DEBUG(8,("specific: [%s:%s], len: %d\n", keyname, valuename, size));
+
+		/* Vista doesn't like unknown REG_BINARY values in DsSpooler.  
+		   Thanks to Martin Zielinski for the hint. */
+
+		if ( type == REG_BINARY && 
+		     strequal( keyname, SPOOL_DSSPOOLER_KEY ) && 
+		     strequal( valuename, "objectGUID" ) ) 
+		{
+			struct uuid guid;
+			UNISTR2 unistr_guid;
+
+			ZERO_STRUCT( unistr_guid );
+			
+			/* convert the GUID to a UNICODE string */
+			
+			memcpy( &guid, data_p, sizeof(struct uuid) );
+			
+			init_unistr2( &unistr_guid, smb_uuid_string_static(guid), 
+				      UNI_STR_TERMINATE );
+			
+			regval_ctr_addvalue( printer_data->keys[key_index].values, 
+					     valuename, REG_SZ, 
+					     (const char *)unistr_guid.buffer, 
+					     unistr_guid.uni_str_len*2 );
+
+		} else {
+			/* add the value */
+
+			regval_ctr_addvalue( printer_data->keys[key_index].values, 
+					     valuename, type, (const char *)data_p, 
+					     size );
+		}
 		
-		regval_ctr_addvalue( printer_data->keys[key_index].values, valuename, type, (const char *)data_p, size );
 
 		SAFE_FREE(data_p); /* 'B' option to tdbpack does a malloc() */
 
-		DEBUG(8,("specific: [%s:%s], len: %d\n", keyname, valuename, size));
 	}
 
 	return len;
diff -burN source/printing/print_generic.c source/printing/print_generic.c
--- source/printing/print_generic.c	2007-02-04 19:59:13.000000000 +0100
+++ source/printing/print_generic.c	2007-08-07 09:38:18.000000000 +0200
@@ -58,7 +58,7 @@
 	if ( do_sub && snum != -1 )
 		standard_sub_snum(snum,syscmd,sizeof(syscmd));
 		
-	ret = smbrun(syscmd,outfd);
+	ret = smbrun_no_sanitize(syscmd,outfd);
 
 	DEBUG(3,("Running the command `%s' gave %d\n",syscmd,ret));
 
diff -burN source/registry/regfio.c source/registry/regfio.c
--- source/registry/regfio.c	2007-02-04 19:59:26.000000000 +0100
+++ source/registry/regfio.c	2007-08-07 09:38:18.000000000 +0200
@@ -642,8 +642,12 @@
 		return False;
 
 	if ( UNMARSHALLING(&hbin->ps) ) {
+		if (lf->num_keys) {
 		if ( !(lf->hashes = PRS_ALLOC_MEM( &hbin->ps, REGF_HASH_REC, lf->num_keys )) )
 			return False;
+		} else {
+			lf->hashes = NULL;
+		}
 	}
 
 	for ( i=0; i<lf->num_keys; i++ ) {
diff -burN source/registry/reg_frontend.c source/registry/reg_frontend.c
--- source/registry/reg_frontend.c	2005-11-09 19:29:03.000000000 +0100
+++ source/registry/reg_frontend.c	2007-07-17 13:19:05.000000000 +0200
@@ -35,9 +35,11 @@
 
 REGISTRY_HOOK reg_hooks[] = {
 #ifndef REG_TDB_ONLY 
+#ifndef AVM_NO_PRINTING
   { KEY_PRINTING,    		&printing_ops },
   { KEY_PRINTING_2K, 		&printing_ops },
   { KEY_PRINTING_PORTS, 	&printing_ops },
+#endif
   { KEY_SHARES,      		&shares_reg_ops },
 #endif
   { NULL, NULL }
diff -burN source/rpc_client/cli_pipe.c source/rpc_client/cli_pipe.c
--- source/rpc_client/cli_pipe.c	2007-02-04 19:59:11.000000000 +0100
+++ source/rpc_client/cli_pipe.c	2007-07-17 13:19:05.000000000 +0200
@@ -619,7 +619,11 @@
 
 			DEBUG(1, ("cli_pipe_validate_current_pdu: RPC fault code %s received from remote machine %s "
 				"pipe %s fnum 0x%x!\n",
+#if 1 /* AVM */
+				"ERRSTR-REPLACEMENT",
+#else
 				dcerpc_errstr(NT_STATUS_V(fault_resp.status)),
+#endif
 				cli->cli->desthost,
 				cli->pipe_name,
 				(unsigned int)cli->fnum));
diff -burN source/rpc_parse/parse_dfs.c source/rpc_parse/parse_dfs.c
--- source/rpc_parse/parse_dfs.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_dfs.c	2007-08-07 09:38:18.000000000 +0200
@@ -325,7 +325,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->stores = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->stores)*v->num_stores);
+			v->stores = PRS_ALLOC_MEM(ps,NETDFS_DFS_STORAGEINFO,v->num_stores);
+			if (!v->stores)
+				return False;
 		}
 		for (i_stores_1=0; i_stores_1<v->num_stores;i_stores_1++) {
 			if (!netdfs_io_dfs_StorageInfo_p("stores", &v->stores[i_stores_1], ps, depth))
@@ -447,7 +449,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->stores = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->stores)*v->num_stores);
+			v->stores = PRS_ALLOC_MEM(ps,NETDFS_DFS_STORAGEINFO,v->num_stores);
+			if (!v->stores)
+				return False;
 		}
 		for (i_stores_1=0; i_stores_1<v->num_stores;i_stores_1++) {
 			if (!netdfs_io_dfs_StorageInfo_p("stores", &v->stores[i_stores_1], ps, depth))
@@ -920,7 +924,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO1,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info1_p("s", &v->s[i_s_1], ps, depth))
@@ -986,7 +992,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO2,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info2_p("s", &v->s[i_s_1], ps, depth))
@@ -1052,7 +1060,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO3,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info3_p("s", &v->s[i_s_1], ps, depth))
@@ -1118,7 +1128,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO4,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info4_p("s", &v->s[i_s_1], ps, depth))
@@ -1184,7 +1196,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO200,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info200_p("s", &v->s[i_s_1], ps, depth))
@@ -1250,7 +1264,9 @@
 			return False;
 		
 		if (UNMARSHALLING(ps)) {
-			v->s = (void *)PRS_ALLOC_MEM_VOID(ps,sizeof(*v->s)*v->count);
+			v->s = PRS_ALLOC_MEM(ps,NETDFS_DFS_INFO300,v->count);
+			if (!v->s)
+				return False;
 		}
 		for (i_s_1=0; i_s_1<v->count;i_s_1++) {
 			if (!netdfs_io_dfs_Info300_p("s", &v->s[i_s_1], ps, depth))
diff -burN source/rpc_parse/parse_lsa.c source/rpc_parse/parse_lsa.c
--- source/rpc_parse/parse_lsa.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_lsa.c	2007-08-07 09:38:18.000000000 +0200
@@ -1171,7 +1171,7 @@
 
 	/* Mallocate memory if we're unpacking from the wire */
 
-	if (UNMARSHALLING(ps)) {
+	if (UNMARSHALLING(ps) && sen->num_entries) {
 		if ((sen->ptr_sid = PRS_ALLOC_MEM( ps, uint32, sen->num_entries)) == NULL) {
 			DEBUG(3, ("init_lsa_sid_enum(): out of memory for "
 				  "ptr_sid\n"));
@@ -1349,12 +1349,17 @@
 			       &trn->num_entries2))
 			return False;
 
-		if (UNMARSHALLING(ps)) {
-			if ((trn->name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME, trn->num_entries)) == NULL) {
+		if (trn->num_entries2 != trn->num_entries) {
+			/* RPC fault */
 				return False;
 			}
 
-			if ((trn->uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn->num_entries)) == NULL) {
+		if (UNMARSHALLING(ps) && trn->num_entries2) {
+			if ((trn->name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME, trn->num_entries2)) == NULL) {
+				return False;
+			}
+
+			if ((trn->uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn->num_entries2)) == NULL) {
 				return False;
 			}
 		}
@@ -1406,12 +1411,17 @@
 			       &trn->num_entries2))
 			return False;
 
-		if (UNMARSHALLING(ps)) {
-			if ((trn->name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME2, trn->num_entries)) == NULL) {
+		if (trn->num_entries2 != trn->num_entries) {
+			/* RPC fault */
 				return False;
 			}
 
-			if ((trn->uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn->num_entries)) == NULL) {
+		if (UNMARSHALLING(ps) && trn->num_entries2) {
+			if ((trn->name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME2, trn->num_entries2)) == NULL) {
+				return False;
+			}
+
+			if ((trn->uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn->num_entries2)) == NULL) {
 				return False;
 			}
 		}
@@ -1678,7 +1688,7 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && out->num_entries2) {
 			if ((out->dom_rid = PRS_ALLOC_MEM(ps, DOM_RID, out->num_entries2))
 			    == NULL) {
 				DEBUG(3, ("lsa_io_r_lookup_names(): out of memory\n"));
@@ -1803,7 +1813,7 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && out->num_entries2) {
 			if ((out->dom_rid = PRS_ALLOC_MEM(ps, DOM_RID2, out->num_entries2))
 			    == NULL) {
 				DEBUG(3, ("lsa_io_r_lookup_names2(): out of memory\n"));
@@ -1956,7 +1966,7 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && out->num_entries2) {
 			if ((out->trans_sids = PRS_ALLOC_MEM(ps, LSA_TRANSLATED_SID3, out->num_entries2))
 			    == NULL) {
 				DEBUG(3, ("lsa_io_r_lookup_names3(): out of memory\n"));
@@ -2085,7 +2095,7 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && out->num_entries2) {
 			if ((out->trans_sids = PRS_ALLOC_MEM(ps, LSA_TRANSLATED_SID3, out->num_entries2))
 			    == NULL) {
 				DEBUG(3, ("lsa_io_r_lookup_names4(): out of memory\n"));
@@ -2324,7 +2334,7 @@
 		if(!prs_uint32("count1", ps, depth, &out->count1))
 			return False;
 
-		if (UNMARSHALLING(ps))
+		if (UNMARSHALLING(ps) && out->count1)
 			if (!(out->privs = PRS_ALLOC_MEM(ps, LSA_PRIV_ENTRY, out->count1)))
 				return False;
 
@@ -2759,7 +2769,7 @@
 
 static BOOL lsa_io_privilege_set(const char *desc, PRIVILEGE_SET *out, prs_struct *ps, int depth)
 {
-	uint32 i;
+	uint32 i, dummy;
 
 	prs_debug(ps, depth, desc, "lsa_io_privilege_set");
 	depth++;
@@ -2767,7 +2777,7 @@
 	if(!prs_align(ps))
 		return False;
  
-	if(!prs_uint32("count", ps, depth, &out->count))
+	if(!prs_uint32("count", ps, depth, &dummy))
 		return False;
 	if(!prs_uint32("control", ps, depth, &out->control))
 		return False;
@@ -3886,7 +3896,7 @@
 	prs_debug(ps, depth, desc, "smb_io_lsa_data_buf");
 	depth++;
 
-	if ( UNMARSHALLING(ps) ) {
+	if ( UNMARSHALLING(ps) && length ) {
 		if ( !(buf->data = PRS_ALLOC_MEM( ps, uint8, length )) )
 			return False;
 	}
@@ -3900,7 +3910,7 @@
 	if (!prs_uint32("length", ps, depth, &buf->length))
 		return False;
 
-	if(!prs_uint8s(False, "data", ps, depth, buf->data, size))
+	if(!prs_uint8s(False, "data", ps, depth, buf->data, length))
 		return False;
 
 	return True;
diff -burN source/rpc_parse/parse_net.c source/rpc_parse/parse_net.c
--- source/rpc_parse/parse_net.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_net.c	2007-08-07 09:38:18.000000000 +0200
@@ -1721,9 +1721,13 @@
 	}
 
 	if (UNMARSHALLING(ps)) {
+		if (usr->num_groups) {
 		usr->gids = PRS_ALLOC_MEM(ps, DOM_GID, usr->num_groups);
 		if (usr->gids == NULL)
 			return False;
+		} else {
+			usr->gids = NULL;
+		}
 	}
 
 	for (i = 0; i < usr->num_groups; i++) {
@@ -1756,9 +1760,14 @@
 			return False;
 
 		if (UNMARSHALLING(ps)) {
+			if (usr->num_other_sids) {
 			usr->other_sids = PRS_ALLOC_MEM(ps, DOM_SID2, usr->num_other_sids);
 			usr->other_sids_attrib =
 				PRS_ALLOC_MEM(ps, uint32, usr->num_other_sids);
+			} else {
+				usr->other_sids = NULL;
+				usr->other_sids_attrib = NULL;
+			}
 							       
 			if ((num_other_sids != 0) &&
 			    ((usr->other_sids == NULL) ||
diff -burN source/rpc_parse/parse_prs.c source/rpc_parse/parse_prs.c
--- source/rpc_parse/parse_prs.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_prs.c	2007-08-07 09:38:18.000000000 +0200
@@ -156,7 +156,7 @@
 {
 	char *ret = NULL;
 
-	if (size) {
+	if (size && count) {
 		/* We can't call the type-safe version here. */
 		ret = _talloc_zero_array(ps->mem_ctx, size, count, "parse_prs");
 	}
@@ -642,8 +642,12 @@
 		return True;
 
 	if (UNMARSHALLING(ps)) {
-		if ( !(*data = PRS_ALLOC_MEM_VOID(ps, data_size)) )
+		if (data_size) {
+			if ( !(*data = (void *)PRS_ALLOC_MEM(ps, char, data_size)) )
 			return False;
+		} else {
+			*data = NULL;
+		}
 	}
 
 	return prs_fn(name, ps, depth, *data);
@@ -790,7 +794,12 @@
 	}
 
 	DEBUG(5,("%s%04x %s: %s\n", tab_depth(depth), ps->data_offset, name, 
-		 dcerpc_errstr(NT_STATUS_V(*status))));
+#if 1 /* AVM */
+				"ERRSTR-REPLACEMENT"
+#else
+		 dcerpc_errstr(NT_STATUS_V(*status))
+#endif
+		 ));
 
 	ps->data_offset += sizeof(uint32);
 
@@ -1014,16 +1023,16 @@
 	if (q == NULL)
 		return False;
 
+	/* If the string is empty, we don't have anything to stream */
+	if (str->buf_len==0)
+		return True;
+
 	if (UNMARSHALLING(ps)) {
 		str->buffer = PRS_ALLOC_MEM(ps,uint16,str->buf_len);
 		if (str->buffer == NULL)
 			return False;
 	}
 
-	/* If the string is empty, we don't have anything to stream */
-	if (str->buf_len==0)
-		return True;
-
 	p = (char *)str->buffer;
 
 	dbg_rw_punival(charmode, name, depth, ps, q, p, str->buf_len);
@@ -1053,6 +1062,8 @@
 			buf->buffer = PRS_ALLOC_MEM(ps, uint16, buf->buf_max_len);
 			if ( buf->buffer == NULL )
 				return False;
+		} else {
+			buf->buffer = NULL;
 		}
 	}
 
@@ -1080,9 +1091,13 @@
 		if (str->str_str_len > str->str_max_len) {
 			return False;
 		}
+		if (str->str_max_len) {
 		str->buffer = PRS_ALLOC_MEM(ps,unsigned char, str->str_max_len);
 		if (str->buffer == NULL)
 			return False;
+		} else {
+			str->buffer = NULL;
+		}
 	}
 
 	if (UNMARSHALLING(ps)) {
@@ -1127,9 +1142,13 @@
 		if (str->uni_str_len > str->uni_max_len) {
 			return False;
 		}
+		if (str->uni_max_len) {
 		str->buffer = PRS_ALLOC_MEM(ps,uint16,str->uni_max_len);
 		if (str->buffer == NULL)
 			return False;
+		} else {
+			str->buffer = NULL;
+		}
 	}
 
 	p = (char *)str->buffer;
@@ -1154,9 +1173,13 @@
 		return False;
 
 	if (UNMARSHALLING(ps)) {
+		if (str->uni_str_len) {
 		str->str.buffer = PRS_ALLOC_MEM(ps,uint16,str->uni_str_len);
 		if (str->str.buffer == NULL)
 			return False;
+		} else {
+			str->str.buffer = NULL;
+		}
 	}
 
 	p = (char *)str->str.buffer;
diff -burN source/rpc_parse/parse_samr.c source/rpc_parse/parse_samr.c
--- source/rpc_parse/parse_samr.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_samr.c	2007-08-07 09:38:18.000000000 +0200
@@ -3337,7 +3337,7 @@
 		if(!prs_uint32("num_entries3", ps, depth, &r_u->num_entries3))
 			return False;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && r_u->num_entries2) {
 			r_u->sam = PRS_ALLOC_MEM(ps,SAM_ENTRY,r_u->num_entries2);
 			r_u->uni_dom_name = PRS_ALLOC_MEM(ps,UNISTR2,r_u->num_entries2);
 		}
@@ -3476,7 +3476,7 @@
 		if(!prs_uint32("num_entries3", ps, depth, &r_u->num_entries3))
 			return False;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && r_u->num_entries2) {
 			r_u->sam = PRS_ALLOC_MEM(ps,SAM_ENTRY,r_u->num_entries2);
 			r_u->uni_grp_name = PRS_ALLOC_MEM(ps,UNISTR2,r_u->num_entries2);
 		}
@@ -4980,13 +4980,14 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps))
+		if (UNMARSHALLING(ps) && r_u->num_rids2) {
 			r_u->rids = PRS_ALLOC_MEM(ps, uint32, r_u->num_rids2);
 
 		if (!r_u->rids) {
 			DEBUG(0, ("NULL rids in samr_io_r_lookup_names\n"));
 			return False;
 		}
+		}
 
 		for (i = 0; i < r_u->num_rids2; i++) {
 			slprintf(tmp, sizeof(tmp) - 1, "rid[%02d]  ", i);
@@ -5009,13 +5010,14 @@
 			return False;
 		}
 
-		if (UNMARSHALLING(ps))
+		if (UNMARSHALLING(ps) && r_u->num_types2) {
 			r_u->types = PRS_ALLOC_MEM(ps, uint32, r_u->num_types2);
 
 		if (!r_u->types) {
 			DEBUG(0, ("NULL types in samr_io_r_lookup_names\n"));
 			return False;
 		}
+		}
 
 		for (i = 0; i < r_u->num_types2; i++) {
 			slprintf(tmp, sizeof(tmp) - 1, "type[%02d]  ", i);
diff -burN source/rpc_parse/parse_sec.c source/rpc_parse/parse_sec.c
--- source/rpc_parse/parse_sec.c	2005-04-18 18:38:20.000000000 +0200
+++ source/rpc_parse/parse_sec.c	2007-08-07 09:38:18.000000000 +0200
@@ -122,7 +122,7 @@
  for you as it reads them.
 ********************************************************************/
 
-BOOL sec_io_acl(const char *desc, SEC_ACL **ppsa, prs_struct *ps, int depth)
+static BOOL sec_io_acl(const char *desc, SEC_ACL **ppsa, prs_struct *ps, int depth)
 {
 	unsigned int i;
 	uint32 old_offset;
@@ -165,14 +165,11 @@
 		return False;
 
 	if (UNMARSHALLING(ps)) {
-		/*
-		 * Even if the num_aces is zero, allocate memory as there's a difference
-		 * between a non-present DACL (allow all access) and a DACL with no ACE's
-		 * (allow no access).
-		 */
-		if((psa->ace = PRS_ALLOC_MEM(ps, SEC_ACE, psa->num_aces+1)) == NULL)
+		if (psa->num_aces) {
+			if((psa->ace = PRS_ALLOC_MEM(ps, SEC_ACE, psa->num_aces)) == NULL)
 			return False;
 	}
+	}
 
 	for (i = 0; i < psa->num_aces; i++) {
 		fstring tmp;
diff -burN source/rpc_parse/parse_spoolss.c source/rpc_parse/parse_spoolss.c
--- source/rpc_parse/parse_spoolss.c	2007-02-04 19:59:22.000000000 +0100
+++ source/rpc_parse/parse_spoolss.c	2007-08-07 09:38:18.000000000 +0200
@@ -227,8 +227,13 @@
 	if(!prs_uint32("count2", ps, depth, &type->count2))
 		return False;
 	
-	if (type->count2 != type->count)
+	if (type->count2 != type->count) {
 		DEBUG(4,("What a mess, count was %x now is %x !\n", type->count, type->count2));
+		return False;
+	}
+	if (type->count2 > MAX_NOTIFY_TYPE_FOR_NOW) {
+		return False;
+	}
 
 	/* parse the option type data */
 	for(i=0;i<type->count2;i++)
@@ -252,7 +257,7 @@
 		return False;
 
 	/* reading */
-	if (UNMARSHALLING(ps))
+	if (UNMARSHALLING(ps) && ctr->count)
 		if((ctr->type=PRS_ALLOC_MEM(ps,SPOOL_NOTIFY_OPTION_TYPE,ctr->count)) == NULL)
 			return False;
 		
@@ -411,7 +416,7 @@
 		if(!prs_uint32("string length", ps, depth, &data->notify_data.data.length))
 			return False;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && data->notify_data.data.length) {
 			data->notify_data.data.string = PRS_ALLOC_MEM(ps, uint16,
 								data->notify_data.data.length);
 
@@ -430,7 +435,7 @@
 
 	case NOTIFY_POINTER:
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && data->notify_data.data.length) {
 			data->notify_data.data.string = PRS_ALLOC_MEM(ps, uint16,
 								data->notify_data.data.length);
 
@@ -490,9 +495,13 @@
 
 			/* Tallocate memory for string */
 
+			if (x) {
 			data->notify_data.data.string = PRS_ALLOC_MEM(ps, uint16, x * 2);
 			if (!data->notify_data.data.string) 
 				return False;
+			} else {
+				data->notify_data.data.string = NULL;
+			}
 
 			if(!prs_uint16uni(True,"string",ps,depth,data->notify_data.data.string,x))
 				return False;
@@ -3893,7 +3902,16 @@
 		}
 		case 3:
 		{
+			/* FIXME ! Our parsing here is wrong I think,
+			 * but for a level3 it makes no sense for
+			 * ptr_sec_desc to be NULL. JRA. Based on
+			 * a Vista sniff from Martin Zielinski <mz@seh.de>.
+			 */
+			if (UNMARSHALLING(ps)) {
+				ptr_sec_desc = 1;
+			} else {
 			ptr_sec_desc = q_u->info.info_3->secdesc_ptr;
+			}
 			break;
 		}
 	}
@@ -6956,7 +6974,7 @@
 	
 	/* first loop to write basic enum_value information */
 	
-	if (UNMARSHALLING(ps)) {
+	if (UNMARSHALLING(ps) && ctr->size_of_array) {
 		ctr->values = PRS_ALLOC_MEM(ps, PRINTER_ENUM_VALUES, ctr->size_of_array);
 		if (!ctr->values)
 			return False;
diff -burN source/rpc_parse/parse_srv.c source/rpc_parse/parse_srv.c
--- source/rpc_parse/parse_srv.c	2005-04-18 18:38:20.000000000 +0200
+++ source/rpc_parse/parse_srv.c	2007-08-07 09:38:18.000000000 +0200
@@ -782,7 +782,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info0 = PRS_ALLOC_MEM(ps, SRV_SHARE_INFO_0, num_entries)))
 				return False;
 			ctr->share.info0 = info0;
@@ -808,7 +808,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1 = PRS_ALLOC_MEM(ps, SRV_SHARE_INFO_1, num_entries)))
 				return False;
 			ctr->share.info1 = info1;
@@ -834,7 +834,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info2 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_2,num_entries)))
 				return False;
 			ctr->share.info2 = info2;
@@ -859,7 +859,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info501 = PRS_ALLOC_MEM(ps, SRV_SHARE_INFO_501, num_entries)))
 				return False;
 			ctr->share.info501 = info501;
@@ -884,7 +884,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info502 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_502,num_entries)))
 				return False;
 			ctr->share.info502 = info502;
@@ -910,7 +910,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1004 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_1004,num_entries)))
 				return False;
 			ctr->share.info1004 = info1004;
@@ -936,7 +936,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1005 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_1005,num_entries)))
 				return False;
 			ctr->share.info1005 = info1005;
@@ -956,7 +956,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1006 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_1006,num_entries)))
 				return False;
 			ctr->share.info1006 = info1006;
@@ -976,7 +976,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1007 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_1007,num_entries)))
 				return False;
 			ctr->share.info1007 = info1007;
@@ -1002,7 +1002,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info1501 = PRS_ALLOC_MEM(ps,SRV_SHARE_INFO_1501,num_entries)))
 				return False;
 			ctr->share.info1501 = info1501;
@@ -2558,7 +2558,7 @@
 		int num_entries = ctr->num_entries;
 		int i;
 
-		if (UNMARSHALLING(ps)) {
+		if (UNMARSHALLING(ps) && num_entries) {
 			if (!(info3 = PRS_ALLOC_MEM(ps, SRV_FILE_INFO_3, num_entries)))
 				return False;
 			ctr->file.info3 = info3;
@@ -3377,7 +3377,7 @@
 
 	r_n->disk_enum_ctr.entries_read = entries_read3;
 
-	if(UNMARSHALLING(ps)) {
+	if(UNMARSHALLING(ps) && entries_read3) {
 
 		DISK_INFO *dinfo;
 
@@ -3386,7 +3386,7 @@
 		r_n->disk_enum_ctr.disk_info = dinfo;
 	}
 
-	for(i=0; i < r_n->disk_enum_ctr.entries_read; i++) {
+	for(i=0; i < entries_read3; i++) {
 
 		if(!prs_uint32("unknown", ps, depth, &r_n->disk_enum_ctr.disk_info[i].unknown))
 			return False;
diff -burN source/rpc_server/srv_pipe.c source/rpc_server/srv_pipe.c
--- source/rpc_server/srv_pipe.c	2007-02-04 19:59:21.000000000 +0100
+++ source/rpc_server/srv_pipe.c	2007-07-17 13:19:05.000000000 +0200
@@ -2331,6 +2331,7 @@
 	int               n_cmds = 0;
 
 	switch ( idx ) {
+#ifndef AVM_SMALLER
 		case PI_LSARPC:
 			lsa_get_pipe_fns( &cmds, &n_cmds );
 			break;
@@ -2343,12 +2344,14 @@
 		case PI_NETLOGON:
 			netlog_get_pipe_fns( &cmds, &n_cmds );
 			break;
+#endif /* AVM_SMALLER */
 		case PI_SRVSVC:
 			srvsvc_get_pipe_fns( &cmds, &n_cmds );
 			break;
 		case PI_WKSSVC:
 			wkssvc_get_pipe_fns( &cmds, &n_cmds );
 			break;
+#ifndef AVM_SMALLER
 		case PI_WINREG:
 			reg_get_pipe_fns( &cmds, &n_cmds );
 			break;
@@ -2367,6 +2370,8 @@
 		case PI_NTSVCS:
 			ntsvcs_get_pipe_fns( &cmds, &n_cmds );
 			break;
+#endif /* AVM_SMALLER */
+
 #ifdef DEVELOPER
 		case PI_ECHO:
 			echo_get_pipe_fns( &cmds, &n_cmds );
diff -burN source/rpc_server/srv_spoolss.c source/rpc_server/srv_spoolss.c
--- source/rpc_server/srv_spoolss.c	2006-04-20 04:29:27.000000000 +0200
+++ source/rpc_server/srv_spoolss.c	2007-08-07 09:38:18.000000000 +0200
@@ -1477,6 +1477,15 @@
 	ZERO_STRUCT(r_u);
 	
 	if(!spoolss_io_q_addprinterdriverex("", &q_u, data, 0)) {
+		if (q_u.level != 3 && q_u.level != 6) {
+			/* Clever hack from Martin Zielinski <mz@seh.de>
+			 * to allow downgrade from level 8 (Vista).
+			 */
+			DEBUG(3,("api_spoolss_addprinterdriverex: unknown SPOOL_Q_ADDPRINTERDRIVEREX level %u.\n",
+				(unsigned int)q_u.level ));
+			setup_fault_pdu(p, NT_STATUS(DCERPC_FAULT_INVALID_TAG));
+			return True;
+		}
 		DEBUG(0,("spoolss_io_q_addprinterdriverex: unable to unmarshall SPOOL_Q_ADDPRINTERDRIVEREX.\n"));
 		return False;
 	}
diff -burN source/rpc_server/srv_spoolss_nt.c source/rpc_server/srv_spoolss_nt.c
--- source/rpc_server/srv_spoolss_nt.c	2007-02-04 19:59:21.000000000 +0100
+++ source/rpc_server/srv_spoolss_nt.c	2007-08-07 09:38:18.000000000 +0200
@@ -5848,6 +5848,12 @@
 		goto done;
 	}
 	
+	if (!secdesc_ctr) {
+		DEBUG(10,("update_printer_sec: secdesc_ctr is NULL !\n"));
+		result = WERR_INVALID_PARAM;
+		goto done;
+	}
+
 	/* Check the user has permissions to change the security
 	   descriptor.  By experimentation with two NT machines, the user
 	   requires Full Access to the printer to change security
@@ -9378,6 +9384,15 @@
 	
 	/* housekeeping information in the reply */
 	
+	/* Fix from Martin Zielinski <mz@seh.de> - ensure
+	 * the hand marshalled container size is a multiple
+	 * of 4 bytes for RPC alignment.
+	 */
+
+	if (needed % 4) {
+		needed += 4-(needed % 4);
+	}
+
 	r_u->needed 	= needed;
 	r_u->returned 	= num_entries;
 
diff -burN source/smbd/change_trust_pw.c source/smbd/change_trust_pw.c
--- source/smbd/change_trust_pw.c	2005-10-18 04:44:56.000000000 +0200
+++ source/smbd/change_trust_pw.c	2007-07-17 13:19:05.000000000 +0200
@@ -30,6 +30,10 @@
 
 NTSTATUS change_trust_account_password( const char *domain, const char *remote_machine)
 {
+#ifdef AVM_SMALLER
+       return NT_STATUS_UNSUCCESSFUL;
+#else
+
 	NTSTATUS nt_status = NT_STATUS_UNSUCCESSFUL;
 	struct in_addr pdc_ip;
 	fstring dc_name;
@@ -95,4 +99,5 @@
 		DEBUG(5,("change_trust_account_password: sucess!\n"));
   
 	return nt_status;
+#endif /* AVM_SMALLER */
 }
diff -burN source/smbd/close.c source/smbd/close.c
--- source/smbd/close.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/close.c	2007-07-17 13:19:05.000000000 +0200
@@ -295,7 +295,9 @@
 	}
 
 	if (fsp->print_file) {
+#ifndef AVM_NO_PRINTING
 		print_fsp_end(fsp, close_type);
+#endif
 		file_free(fsp);
 		return 0;
 	}
diff -burN source/smbd/conn.c source/smbd/conn.c
--- source/smbd/conn.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/conn.c	2007-07-17 13:19:05.000000000 +0200
@@ -205,9 +205,12 @@
 	 * idle with a handle open.
 	 */
 
+
+#ifndef AVM_SMALLER
 	for (plist = get_first_internal_pipe(); plist; plist = get_next_internal_pipe(plist))
 		if (plist->pipe_handles && plist->pipe_handles->count)
 			allidle = False;
+#endif	
 	
 	return allidle;
 }
diff -burN source/smbd/dfree.c source/smbd/dfree.c
--- source/smbd/dfree.c	2005-11-09 19:28:55.000000000 +0100
+++ source/smbd/dfree.c	2007-07-17 13:19:05.000000000 +0200
@@ -130,11 +130,13 @@
 		}
 	}
 
+#if 0 /* AR7 */
 	if (disk_quotas(path, &bsize_q, &dfree_q, &dsize_q)) {
 		(*bsize) = bsize_q;
 		(*dfree) = MIN(*dfree,dfree_q);
 		(*dsize) = MIN(*dsize,dsize_q);
 	}
+#endif
 
 	/* FIXME : Any reason for this assumption ? */
 	if (*bsize < 256) {
diff -burN source/smbd/dir.c source/smbd/dir.c
--- source/smbd/dir.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/dir.c	2007-08-07 09:38:18.000000000 +0200
@@ -1255,3 +1255,42 @@
 	}
 	return False;
 }
+
+/*****************************************************************
+ Is this directory empty ?
+*****************************************************************/
+
+NTSTATUS can_delete_directory(struct connection_struct *conn,
+				const char *dirname)
+{
+	NTSTATUS status = NT_STATUS_OK;
+	long dirpos = 0;
+	const char *dname;
+	struct smb_Dir *dir_hnd = OpenDir(conn, dirname, NULL, 0);
+
+	if (!dir_hnd) {
+		return map_nt_error_from_unix(errno);
+	}
+
+	while ((dname = ReadDirName(dir_hnd,&dirpos))) {
+		SMB_STRUCT_STAT st;
+
+		/* Quick check for "." and ".." */
+		if (dname[0] == '.') {
+			if (!dname[1] || (dname[1] == '.' && !dname[2])) {
+				continue;
+			}
+		}
+
+		if (!is_visible_file(conn, dirname, dname, &st, True)) {
+			continue;
+		}
+
+		DEBUG(10,("can_delete_directory: got name %s - can't delete\n", dname ));
+		status = NT_STATUS_DIRECTORY_NOT_EMPTY;
+		break;
+	}
+	CloseDir(dir_hnd);
+
+	return status;
+}
diff -burN source/smbd/dosmode.c source/smbd/dosmode.c
--- source/smbd/dosmode.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/dosmode.c	2007-07-17 13:19:05.000000000 +0200
@@ -48,12 +48,15 @@
 	if (ISDOT(path) || ISDOTDOT(path)) {
 		return 0;
 	}
-
+#ifdef AVM_SMALLER
+	return 0;
+#else
 	if (!lp_dmapi_support(SNUM(conn)) || !dmapi_have_session()) {
 		return 0;
 	}
 
 	return dmapi_file_flags(path);
+#endif
 }
 
 /****************************************************************************
diff -burN source/smbd/fileio.c source/smbd/fileio.c
--- source/smbd/fileio.c	2005-10-18 04:44:57.000000000 +0200
+++ source/smbd/fileio.c	2007-08-07 09:38:18.000000000 +0200
@@ -176,6 +176,8 @@
 
 static int wcp_file_size_change(files_struct *fsp)
 {
+/* AVM: Fuer Pruefung des freien Speichers auf dem Datentraeger wird 
+   SMB_VFS_FTRUNCATE aufgerufen, auch falls es langsam sein sollte */
 	int ret;
 	write_cache *wcp = fsp->wcp;
 
@@ -199,6 +201,10 @@
 	int write_path = -1; 
 
 	if (fsp->print_file) {
+#ifdef AVM_NO_PRINTING
+			errno = EBADF;
+			return -1;
+#else
 		fstring sharename;
 		uint32 jobid;
 
@@ -210,6 +216,7 @@
 		}
 
 		return print_job_write(SNUM(fsp->conn), jobid, data, pos, n);
+#endif /* AVM_NO_PRINTING */
 	}
 
 	if (!fsp->can_write) {
diff -burN source/smbd/files.c source/smbd/files.c
--- source/smbd/files.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/files.c	2007-07-17 13:19:05.000000000 +0200
@@ -203,10 +203,12 @@
 		exit_server("out of memory in file_init");
 	}
 	
+#ifndef AVM_SMALLER
 	/*
 	 * Ensure that pipe_handle_oppset is set correctly.
 	 */
 	set_pipe_handle_offset(real_max_open_files);
+#endif
 }
 
 /****************************************************************************
diff -burN source/smbd/lanman.c source/smbd/lanman.c
--- source/smbd/lanman.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/lanman.c	2007-07-17 13:19:05.000000000 +0200
@@ -378,6 +378,7 @@
 	PACK(desc,t,v);
 }
 
+#ifndef AVM_NO_PRINTING
 /****************************************************************************
  Get a print queue.
 ****************************************************************************/
@@ -753,6 +754,7 @@
 		
 	return result;
 }
+#endif /* AVM_NO_PRINTING */
 
 static BOOL api_DosPrintQGetInfo(connection_struct *conn,
 				 uint16 vuid, char *param,char *data,
@@ -760,6 +762,9 @@
 				 char **rdata,char **rparam,
 				 int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -865,6 +870,7 @@
 	SAFE_FREE(tmpdata);
 
 	return(True);
+#endif /* AVM_NO_PRINTING */
 }
 
 /****************************************************************************
@@ -876,6 +882,9 @@
  			      char **rdata, char** rparam,
  			      int *rdata_len, int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *param_format = param+2;
 	char *output_format1 = skip_string(param_format,1);
 	char *p = skip_string(output_format1,1);
@@ -1004,6 +1013,7 @@
 	SAFE_FREE(status);
 
 	return False;
+#endif /* AVM_NO_PRINTING */
 }
 
 /****************************************************************************
@@ -2378,6 +2388,9 @@
 				char **rdata,char **rparam,
 				int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	int function = SVAL(param,0);
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
@@ -2438,6 +2451,7 @@
 	SSVAL(*rparam,2,0);		/* converter word */
 
 	return(True);
+#endif
 }
 
 /****************************************************************************
@@ -2449,6 +2463,9 @@
 				 char **rdata,char **rparam,
 				 int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	int function = SVAL(param,0);
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
@@ -2494,6 +2511,7 @@
 	SSVAL(*rparam,2,0);		/* converter word */
 
 	return(True);
+#endif
 }
 
 /****************************************************************************
@@ -2525,6 +2543,9 @@
   			     char **rdata,char **rparam,
   			     int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	struct pack_desc desc;
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
@@ -2590,6 +2611,7 @@
 	SSVAL(*rparam,2,0);		/* converter word */
 	
 	return(True);
+#endif
 }
 
 
@@ -3272,6 +3294,9 @@
 				 char **rdata,char **rparam,
 				 int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3358,6 +3383,7 @@
 	DEBUG(4,("WPrintJobGetInfo: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 static BOOL api_WPrintJobEnumerate(connection_struct *conn,uint16 vuid, char *param,char *data,
@@ -3365,6 +3391,9 @@
 				   char **rdata,char **rparam,
 				   int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3440,6 +3469,7 @@
 	DEBUG(4,("WPrintJobEnumerate: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 static int check_printdest_info(struct pack_desc* desc,
@@ -3509,6 +3539,9 @@
 				  char **rdata,char **rparam,
 				  int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3573,6 +3606,7 @@
 	SAFE_FREE(tmpdata);
 
 	return True;
+#endif
 }
 
 static BOOL api_WPrintDestEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
@@ -3580,6 +3614,9 @@
 			       char **rdata,char **rparam,
 			       int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3648,6 +3685,7 @@
 	DEBUG(4,("WPrintDestEnumerate: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 static BOOL api_WPrintDriverEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
@@ -3655,6 +3693,9 @@
 				 char **rdata,char **rparam,
 				 int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3705,6 +3746,7 @@
 	DEBUG(4,("WPrintDriverEnum: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 static BOOL api_WPrintQProcEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
@@ -3712,6 +3754,9 @@
 				char **rdata,char **rparam,
 				int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3763,6 +3808,7 @@
 	DEBUG(4,("WPrintQProcEnum: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 static BOOL api_WPrintPortEnum(connection_struct *conn,uint16 vuid, char *param,char *data,
@@ -3770,6 +3816,9 @@
 			       char **rdata,char **rparam,
 			       int *rdata_len,int *rparam_len)
 {
+#ifdef AVM_NO_PRINTING
+return False;
+#else
 	char *str1 = param+2;
 	char *str2 = skip_string(str1,1);
 	char *p = skip_string(str2,1);
@@ -3822,6 +3871,7 @@
 	DEBUG(4,("WPrintPortEnum: errorcode %d\n",desc.errcode));
 
 	return True;
+#endif
 }
 
 
diff -burN source/smbd/msdfs.c source/smbd/msdfs.c
--- source/smbd/msdfs.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/msdfs.c	2007-08-07 09:38:18.000000000 +0200
@@ -832,9 +832,13 @@
 
 	/* create the referral depeding on version */
 	DEBUG(10,("max_referral_level :%d\n",max_referral_level));
-	if(max_referral_level<2 || max_referral_level>3) {
+
+	if (max_referral_level < 2) {
 		max_referral_level = 2;
 	}
+	if (max_referral_level > 3) {
+		max_referral_level = 3;
+	}
 
 	switch(max_referral_level) {
 	case 2:
diff -burN source/smbd/negprot.c source/smbd/negprot.c
--- source/smbd/negprot.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/negprot.c	2007-08-07 09:38:18.000000000 +0200
@@ -263,6 +263,16 @@
 
 	global_encrypted_passwords_negotiated = lp_encrypted_passwords();
 
+	/* Check the flags field to see if this is Vista.
+	   WinXP sets it and Vista does not. But we have to 
+	   distinguish from NT which doesn't set it either. */
+
+	if ( (SVAL(inbuf, smb_flg2) & FLAGS2_EXTENDED_SECURITY) &&
+		((SVAL(inbuf, smb_flg2) & FLAGS2_UNKNOWN_BIT4) == 0) ) 
+	{
+		set_remote_arch( RA_VISTA );		
+	}
+
 	/* do spnego in user level security if the client
 	   supports it and we can do encrypted passwords */
 	
@@ -393,6 +403,15 @@
 protocol [LANMAN2.1]
 protocol [NT LM 0.12]
 
+Vista:
+protocol [PC NETWORK PROGRAM 1.0]
+protocol [LANMAN1.0]
+protocol [Windows for Workgroups 3.1a]
+protocol [LM1.2X002]
+protocol [LANMAN2.1]
+protocol [NT LM 0.12]
+protocol [SMB 2.001]
+
 OS/2:
 protocol [PC NETWORK PROGRAM 1.0]
 protocol [XENIX CORE]
@@ -406,18 +425,19 @@
   *
   * This appears to be the matrix of which protocol is used by which
   * MS product.
-       Protocol                       WfWg    Win95   WinNT  Win2K  OS/2
-       PC NETWORK PROGRAM 1.0          1       1       1      1      1
+       Protocol                       WfWg    Win95   WinNT  Win2K  OS/2 Vista
+       PC NETWORK PROGRAM 1.0          1       1       1      1      1     1
        XENIX CORE                                      2             2
        MICROSOFT NETWORKS 3.0          2       2       
        DOS LM1.2X002                   3       3       
        MICROSOFT NETWORKS 1.03                         3
        DOS LANMAN2.1                   4       4       
-       LANMAN1.0                                       4      2      3
-       Windows for Workgroups 3.1a     5       5       5      3
-       LM1.2X002                                       6      4      4
-       LANMAN2.1                                       7      5      5
-       NT LM 0.12                              6       8      6
+       LANMAN1.0                                       4      2      3     2
+       Windows for Workgroups 3.1a     5       5       5      3            3
+       LM1.2X002                                       6      4      4     4
+       LANMAN2.1                                       7      5      5     5
+       NT LM 0.12                              6       8      6            6
+       SMB 2.001                                                           7
   *
   *  tim@fsg.com 09/29/95
   *  Win2K added by matty 17/7/99
@@ -430,6 +450,7 @@
 #define ARCH_OS2      0x14     /* Again OS/2 is like NT */
 #define ARCH_SAMBA    0x20
 #define ARCH_CIFSFS   0x40
+#define ARCH_VISTA    0x8C     /* Vista is like XP/2K */
  
 #define ARCH_ALL      0x7F
  
@@ -493,6 +514,8 @@
 			arch &= ( ARCH_WFWG | ARCH_WIN95 );
 		else if (strcsequal(p,"NT LM 0.12"))
 			arch &= ( ARCH_WIN95 | ARCH_WINNT | ARCH_WIN2K | ARCH_CIFSFS);
+		else if (strcsequal(p,"SMB 2.001"))
+			arch = ARCH_VISTA;		
 		else if (strcsequal(p,"LANMAN2.1"))
 			arch &= ( ARCH_WINNT | ARCH_WIN2K | ARCH_OS2 );
 		else if (strcsequal(p,"LM1.2X002"))
@@ -537,8 +560,14 @@
 				set_remote_arch(RA_WINNT);
 			break;
 		case ARCH_WIN2K:
+			/* Vista may have been set in the negprot so don't 
+			   override it here */
+			if ( get_remote_arch() != RA_VISTA )
 			set_remote_arch(RA_WIN2K);
 			break;
+		case ARCH_VISTA:
+			set_remote_arch(RA_VISTA);
+			break;
 		case ARCH_OS2:
 			set_remote_arch(RA_OS2);
 			break;
diff -burN source/smbd/open.c source/smbd/open.c
--- source/smbd/open.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/open.c	2007-07-17 13:19:05.000000000 +0200
@@ -1127,8 +1127,11 @@
 		}
 
 		DEBUG(10, ("open_file_ntcreate: printer open fname=%s\n", fname));
-
+#ifdef AVM_NO_PRINTING
+		return NULL;
+#else
 		return print_fsp_open(conn, fname);
+#endif
 	}
 
 	/* We add aARCH to this as this mode is only used if the file is
diff -burN source/smbd/password.c source/smbd/password.c
--- source/smbd/password.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/password.c	2007-07-17 13:19:05.000000000 +0200
@@ -23,6 +23,8 @@
 /* users from session setup */
 static char *session_userlist = NULL;
 static int len_session_userlist = 0;
+/* workgroup from session setup. */
+static char *session_workgroup = NULL;
 
 /* this holds info on user ids that are already validated for this VC */
 static user_struct *validated_users;
@@ -406,6 +408,29 @@
 }
 
 /****************************************************************************
+ In security=share mode we need to store the client workgroup, as that's
+  what Vista uses for the NTLMv2 calculation.
+****************************************************************************/
+
+void add_session_workgroup(const char *workgroup)
+{
+	if (session_workgroup) {
+		SAFE_FREE(session_workgroup);
+	}
+	session_workgroup = smb_xstrdup(workgroup);
+}
+
+/****************************************************************************
+ In security=share mode we need to return the client workgroup, as that's
+  what Vista uses for the NTLMv2 calculation.
+****************************************************************************/
+
+const char *get_session_workgroup(void)
+{
+	return session_workgroup;
+}
+
+/****************************************************************************
  Check if a user is in a netgroup user list. If at first we don't succeed,
  try lower case.
 ****************************************************************************/
diff -burN source/smbd/posix_acls.c source/smbd/posix_acls.c
--- source/smbd/posix_acls.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/posix_acls.c	2007-08-07 09:38:18.000000000 +0200
@@ -655,6 +655,7 @@
 	}
 	return 0;
 }
+
 /****************************************************************************
  Function to create owner and group SIDs from a SMB_STRUCT_STAT.
 ****************************************************************************/
@@ -666,6 +667,27 @@
 }
 
 /****************************************************************************
+ Is the identity in two ACEs equal ? Check both SID and uid/gid.
+****************************************************************************/
+
+static BOOL identity_in_ace_equal(canon_ace *ace1, canon_ace *ace2)
+{
+	if (sid_equal(&ace1->trustee, &ace2->trustee)) {
+		return True;
+	}
+	if (ace1->owner_type == ace2->owner_type) {
+		if (ace1->owner_type == UID_ACE &&
+				ace1->unix_ug.uid == ace2->unix_ug.uid) {
+			return True;
+		} else if (ace1->owner_type == GID_ACE &&
+				ace1->unix_ug.gid == ace2->unix_ug.gid) {
+			return True;
+		}
+	}
+	return False;
+}
+
+/****************************************************************************
  Merge aces with a common sid - if both are allow or deny, OR the permissions together and
  delete the second one. If the first is deny, mask the permissions off and delete the allow
  if the permissions become zero, delete the deny if the permissions are non zero.
@@ -692,7 +714,7 @@
 
 			curr_ace_next = curr_ace->next; /* Save the link in case of delete. */
 
-			if (sid_equal(&curr_ace->trustee, &curr_ace_outer->trustee) &&
+			if (identity_in_ace_equal(curr_ace, curr_ace_outer) &&
 				(curr_ace->attr == curr_ace_outer->attr)) {
 
 				if( DEBUGLVL( 10 )) {
@@ -732,7 +754,7 @@
 			 * we've put on the ACL, we know the deny must be the first one.
 			 */
 
-			if (sid_equal(&curr_ace->trustee, &curr_ace_outer->trustee) &&
+			if (identity_in_ace_equal(curr_ace, curr_ace_outer) &&
 				(curr_ace_outer->attr == DENY_ACE) && (curr_ace->attr == ALLOW_ACE)) {
 
 				if( DEBUGLVL( 10 )) {
diff -burN source/smbd/process.c source/smbd/process.c
--- source/smbd/process.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/process.c	2007-07-17 13:19:05.000000000 +0200
@@ -1008,7 +1008,9 @@
 
 	chain_size = 0;
 	file_chain_reset();
+#ifndef AVM_SMALLER
 	reset_chain_p();
+#endif
 
 	if (msg_type != 0)
 		return(reply_special(inbuf,outbuf));  
@@ -1285,8 +1287,10 @@
 	if (t != -1)
 		select_timeout = MIN(select_timeout, t*1000);
 
+#ifndef AVM_NO_PRINTING
 	if (print_notify_messages_pending())
 		select_timeout = MIN(select_timeout, 1000);
+#endif
 
 	return select_timeout;
 }
@@ -1477,9 +1481,10 @@
 	 */
 	process_blocking_lock_queue(t);
 
+#ifndef AVM_NO_PRINTING
 	/* update printer queue caches if necessary */
-  
 	update_monitored_printq_cache();
+#endif
   
 	/*
 	 * Check to see if we have any change notifies 
@@ -1494,9 +1499,10 @@
 	force_check_log_size();
 	check_log_size();
 
+#ifndef AVM_NO_PRINTING
 	/* Send any queued printer notify message to interested smbd's. */
-
 	print_notify_send_messages(0);
+#endif
 
 	/*
 	 * Modify the select timeout depending upon
diff -burN source/smbd/reply.c source/smbd/reply.c
--- source/smbd/reply.c	2007-02-04 20:09:01.000000000 +0100
+++ source/smbd/reply.c	2007-07-17 13:19:05.000000000 +0200
@@ -3599,7 +3599,10 @@
 	int outsize = 0;
 	files_struct *fsp;
 	START_PROFILE(SMBsplopen);
-	
+#ifdef AVM_NO_PRINTING
+		END_PROFILE(SMBsplopen);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+#else
 	if (!CAN_PRINT(conn)) {
 		END_PROFILE(SMBsplopen);
 		return ERROR_DOS(ERRDOS,ERRnoaccess);
@@ -3621,6 +3624,7 @@
 
 	END_PROFILE(SMBsplopen);
 	return(outsize);
+#endif
 }
 
 /****************************************************************************
@@ -3637,6 +3641,10 @@
 
 	CHECK_FSP(fsp,conn);
 
+#ifdef AVM_NO_PRINTING
+		END_PROFILE(SMBsplretq);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+#else
 	if (!CAN_PRINT(conn)) {
 		END_PROFILE(SMBsplclose);
 		return ERROR_NT(NT_STATUS_UNSUCCESSFUL);
@@ -3655,6 +3663,7 @@
 
 	END_PROFILE(SMBsplclose);
 	return(outsize);
+#endif
 }
 
 /****************************************************************************
@@ -3664,6 +3673,10 @@
 int reply_printqueue(connection_struct *conn,
 		     char *inbuf,char *outbuf, int dum_size, int dum_buffsize)
 {
+#ifdef AVM_NO_PRINTING
+		END_PROFILE(SMBsplretq);
+		return ERROR_DOS(ERRDOS,ERRnoaccess);
+#else
 	int outsize = set_message(outbuf,2,3,True);
 	int max_count = SVAL(inbuf,smb_vwv0);
 	int start_index = SVAL(inbuf,smb_vwv1);
@@ -3726,6 +3739,7 @@
   
 	END_PROFILE(SMBsplretq);
 	return(outsize);
+#endif
 }
 
 /****************************************************************************
diff -burN source/smbd/server.c source/smbd/server.c
--- source/smbd/server.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/server.c	2007-08-07 09:38:18.000000000 +0200
@@ -22,7 +22,7 @@
 
 #include "includes.h"
 
-static_decl_rpc;
+/* AR7 ???? static_decl_rpc; */
 
 static int am_parent = 1;
 
@@ -41,6 +41,41 @@
 extern int dcelogin_atmost_once;
 #endif /* WITH_DFS */
 
+
+
+#ifdef SAMBA_DEBUG
+void _fLog(char *fmt, ...)
+{
+	va_list va;
+	FILE *fp = fopen("/var/tmp/smbd.log", "a");
+	time_t t = time(0); /* LOG */
+
+	if (!fp) return;
+
+	fprintf(fp, " [%d] %02u:%02u  ", getpid(), (t / 60) % 60, t % 60);
+	va_start(va, fmt);
+	vfprintf(fp, fmt, va);
+	va_end(va);
+	fprintf(fp, "\n");
+	fclose(fp);
+}
+
+void _fDebug(char *fmt, ...)
+{
+	va_list va;
+	FILE *fp = fopen("/var/tmp/smbd.log", "a");
+	time_t t = time(0); /* LOG */
+
+	if (!fp) return;
+
+	fprintf(fp, " [%d] %02u:%02u ", getpid(), (t / 60) % 60, t % 60);
+	va_start(va, fmt);
+	vfprintf(fp, fmt, va);
+	va_end(va);
+	fclose(fp);
+}
+#endif
+
 /* really we should have a top level context structure that has the
    client file descriptor as an element. That would require a major rewrite :(
 
@@ -523,6 +558,7 @@
 **************************************************************************/
 void reload_printers(void)
 {
+#ifndef AVM_NO_PRINTING
 	int snum;
 	int n_services = lp_numservices();
 	int pnum = lp_servicenumber(PRINTERS_NAME);
@@ -549,6 +585,7 @@
 	}
 
 	load_printers();
+#endif /* AVM_NO_PRINTING */
 }
 
 /****************************************************************************
@@ -631,7 +668,9 @@
 
 	invalidate_all_vuids();
 
+#ifndef AVM_NO_PRINTING
 	print_notify_send_messages(3); /* 3 second timeout. */
+#endif
 
 	/* delete our entry in the connections database. */
 	yield_connection(NULL,"");
@@ -646,7 +685,9 @@
 #endif
 
 	locking_end();
+#ifndef AVM_NO_PRINTING
 	printing_end();
+#endif
 
 	if (how != SERVER_EXIT_NORMAL) {
 		int oldlevel = DEBUGLEVEL;
@@ -729,7 +770,9 @@
    mkproto.h.  Mixing $(builddir) and $(srcdir) source files in the current
    prototype generation system is too complicated. */
 
+#if 0 /* AR7 */
 void build_options(BOOL screen);
+#endif
 
  int main(int argc,const char *argv[])
 {
@@ -741,6 +784,13 @@
 	static BOOL log_stdout = False;
 	static char *ports = NULL;
 	int opt;
+
+#if 0 // AVM DEBUG
+	extern void crashdump_init(char*);
+	crashdump_init("smbd");
+#endif
+
+#ifndef AVM_NO_POPT
 	poptContext pc;
 
 	struct poptOption long_options[] = {
@@ -750,7 +800,9 @@
 	{"foreground", 'F', POPT_ARG_VAL, &Fork, False, "Run daemon in foreground (for daemontools, etc.)" },
 	{"no-process-group", '\0', POPT_ARG_VAL, &no_process_group, True, "Don't create a new process group" },
 	{"log-stdout", 'S', POPT_ARG_VAL, &log_stdout, True, "Log to stdout" },
+#if 0 /* AR7 */
 	{"build-options", 'b', POPT_ARG_NONE, NULL, 'b', "Print build options" },
+#endif
 	{"port", 'p', POPT_ARG_STRING, &ports, 0, "Listen on the specified ports"},
 	POPT_COMMON_SAMBA
 	POPT_COMMON_DYNCONFIG
@@ -766,21 +818,31 @@
 	pc = poptGetContext("smbd", argc, argv, long_options, 0);
 	
 	while((opt = poptGetNextOpt(pc)) != -1) {
+#if 0 /* AR7 */
 		switch (opt)  {
 		case 'b':
 			build_options(True); /* Display output to screen as well as debug */ 
 			exit(0);
 			break;
 		}
+#endif
 	}
 
 	poptFreeContext(pc);
+#else
+	load_case_tables();
+#endif /* AVM_NO_POPT */
+
 
 #ifdef HAVE_SETLUID
 	/* needed for SecureWare on SCO */
 	setluid(0);
 #endif
 
+#if 1 /* AVM */
+	setpriority(PRIO_PROCESS, 0, 19); /* be nice */
+#endif
+
 	sec_init();
 
 	set_remote_machine_name("smbd", False);
@@ -808,6 +870,16 @@
 	/* make absolutely sure we run as root - to handle cases where people
 	   are crazy enough to have it setuid */
 
+	generate_random_buffer(NULL, 0);
+
+	/* make absolutely sure we run as root - to handle cases where people
+	   are crazy enough to have it setuid */
+
+	gain_root_privilege();
+	gain_root_group_privilege();
+
+	fault_setup((void (*)(void *))exit_server_fault);
+	dump_core_setup("smbd");
 	gain_root_privilege();
 	gain_root_group_privilege();
 
@@ -850,8 +922,10 @@
 	DEBUG(2,("uid=%d gid=%d euid=%d egid=%d\n",
 		 (int)getuid(),(int)getgid(),(int)geteuid(),(int)getegid()));
 
+#if 0 /* AR7 */
 	/* Output the build options to the debug log */ 
 	build_options(False);
+#endif
 
 	if (sizeof(uint16) < 2 || sizeof(uint32) < 4) {
 		DEBUG(0,("ERROR: Samba is not configured correctly for the word size on your machine\n"));
@@ -945,16 +1019,20 @@
 
 	namecache_enable();
 
+#ifndef AVM_SMALLER
 	if (!init_registry())
 		exit(1);
+#endif
 
 #if 0
 	if (!init_svcctl_db())
                 exit(1);
 #endif
 
+#ifndef AVM_NO_PRINTING
 	if (!print_backend_init())
 		exit(1);
+#endif
 
 	if (!init_guest_info()) {
 		DEBUG(0,("ERROR: failed to setup guest info.\n"));
@@ -971,14 +1049,18 @@
 	   smbd is launched via inetd and we fork a copy of 
 	   ourselves here */
 
+#ifndef AVM_NO_PRINTING
 	if ( is_daemon && !interactive )
 		start_background_queue(); 
+#endif
 
+#if 0 /* AVM */
 	/* Always attempt to initialize DMAPI. We will only use it later if
 	 * lp_dmapi_support is set on the share, but we need a single global
 	 * session to work with.
 	 */
 	dmapi_init_session();
+#endif
 
 	if (!open_sockets_smbd(is_daemon, interactive, ports))
 		exit(1);
@@ -987,7 +1069,12 @@
 	 * everything after this point is run after the fork()
 	 */ 
 
+#if 0 /* AR7 */
 	static_init_rpc;
+#else
+	rpc_wks_init();
+	rpc_srv_init();
+#endif
 
 	init_modules();
 
diff -burN source/smbd/service.c source/smbd/service.c
--- source/smbd/service.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/service.c	2007-07-17 13:19:05.000000000 +0200
@@ -254,6 +254,7 @@
 		iService = add_home_service(service,service /* 'username' */, phome_dir);
 	}
 
+#ifndef AVM_NO_PRINTING
 	/* If we still don't have a service, attempt to add it as a printer. */
 	if (iService < 0) {
 		int iPrinterService;
@@ -273,6 +274,7 @@
 			}
 		}
 	}
+#endif /* AVM_NO_PRINTING */
 
 	/* Check for default vfs service?  Unsure whether to implement this */
 	if (iService < 0) {
@@ -1136,7 +1138,9 @@
 void close_cnum(connection_struct *conn, uint16 vuid)
 {
 	if (IS_IPC(conn)) {
+#ifndef AVM_SMALLER
 		pipe_close_conn(conn);
+#endif
 	} else {
 		file_close_conn(conn);
 		dptr_closecnum(conn);
diff -burN source/smbd/sesssetup.c source/smbd/sesssetup.c
--- source/smbd/sesssetup.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/sesssetup.c	2007-07-17 13:19:05.000000000 +0200
@@ -1035,6 +1035,7 @@
 
 		map_username(sub_user);
 		add_session_user(sub_user);
+		add_session_workgroup(domain);
 		/* Then force it to null for the benfit of the code below */
 		*user = 0;
 	}
diff -burN source/smbd/trans2.c source/smbd/trans2.c
--- source/smbd/trans2.c	2007-02-04 20:09:01.000000000 +0100
+++ source/smbd/trans2.c	2007-07-17 13:19:05.000000000 +0200
@@ -2638,11 +2638,14 @@
 				/* unknown_2 6 NULL bytes follow*/
 		
 				/* now set the quotas */
+#if 1 /* AR7 */
+					return ERROR_DOS(ERRSRV,ERRerror);
+#else
 				if (vfs_set_ntquota(fsp, SMB_USER_FS_QUOTA_TYPE, NULL, &quotas)!=0) {
 					DEBUG(0,("vfs_set_ntquota() failed for service [%s]\n",lp_servicename(SNUM(conn))));
 					return ERROR_DOS(ERRSRV,ERRerror);
 				}
-			
+#endif			
 				break;
 			}
 		default:
diff -burN source/smbd/uid.c source/smbd/uid.c
--- source/smbd/uid.c	2006-04-20 04:29:19.000000000 +0200
+++ source/smbd/uid.c	2007-08-07 09:38:18.000000000 +0200
@@ -151,6 +151,8 @@
 	char group_c;
 	BOOL must_free_token = False;
 	NT_USER_TOKEN *token = NULL;
+	int num_groups = 0;
+	gid_t *group_list = NULL;
 
 	if (!conn) {
 		DEBUG(2,("change_to_user: Connection not open\n"));
@@ -190,14 +192,14 @@
 	if (conn->force_user) /* security = share sets this too */ {
 		uid = conn->uid;
 		gid = conn->gid;
-		current_user.ut.groups = conn->groups;
-		current_user.ut.ngroups = conn->ngroups;
+	        group_list = conn->groups;
+		num_groups = conn->ngroups;
 		token = conn->nt_user_token;
 	} else if (vuser) {
 		uid = conn->admin_user ? 0 : vuser->uid;
 		gid = vuser->gid;
-		current_user.ut.ngroups = vuser->n_groups;
-		current_user.ut.groups  = vuser->groups;
+		num_groups = vuser->n_groups;
+		group_list  = vuser->groups;
 		token = vuser->nt_user_token;
 	} else {
 		DEBUG(2,("change_to_user: Invalid vuid used %d in accessing "
@@ -230,8 +232,8 @@
 			 */
 
 			int i;
-			for (i = 0; i < current_user.ut.ngroups; i++) {
-				if (current_user.ut.groups[i] == conn->gid) {
+			for (i = 0; i < num_groups; i++) {
+				if (group_list[i] == conn->gid) {
 					gid = conn->gid;
 					gid_to_sid(&token->user_sids[1], gid);
 					break;
@@ -243,6 +245,12 @@
 		}
 	}
 	
+	/* Now set current_user since we will immediately also call
+	   set_sec_ctx() */
+
+	current_user.ut.ngroups = num_groups;
+	current_user.ut.groups  = group_list;	
+
 	set_sec_ctx(uid, gid, current_user.ut.ngroups, current_user.ut.groups,
 		    token);
 
diff -burN source/smbd/vfs-wrap.c source/smbd/vfs-wrap.c
--- source/smbd/vfs-wrap.c	2007-02-04 19:59:13.000000000 +0100
+++ source/smbd/vfs-wrap.c	2007-08-07 09:38:18.000000000 +0200
@@ -694,6 +694,44 @@
 		return result;
 	}
 
+#if 1 // AVM patch - don't growth the file  (too much time and RAM for copy of large files to USB1.1 FAT filesystem)
+	{ 
+	SMB_BIG_UINT big_len = len;
+
+	result = SMB_VFS_FSTAT(fsp,fsp->fh->fd,&st);
+	if (result == -1) {
+		goto done;
+	}
+
+	if (big_len == (SMB_BIG_UINT)st.st_size) {
+		result = 0;
+		goto done;
+	}
+
+	if (big_len > (SMB_BIG_UINT)st.st_size) {
+		SMB_BIG_UINT space_avail;
+		SMB_BIG_UINT bsize,dfree,dsize;
+		big_len -= st.st_size;
+		big_len /= 1024; /* Len is now number of 1k blocks needed. */
+		space_avail = SMB_VFS_DISK_FREE(fsp->conn ,fsp->fsp_name,False,&bsize,&dfree,&dsize);
+		if (space_avail == (SMB_BIG_UINT)-1) {
+			result = -1;
+			goto done;
+		}
+
+		if (big_len > space_avail) {
+			errno = ENOSPC;
+			result = -1;
+			goto done;
+		}
+
+		// do nothing to be fast!
+		result = 0;
+		goto done;
+	}
+	} // block
+#endif // AVM Patch
+
 	/* we used to just check HAVE_FTRUNCATE_EXTEND and only use
 	   sys_ftruncate if the system supports it. Then I discovered that
 	   you can have some filesystems that support ftruncate
diff -burN source/utils/avm_smbpasswd.c source/utils/avm_smbpasswd.c
--- source/utils/avm_smbpasswd.c	1970-01-01 01:00:00.000000000 +0100
+++ source/utils/avm_smbpasswd.c	2007-10-23 12:27:13.000000000 +0200
@@ -0,0 +1,213 @@
+/*
+ * Unix SMB/CIFS implementation. 
+ * Copyright (C) Jeremy Allison 1995-1998
+ * Copyright (C) Tim Potter     2001
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 675
+ * Mass Ave, Cambridge, MA 02139, USA.  */
+
+#include "includes.h"
+
+
+void E_md4hash(const char *passwd, uchar p16[16])
+{
+	int len;
+	smb_ucs2_t wpwd[129];
+	int i;
+
+	
+	/* Password must be converted to NT unicode - null terminated. */
+	len = strlen(passwd);
+#if 0
+	push_ucs2(NULL, wpwd, (const char *)passwd, 256, STR_UNICODE|STR_NOALIGN|STR_TERMINATE);
+#else
+	for (i = 0; i < len; i++) {
+		wpwd[i] = (unsigned char)passwd[i];
+	}
+	wpwd[i] = 0; // termination
+#endif
+	/* Calculate length in bytes */
+	len = len /*strlen_w(wpwd)*/ * sizeof(int16);
+
+	mdfour(p16, (unsigned char *)wpwd, len);
+	ZERO_STRUCT(wpwd);	
+}
+
+/**
+ * Creates the DES forward-only Hash of the users password in DOS ASCII charset
+ * @param passwd password in 'unix' charset.
+ * @param p16 return password hashed with DES, caller allocated 16 byte buffer
+ * @return False if password was > 14 characters, and therefore may be incorrect, otherwise True
+ * @note p16 is filled in regardless
+ */
+ 
+BOOL E_deshash(const char *passwd, uchar p16[16])
+{
+	BOOL ret = True;
+	char dospwd[256+2];
+	int i;
+	int len;
+	
+	/* Password must be converted to DOS charset - null terminated, uppercase. */
+//	push_ascii(dospwd, passwd, sizeof(dospwd), STR_UPPER|STR_TERMINATE);
+	len = strlen(passwd);
+	for (i = 0; i < len; i++) {
+		char c = passwd[i];
+		if (islower(c)) c = toupper(c);
+		dospwd[i] = c;
+	}
+	dospwd[i] = 0;
+       
+	/* Only the fisrt 14 chars are considered, password need not be null terminated. */
+	E_P16((const unsigned char *)dospwd, p16);
+
+	if (strlen(dospwd) > 14) {
+		ret = False;
+	}
+
+	memset(dospwd, 0, sizeof(dospwd));
+	// ZERO_STRUCT(dospwd);	
+
+	return ret;
+}
+
+static void my_pdb_sethexpwd(char *p, const unsigned char *pwd)
+{
+	if (pwd != NULL) {
+		int i;
+		for (i = 0; i < 16; i++)
+			slprintf(&p[i*2], 3, "%02X", pwd[i]);
+	} else {
+		strncpy(p, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", 32);
+	}
+}
+
+static void crypt_password (const char *user_name,
+			   const char *new_passwd, char *new_lanman_p16, char *new_nt_p16)
+{
+	/* Calculate the MD4 hash (NT compatible) of the password */
+	E_md4hash(new_passwd, new_nt_p16);
+
+	if (!E_deshash(new_passwd, new_lanman_p16)) {
+		/* E_deshash returns false for 'long' passwords (> 14
+		   DOS chars).  This allows us to match Win2k, which
+		   does not store a LM hash for these passwords (which
+		   would reduce the effective password length to 14 */
+
+		memset(new_lanman_p16, 0, LM_HASH_LEN);
+	}
+}
+
+/*
+ftpuser:1000:8C6F5D02DEB21501AAD3B435B51404EE:E0FBA38268D0EC66EF1CB452D5885E53:[UX         ]:LCT-00000000:
+*/
+
+/*********************************************************
+ Start here.
+**********************************************************/
+int main(int argc, char **argv)
+{	
+	char *passwd_filename = "/var/samba/private/smbpasswd";
+	char *cleartext_filename = "/var/tmp/smbpasswd.cleartext";
+
+	if (argc != 1) {
+		fprintf(stderr, "use: smbpasswd\n");
+		fprintf(stderr, "  file %s will be encrypted to %s\n", cleartext_filename, passwd_filename);
+		return -9;
+	}
+
+	FILE *fp = fopen(passwd_filename, "w");
+
+	if (fp == NULL) {
+		fprintf(stderr, "can't write %s\n", passwd_filename);
+		return -10;
+	}
+	/* Make sure it is only rw by the owner */
+	chmod(passwd_filename, 0600);
+
+
+	FILE *fp_in = fopen(cleartext_filename, "r");
+	if (!fp_in) {
+		fprintf(stderr, "can't read %s\n", cleartext_filename);
+		fclose(fp);
+		return -11;
+	}
+
+
+	char line[512];
+
+	unsigned nusers = 0;
+	while(line == fgets(line, sizeof(line)-1, fp_in)) {
+		char *username, *passwd, *extra;
+		unsigned uid;
+		uchar new_lanman_p16[LM_HASH_LEN];
+		uchar new_nt_p16[NT_HASH_LEN];
+		char ascii_p16[32+1];
+		char *p;
+			
+		line[sizeof(line)-1] = '\0';
+		if (strlen(line)) {
+			p = &line[strlen(line)-1];
+			while(p >= line) {
+				if (*p != '\n' && *p != '\r') break;
+				*p = '\0';
+				p--;
+			}
+		}
+
+		p = line;
+		char *p2 = strchr(p, ':');
+		if (!p2) goto err;
+		*p2 = 0;
+		username = p;
+
+		p = p2 + 1;
+		p2 = strchr(p, ':');
+		if (!p2) goto err;
+		*p2 = 0;
+		uid = atoi(p);
+
+		p = p2 + 1;
+		p2 = strchr(p, ':');
+		if (!p2) goto err;
+		*p2 = 0;
+		passwd = p;
+
+		extra = p2 + 1;
+
+		crypt_password(username, passwd, new_lanman_p16, new_nt_p16);
+
+		fprintf(fp, "%s:%u:", username, uid);
+
+		my_pdb_sethexpwd(ascii_p16, new_lanman_p16);
+		ascii_p16[32] = '\0';
+		fprintf(fp, "%s:", ascii_p16);
+
+		my_pdb_sethexpwd(ascii_p16, new_nt_p16);
+		ascii_p16[32] = '\0';
+		fprintf(fp, "%s:", ascii_p16);
+
+		fprintf(fp, "%s\n", extra);
+
+		nusers++;
+	} // while
+
+err:
+	fclose(fp_in);
+	fclose(fp);
+
+fprintf(stderr, "%u samba users written to %s\n", nusers, passwd_filename);
+	return 0;
+}
+
diff -burN source/utils/ntlm_auth_proto.h source/utils/ntlm_auth_proto.h
--- source/utils/ntlm_auth_proto.h	1970-01-01 01:00:00.000000000 +0100
+++ source/utils/ntlm_auth_proto.h	2007-07-17 13:19:05.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef _NTLM_AUTH_PROTO_H_
+#define _NTLM_AUTH_PROTO_H_
+
+/* This file is automatically generated with "make proto". DO NOT EDIT */
+
+
+/* The following definitions come from utils/ntlm_auth.c  */
+
+const char *get_winbind_domain(void);
+const char *get_winbind_netbios_name(void);
+DATA_BLOB get_challenge(void) ;
+NTSTATUS contact_winbind_auth_crap(const char *username, 
+				   const char *domain, 
+				   const char *workstation,
+				   const DATA_BLOB *challenge, 
+				   const DATA_BLOB *lm_response, 
+				   const DATA_BLOB *nt_response, 
+				   uint32 flags, 
+				   uint8 lm_key[8], 
+				   uint8 user_session_key[16], 
+				   char **error_string, 
+				   char **unix_name) ;
+
+/* The following definitions come from utils/ntlm_auth_diagnostics.c  */
+
+BOOL diagnose_ntlm_auth(void);
+
+#endif /*  _NTLM_AUTH_PROTO_H_  */
--- source/include/config.h	2007-11-18 12:56:01.000000000 +0100
+++ source/include/config.h	2007-07-17 13:19:05.000000000 +0200
@@ -0,0 +1,2227 @@
+/* include/config.h.  Generated by configure.  */
+/* include/config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Whether the host os is aix */
+/* #undef AIX */
+
+/* Whether the AIX send_file() API is available */
+/* #undef AIX_SENDFILE_API */
+
+/* Does extattr API work */
+/* #undef BROKEN_EXTATTR */
+
+/* Does getgrnam work correctly */
+/* #undef BROKEN_GETGRNAM */
+
+/* Whether the nisplus include files are broken */
+#define BROKEN_NISPLUS_INCLUDE_FILES 1
+
+/* Broken RedHat 7.2 system header files */
+/* #undef BROKEN_REDHAT_7_SYSTEM_HEADERS */
+
+/* Does strndup work correctly */
+/* #undef BROKEN_STRNDUP */
+
+/* Does strnlen work correctly */
+/* #undef BROKEN_STRNLEN */
+
+/* Does this system use unicode compose characters */
+/* #undef BROKEN_UNICODE_COMPOSE_CHARACTERS */
+
+/* Whether the compiler supports the LL prefix on long long integers */
+#define COMPILER_SUPPORTS_LL 1
+
+/* Whether the host os is Darwin/MacOSX */
+/* #undef DARWINOS */
+
+/* Default display charset name */
+#define DEFAULT_DISPLAY_CHARSET "ASCII"
+
+/* Default dos charset name */
+#define DEFAULT_DOS_CHARSET "CP850"
+
+/* Default unix charset name */
+#define DEFAULT_UNIX_CHARSET "UTF-8"
+
+/* Define to check invariants around some common functions */
+/* #undef DMALLOC_FUNC_CHECK */
+
+/* Define to turn on dmalloc debugging */
+/* #undef ENABLE_DMALLOC */
+
+/* Whether the host os is FreeBSD */
+/* #undef FREEBSD */
+
+/* Whether the FreeBSD sendfile() API is available */
+/* #undef FREEBSD_SENDFILE_API */
+
+/* Whether we are running on 64bit linux */
+/* #undef HAVE_64BIT_LINUX */
+
+/* Whether acl_get_perm_np() is available */
+/* #undef HAVE_ACL_GET_PERM_NP */
+
+/* Whether the krb5_address struct has a addrtype property */
+/* #undef HAVE_ADDRTYPE_IN_KRB5_ADDRESS */
+
+/* Whether the krb5_address struct has a addr_type property */
+/* #undef HAVE_ADDR_TYPE_IN_KRB5_ADDRESS */
+
+/* Define to 1 if you have the <afs/afs.h> header file. */
+/* #undef HAVE_AFS_AFS_H */
+
+/* Define to 1 if you have the <afs.h> header file. */
+/* #undef HAVE_AFS_H */
+
+/* Whether 64 bit aio is available */
+/* #undef HAVE_AIOCB64 */
+
+/* Have aio_cancel */
+/* #undef HAVE_AIO_CANCEL */
+
+/* Have aio_cancel64 */
+/* #undef HAVE_AIO_CANCEL64 */
+
+/* Have aio_error */
+/* #undef HAVE_AIO_ERROR */
+
+/* Have aio_error64 */
+/* #undef HAVE_AIO_ERROR64 */
+
+/* Have aio_fsync */
+/* #undef HAVE_AIO_FSYNC */
+
+/* Have aio_fsync64 */
+/* #undef HAVE_AIO_FSYNC64 */
+
+/* Define to 1 if you have the <aio.h> header file. */
+/* AR7 #define HAVE_AIO_H 1 */
+
+/* Have aio_read */
+/* #undef HAVE_AIO_READ */
+
+/* Have aio_read64 */
+/* #undef HAVE_AIO_READ64 */
+
+/* Have aio_return */
+/* #undef HAVE_AIO_RETURN */
+
+/* Have aio_return64 */
+/* #undef HAVE_AIO_RETURN64 */
+
+/* Have aio_suspend */
+/* #undef HAVE_AIO_SUSPEND */
+
+/* Have aio_suspend64 */
+/* #undef HAVE_AIO_SUSPEND64 */
+
+/* Have aio_write */
+/* #undef HAVE_AIO_WRITE */
+
+/* Have aio_write64 */
+/* #undef HAVE_AIO_WRITE64 */
+
+/* Whether AIX ACLs are available */
+/* #undef HAVE_AIX_ACLS */
+
+/* Define to 1 if you have the <alloca.h> header file. */
+#define HAVE_ALLOCA_H 1
+
+/* Whether the AP_OPTS_USE_SUBKEY ap option is available */
+/* #undef HAVE_AP_OPTS_USE_SUBKEY */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* check for <asm/types.h> */
+#define HAVE_ASM_TYPES_H 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define HAVE_ASPRINTF 1
+
+/* Whether asprintf() is available */
+#define HAVE_ASPRINTF_DECL 1
+
+/* Define to 1 if you have the `atexit' function. */
+#define HAVE_ATEXIT 1
+
+/* Define to 1 if you have the `attr_get' function. */
+/* #undef HAVE_ATTR_GET */
+
+/* Define to 1 if you have the `attr_getf' function. */
+/* #undef HAVE_ATTR_GETF */
+
+/* Define to 1 if you have the `attr_list' function. */
+/* #undef HAVE_ATTR_LIST */
+
+/* Define to 1 if you have the `attr_listf' function. */
+/* #undef HAVE_ATTR_LISTF */
+
+/* Define to 1 if you have the `attr_remove' function. */
+/* #undef HAVE_ATTR_REMOVE */
+
+/* Define to 1 if you have the `attr_removef' function. */
+/* #undef HAVE_ATTR_REMOVEF */
+
+/* Define to 1 if you have the `attr_set' function. */
+/* #undef HAVE_ATTR_SET */
+
+/* Define to 1 if you have the `attr_setf' function. */
+/* #undef HAVE_ATTR_SETF */
+
+/* Define to 1 if you have the <attr/xattr.h> header file. */
+/* #undef HAVE_ATTR_XATTR_H */
+
+/* Define to 1 if you have the `backtrace_symbols' function. */
+/* AR7 #define HAVE_BACKTRACE_SYMBOLS 1 */
+
+/* Define to 1 if you have the `ber_scanf' function. */
+/* #undef HAVE_BER_SCANF */
+
+/* What header to include for iconv() function: biconv.h */
+/* #undef HAVE_BICONV */
+
+/* Define to 1 if you have the `bigcrypt' function. */
+/* #undef HAVE_BIGCRYPT */
+
+/* Whether fcntl64 locks are broken */
+/* #undef HAVE_BROKEN_FCNTL64_LOCKS */
+
+/* Whether getgroups is broken */
+/* #undef HAVE_BROKEN_GETGROUPS */
+
+/* Whether readdir() is broken */
+/* #undef HAVE_BROKEN_READDIR */
+
+/* Whether there is a C99 compliant vsnprintf */
+#define HAVE_C99_VSNPRINTF 1
+
+/* Define to 1 if you have the <CFStringEncodingConverter.h> header file. */
+/* #undef HAVE_CFSTRINGENCODINGCONVERTER_H */
+
+/* Define to 1 if you have the `chmod' function. */
+#define HAVE_CHMOD 1
+
+/* Define to 1 if you have the `chown' function. */
+#define HAVE_CHOWN 1
+
+/* Define to 1 if you have the `chroot' function. */
+#define HAVE_CHROOT 1
+
+/* Define to 1 if you have the `chsize' function. */
+/* #undef HAVE_CHSIZE */
+
+/* Define to 1 if you have the `closedir64' function. */
+/* #undef HAVE_CLOSEDIR64 */
+
+/* Whether the compiler will optimize out function calls */
+#define HAVE_COMPILER_WILL_OPTIMIZE_OUT_FNS 1
+
+/* Define to 1 if you have the <com_err.h> header file. */
+/* #undef HAVE_COM_ERR_H */
+
+/* Whether the system has connect() */
+#define HAVE_CONNECT 1
+
+/* Define to 1 if you have the `copy_Authenticator' function. */
+/* #undef HAVE_COPY_AUTHENTICATOR */
+
+/* Define to 1 if you have the <CoreFoundation/CFStringEncodingConverter.h>
+   header file. */
+/* #undef HAVE_COREFOUNDATION_CFSTRINGENCODINGCONVERTER_H */
+
+/* Define to 1 if you have the `creat64' function. */
+/* AR7 #define HAVE_CREAT64 1 */
+
+/* Whether the system has the crypt() function */
+#define HAVE_CRYPT 1
+
+/* Define to 1 if you have the `crypt16' function. */
+/* #undef HAVE_CRYPT16 */
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#define HAVE_CTYPE_H 1
+
+/* Whether we have CUPS */
+/* #undef HAVE_CUPS */
+
+/* Define to 1 if you have the `des_set_key' function. */
+/* #undef HAVE_DES_SET_KEY */
+
+/* Whether the 'dev64_t' type is available */
+/* #undef HAVE_DEV64_T */
+
+/* Whether the major macro for dev_t is available */
+#define HAVE_DEVICE_MAJOR_FN 1
+
+/* Whether the minor macro for dev_t is available */
+#define HAVE_DEVICE_MINOR_FN 1
+
+/* Define to 1 if you have the `devnm' function. */
+/* #undef HAVE_DEVNM */
+
+/* Define to 1 if you have the <devnm.h> header file. */
+/* #undef HAVE_DEVNM_H */
+
+/* Whether dirent has a d_off member */
+#define HAVE_DIRENT_D_OFF 1
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the `dlclose' function. */
+#define HAVE_DLCLOSE 1
+
+/* Define to 1 if you have the `dlerror' function. */
+#define HAVE_DLERROR 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `dlopen' function. */
+#define HAVE_DLOPEN 1
+
+/* Define to 1 if you have the `dlsym' function. */
+#define HAVE_DLSYM 1
+
+/* Define to 1 if you have the `dlsym_prepend_underscore' function. */
+/* #undef HAVE_DLSYM_PREPEND_UNDERSCORE */
+
+/* struct dqblk .dqb_fsoftlimit */
+/* #undef HAVE_DQB_FSOFTLIMIT */
+
+/* Define to 1 if you have the `dup2' function. */
+#define HAVE_DUP2 1
+
+/* Whether the ENCTYPE_ARCFOUR_HMAC_MD5 key type is available */
+/* #undef HAVE_ENCTYPE_ARCFOUR_HMAC_MD5 */
+
+/* Define to 1 if you have the `endmntent' function. */
+#define HAVE_ENDMNTENT 1
+
+/* Define to 1 if you have the `endnetgrent' function. */
+/* AR7 #define HAVE_ENDNETGRENT 1 */
+
+/* Whether errno() is available */
+#define HAVE_ERRNO_DECL 1
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+/* AR7 #define HAVE_EXECINFO_H 1 */
+
+
+/* Define to 1 if you have the `execl' function. */
+#define HAVE_EXECL 1
+
+/* Whether large file support can be enabled */
+/* AR7 #define HAVE_EXPLICIT_LARGEFILE_SUPPORT 1 */
+
+/* Define to 1 if you have the `extattr_delete_fd' function. */
+/* #undef HAVE_EXTATTR_DELETE_FD */
+
+/* Define to 1 if you have the `extattr_delete_file' function. */
+/* #undef HAVE_EXTATTR_DELETE_FILE */
+
+/* Define to 1 if you have the `extattr_delete_link' function. */
+/* #undef HAVE_EXTATTR_DELETE_LINK */
+
+/* Define to 1 if you have the `extattr_get_fd' function. */
+/* #undef HAVE_EXTATTR_GET_FD */
+
+/* Define to 1 if you have the `extattr_get_file' function. */
+/* #undef HAVE_EXTATTR_GET_FILE */
+
+/* Define to 1 if you have the `extattr_get_link' function. */
+/* #undef HAVE_EXTATTR_GET_LINK */
+
+/* Define to 1 if you have the `extattr_list_fd' function. */
+/* #undef HAVE_EXTATTR_LIST_FD */
+
+/* Define to 1 if you have the `extattr_list_file' function. */
+/* #undef HAVE_EXTATTR_LIST_FILE */
+
+/* Define to 1 if you have the `extattr_list_link' function. */
+/* #undef HAVE_EXTATTR_LIST_LINK */
+
+/* Define to 1 if you have the `extattr_set_fd' function. */
+/* #undef HAVE_EXTATTR_SET_FD */
+
+/* Define to 1 if you have the `extattr_set_file' function. */
+/* #undef HAVE_EXTATTR_SET_FILE */
+
+/* Define to 1 if you have the `extattr_set_link' function. */
+/* #undef HAVE_EXTATTR_SET_LINK */
+
+/* Define to 1 if you have the `fchmod' function. */
+#define HAVE_FCHMOD 1
+
+/* Define to 1 if you have the `fchown' function. */
+#define HAVE_FCHOWN 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Whether fcntl locking is available */
+#define HAVE_FCNTL_LOCK 1
+
+/* Define to 1 if you have the `fcvt' function. */
+#define HAVE_FCVT 1
+
+/* Define to 1 if you have the `fcvtl' function. */
+/* #undef HAVE_FCVTL */
+
+/* Define to 1 if you have the `fgetxattr' function. */
+/* AR7 #define HAVE_FGETXATTR 1 */
+
+/* Define to 1 if you have the `flistxattr' function. */
+/* AR7 #define HAVE_FLISTXATTR 1 */
+
+/* Define to 1 if you have the `fopen64' function. */
+/* AR7 #define HAVE_FOPEN64 1 */
+
+/* Define to 1 if you have the `fremovexattr' function. */
+/* AR7 #define HAVE_FREMOVEXATTR 1 */
+
+/* Define to 1 if you have the `fseek64' function. */
+/* #undef HAVE_FSEEK64 */
+
+/* Define to 1 if you have the `fseeko64' function. */
+/* #define HAVE_FSEEKO64 1 */
+
+/* Define to 1 if you have the `fsetxattr' function. */
+/* AR7 #define HAVE_FSETXATTR 1 */
+
+/* Define to 1 if you have the `fstat' function. */
+#define HAVE_FSTAT 1
+
+/* Whether fstat64() is available */
+/* AR7 #define HAVE_FSTAT64 1 */
+
+/* Define to 1 if you have the `fsync' function. */
+#define HAVE_FSYNC 1
+
+/* Define to 1 if you have the `ftell64' function. */
+/* #undef HAVE_FTELL64 */
+
+/* Define to 1 if you have the `ftello64' function. */
+/* AR7 #define HAVE_FTELLO64 1 */
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `ftruncate64' function. */
+/* AR7 #define HAVE_FTRUNCATE64 1 */
+
+/* Truncate extend */
+#define HAVE_FTRUNCATE_EXTEND 1
+
+/* Whether there is a __FUNCTION__ macro */
+#define HAVE_FUNCTION_MACRO 1
+
+/* Define to 1 if you have the `getauthuid' function. */
+/* #undef HAVE_GETAUTHUID */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getdents' function. */
+/* #undef HAVE_GETDENTS */
+
+/* Define to 1 if you have the `getdirentries' function. */
+#define HAVE_GETDIRENTRIES 1
+
+/* Define to 1 if you have the `getgrent' function. */
+#define HAVE_GETGRENT 1
+
+/* Define to 1 if you have the `getgrnam' function. */
+#define HAVE_GETGRNAM 1
+
+/* Define to 1 if you have the `getgrouplist' function. */
+/* #undef HAVE_GETGROUPLIST */
+
+/* Define to 1 if you have the `getmntent' function. */
+#define HAVE_GETMNTENT 1
+
+/* Define to 1 if you have the `getnetgrent' function. */
+#define HAVE_GETNETGRENT 1
+
+/* Define to 1 if you have the `getprpwnam' function. */
+/* #undef HAVE_GETPRPWNAM */
+
+/* Define to 1 if you have the `getpwanam' function. */
+/* #undef HAVE_GETPWANAM */
+
+/* Define to 1 if you have the `getrlimit' function. */
+#define HAVE_GETRLIMIT 1
+
+/* Define to 1 if you have the `getspnam' function. */
+#define HAVE_GETSPNAM 1
+
+/* Whether gettimeofday() is available */
+#define HAVE_GETTIMEOFDAY_TZ 1
+
+/* Define to 1 if you have the `getutmpx' function. */
+#define HAVE_GETUTMPX 1
+
+/* Define to 1 if you have the `getxattr' function. */
+/* AR7 #define HAVE_GETXATTR 1 */
+
+/* What header to include for iconv() function: giconv.h */
+/* #undef HAVE_GICONV */
+
+/* Define to 1 if you have the `glob' function. */
+#define HAVE_GLOB 1
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H 1
+
+/* Define to 1 if you have the `grantpt' function. */
+#define HAVE_GRANTPT 1
+
+/* Define to 1 if you have the <grp.h> header file. */
+#define HAVE_GRP_H 1
+
+/* Whether GSSAPI is available */
+/* #undef HAVE_GSSAPI */
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_GENERIC_H */
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_H */
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_H */
+
+/* Define to 1 if you have the `gss_display_status' function. */
+/* #undef HAVE_GSS_DISPLAY_STATUS */
+
+/* Define to 1 if you have the <history.h> header file. */
+/* #undef HAVE_HISTORY_H */
+
+/* Whether HPUX ACLs are available */
+/* #undef HAVE_HPUX_ACLS */
+
+/* What header to include for iconv() function: iconv.h */
+/* AR7 #define HAVE_ICONV 1 */
+
+/* Whether iface AIX is available */
+/* #undef HAVE_IFACE_AIX */
+
+/* Whether iface ifconf is available */
+#define HAVE_IFACE_IFCONF 1
+
+/* Whether iface ifreq is available */
+/* #undef HAVE_IFACE_IFREQ */
+
+/* Whether the compiler supports immediate structures */
+#define HAVE_IMMEDIATE_STRUCTURES 1
+
+/* Define to 1 if you have the `initgroups' function. */
+#define HAVE_INITGROUPS 1
+
+/* Define to 1 if you have the `innetgr' function. */
+/* AR7 #define HAVE_INNETGR 1 */
+
+/* Whether the 'ino64_t' type is available */
+/* #undef HAVE_INO64_T */
+
+/* Whether int16 typedef is included by rpc/rpc.h */
+/* #undef HAVE_INT16_FROM_RPC_RPC_H */
+
+/* Whether int32 typedef is included by rpc/rpc.h */
+/* #undef HAVE_INT32_FROM_RPC_RPC_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Whether IRIX ACLs are available */
+/* #undef HAVE_IRIX_ACLS */
+
+/* Whether IRIX specific capabilities are available */
+/* #undef HAVE_IRIX_SPECIFIC_CAPABILITIES */
+
+/* Whether kernel notifies changes */
+#define HAVE_KERNEL_CHANGE_NOTIFY 1
+
+/* Whether IRIX kernel oplock type definitions are available */
+/* #undef HAVE_KERNEL_OPLOCKS_IRIX */
+
+/* Whether to use linux kernel oplocks */
+#define HAVE_KERNEL_OPLOCKS_LINUX 1
+
+/* Whether the kernel supports share modes */
+#define HAVE_KERNEL_SHARE_MODES 1
+
+/* Whether to have KRB5 support */
+/* #undef HAVE_KRB5 */
+
+/* Define to 1 if you have the `krb5_auth_con_setkey' function. */
+/* #undef HAVE_KRB5_AUTH_CON_SETKEY */
+
+/* Define to 1 if you have the `krb5_auth_con_setuseruserkey' function. */
+/* #undef HAVE_KRB5_AUTH_CON_SETUSERUSERKEY */
+
+/* Define to 1 if you have the `krb5_c_enctype_compare' function. */
+/* #undef HAVE_KRB5_C_ENCTYPE_COMPARE */
+
+/* Whether the type krb5_encrypt_block exists */
+/* #undef HAVE_KRB5_ENCRYPT_BLOCK */
+
+/* Define to 1 if you have the `krb5_encrypt_data' function. */
+/* #undef HAVE_KRB5_ENCRYPT_DATA */
+
+/* Define to 1 if you have the `krb5_enctypes_compatible_keys' function. */
+/* #undef HAVE_KRB5_ENCTYPES_COMPATIBLE_KEYS */
+
+/* Define to 1 if you have the `krb5_free_data_contents' function. */
+/* #undef HAVE_KRB5_FREE_DATA_CONTENTS */
+
+/* Define to 1 if you have the `krb5_free_keytab_entry_contents' function. */
+/* #undef HAVE_KRB5_FREE_KEYTAB_ENTRY_CONTENTS */
+
+/* Define to 1 if you have the `krb5_free_ktypes' function. */
+/* #undef HAVE_KRB5_FREE_KTYPES */
+
+/* Define to 1 if you have the `krb5_free_unparsed_name' function. */
+/* #undef HAVE_KRB5_FREE_UNPARSED_NAME */
+
+/* Define to 1 if you have the `krb5_get_default_in_tkt_etypes' function. */
+/* #undef HAVE_KRB5_GET_DEFAULT_IN_TKT_ETYPES */
+
+/* Define to 1 if you have the `krb5_get_permitted_enctypes' function. */
+/* #undef HAVE_KRB5_GET_PERMITTED_ENCTYPES */
+
+/* Define to 1 if you have the `krb5_get_pw_salt' function. */
+/* #undef HAVE_KRB5_GET_PW_SALT */
+
+/* Define to 1 if you have the <krb5.h> header file. */
+/* #undef HAVE_KRB5_H */
+
+/* Whether the krb5_creds struct has a keyblock property */
+/* #undef HAVE_KRB5_KEYBLOCK_IN_CREDS */
+
+/* Whether the krb5_keyblock struct has a keyvalue property */
+/* #undef HAVE_KRB5_KEYBLOCK_KEYVALUE */
+
+/* Whether krb5_keytab_entry has key member */
+/* #undef HAVE_KRB5_KEYTAB_ENTRY_KEY */
+
+/* Whether krb5_keytab_entry has keyblock member */
+/* #undef HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK */
+
+/* Define to 1 if you have the `krb5_krbhst_get_addrinfo' function. */
+/* #undef HAVE_KRB5_KRBHST_GET_ADDRINFO */
+
+/* Define to 1 if you have the `krb5_kt_compare' function. */
+/* #undef HAVE_KRB5_KT_COMPARE */
+
+/* Define to 1 if you have the `krb5_kt_free_entry' function. */
+/* #undef HAVE_KRB5_KT_FREE_ENTRY */
+
+/* Define to 1 if you have the `krb5_locate_kdc' function. */
+/* #undef HAVE_KRB5_LOCATE_KDC */
+
+/* Define to 1 if you have the `krb5_mk_req_extended' function. */
+/* #undef HAVE_KRB5_MK_REQ_EXTENDED */
+
+/* Define to 1 if you have the `krb5_principal2salt' function. */
+/* #undef HAVE_KRB5_PRINCIPAL2SALT */
+
+/* Define to 1 if you have the `krb5_principal_get_comp_string' function. */
+/* #undef HAVE_KRB5_PRINCIPAL_GET_COMP_STRING */
+
+/* Whether krb5_princ_component is available */
+/* #undef HAVE_KRB5_PRINC_COMPONENT */
+
+/* Whether the krb5_creds struct has a session property */
+/* #undef HAVE_KRB5_SESSION_IN_CREDS */
+
+/* Define to 1 if you have the `krb5_set_default_in_tkt_etypes' function. */
+/* #undef HAVE_KRB5_SET_DEFAULT_IN_TKT_ETYPES */
+
+/* Define to 1 if you have the `krb5_set_default_tgs_ktypes' function. */
+/* #undef HAVE_KRB5_SET_DEFAULT_TGS_KTYPES */
+
+/* Define to 1 if you have the `krb5_set_real_time' function. */
+/* #undef HAVE_KRB5_SET_REAL_TIME */
+
+/* Define to 1 if you have the `krb5_string_to_key' function. */
+/* #undef HAVE_KRB5_STRING_TO_KEY */
+
+/* Define to 1 if you have the `krb5_string_to_key_salt' function. */
+/* #undef HAVE_KRB5_STRING_TO_KEY_SALT */
+
+/* Whether the krb5_ticket struct has a enc_part2 property */
+/* #undef HAVE_KRB5_TKT_ENC_PART2 */
+
+/* Define to 1 if you have the `krb5_use_enctype' function. */
+/* #undef HAVE_KRB5_USE_ENCTYPE */
+
+/* Whether the KV5M_KEYTAB option is available */
+/* #undef HAVE_KV5M_KEYTAB */
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define to 1 if you have the <lastlog.h> header file. */
+#define HAVE_LASTLOG_H 1
+
+/* Define to 1 if you have the <lber.h> header file. */
+/* #undef HAVE_LBER_H */
+
+/* Whether ldap is available */
+/* #undef HAVE_LDAP */
+
+/* Define to 1 if you have the `ldap_domain2hostlist' function. */
+/* #undef HAVE_LDAP_DOMAIN2HOSTLIST */
+
+/* Define to 1 if you have the <ldap.h> header file. */
+/* #undef HAVE_LDAP_H */
+
+/* Define to 1 if you have the `ldap_init' function. */
+/* #undef HAVE_LDAP_INIT */
+
+/* Define to 1 if you have the `ldap_initialize' function. */
+/* #undef HAVE_LDAP_INITIALIZE */
+
+/* Define to 1 if you have the `ldap_set_rebind_proc' function. */
+/* #undef HAVE_LDAP_SET_REBIND_PROC */
+
+/* Define to 1 if you have the `lgetxattr' function. */
+/* AR7 #define HAVE_LGETXATTR 1 */
+
+/* Define to 1 if you have the `asn1' library (-lasn1). */
+/* #undef HAVE_LIBASN1 */
+
+/* Define to 1 if you have the `com_err' library (-lcom_err). */
+/* #undef HAVE_LIBCOM_ERR */
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+/* #undef HAVE_LIBCRYPTO */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+/* #undef HAVE_LIBDL */
+
+/* Define to 1 if you have the `exc' library (-lexc). */
+/* #undef HAVE_LIBEXC */
+
+/* Define to 1 if you have the <libexc.h> header file. */
+/* #undef HAVE_LIBEXC_H */
+
+/* Define to 1 if you have the `gen' library (-lgen). */
+/* #undef HAVE_LIBGEN */
+
+/* Define to 1 if you have the `gssapi' library (-lgssapi). */
+/* #undef HAVE_LIBGSSAPI */
+
+/* Define to 1 if you have the `gssapi_krb5' library (-lgssapi_krb5). */
+/* #undef HAVE_LIBGSSAPI_KRB5 */
+
+/* Define to 1 if you have the `inet' library (-linet). */
+/* #undef HAVE_LIBINET */
+
+/* Define to 1 if you have the `k5crypto' library (-lk5crypto). */
+/* #undef HAVE_LIBK5CRYPTO */
+
+/* Define to 1 if you have the `krb5' library (-lkrb5). */
+/* #undef HAVE_LIBKRB5 */
+
+/* Define to 1 if you have the `lber' library (-llber). */
+/* #undef HAVE_LIBLBER */
+
+/* Define to 1 if you have the `ldap' library (-lldap). */
+/* #undef HAVE_LIBLDAP */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `nsl_s' library (-lnsl_s). */
+/* #undef HAVE_LIBNSL_S */
+
+/* Whether libpam is available */
+#define HAVE_LIBPAM 1
+
+/* Whether the system has readline */
+/* AR7 #define HAVE_LIBREADLINE 1 */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+#define HAVE_LIBRESOLV 1
+
+/* Define to 1 if you have the `roken' library (-lroken). */
+/* #undef HAVE_LIBROKEN */
+
+/* Define to 1 if you have the `sec' library (-lsec). */
+/* #undef HAVE_LIBSEC */
+
+/* Define to 1 if you have the `security' library (-lsecurity). */
+/* #undef HAVE_LIBSECURITY */
+
+/* Define to 1 if you have the `sendfile' library (-lsendfile). */
+/* #undef HAVE_LIBSENDFILE */
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the `link' function. */
+#define HAVE_LINK 1
+
+/* Whether Linux xfs quota support is available */
+/* AR7 #define HAVE_LINUX_XFS_QUOTAS 1 */
+
+/* Define to 1 if you have the `listxattr' function. */
+/* AR7 #define HAVE_LISTXATTR 1 */
+
+/* Define to 1 if you have the `llistxattr' function. */
+/* AR7 #define HAVE_LLISTXATTR 1 */
+
+/* Define to 1 if you have the `llseek' function. */
+#define HAVE_LLSEEK 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Whether the host supports long long's */
+#define HAVE_LONGLONG 1
+
+/* Define to 1 if you have the `lremovexattr' function. */
+/* AR7 #define HAVE_LREMOVEXATTR 1 */
+
+/* Define to 1 if you have the `lseek64' function. */
+/* AR7 #define HAVE_LSEEK64 1 */
+
+/* Define to 1 if you have the `lsetxattr' function. */
+/* AR7 #define HAVE_LSETXATTR 1 */
+
+/* Define to 1 if you have the `lstat64' function. */
+/* AR7 #define HAVE_LSTAT64 1 */
+
+/* Whether the macro for makedev is available */
+#define HAVE_MAKEDEV 1
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Whether memset() is available */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have the `mknod' function. */
+#define HAVE_MKNOD 1
+
+/* Define to 1 if you have the `mknod64' function. */
+/* #undef HAVE_MKNOD64 */
+
+/* Define to 1 if you have the `mktime' function. */
+#define HAVE_MKTIME 1
+
+/* Whether mmap works */
+#define HAVE_MMAP 1
+
+/* Define to 1 if you have the <mntent.h> header file. */
+#define HAVE_MNTENT_H 1
+
+/* Define to 1 if you have the `nanosleep' function. */
+#define HAVE_NANOSLEEP 1
+
+/* Whether to use native iconv */
+/* AR7 #define HAVE_NATIVE_ICONV 1 */
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <netinet/in_ip.h> header file. */
+/* #undef HAVE_NETINET_IN_IP_H */
+
+/* Define to 1 if you have the <netinet/in_systm.h> header file. */
+#define HAVE_NETINET_IN_SYSTM_H 1
+
+/* Define to 1 if you have the <netinet/ip.h> header file. */
+#define HAVE_NETINET_IP_H 1
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#define HAVE_NETINET_TCP_H 1
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Do we have rl_completion_matches? */
+/* AR7 #define HAVE_NEW_LIBREADLINE 1 */
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#define HAVE_NL_LANGINFO 1
+
+/* Whether no ACLs support is available */
+#define HAVE_NO_ACLS 1
+
+/* Whether no asynchronous io support is available */
+#define HAVE_NO_AIO 1
+
+/* Define to 1 if you have the <nsswitch.h> header file. */
+/* #undef HAVE_NSSWITCH_H */
+
+/* Define to 1 if you have the <nss_common.h> header file. */
+/* #undef HAVE_NSS_COMMON_H */
+
+/* Define to 1 if you have the <nss.h> header file. */
+/* AR7 #define HAVE_NSS_H 1 */
+
+/* Define to 1 if you have the <ns_api.h> header file. */
+/* #undef HAVE_NS_API_H */
+
+/* Whether off64_t is available */
+/* #undef HAVE_OFF64_T */
+
+/* Define to 1 if you have the `open64' function. */
+/* AR7 #define HAVE_OPEN64 1 */
+
+/* Define to 1 if you have the `opendir64' function. */
+/* #undef HAVE_OPENDIR64 */
+
+/* Defined if struct passwd has pw_age field */
+/* #undef HAVE_PASSWD_PW_AGE */
+
+/* Defined if struct passwd has pw_comment field */
+/* #undef HAVE_PASSWD_PW_COMMENT */
+
+/* Define to 1 if you have the `pathconf' function. */
+#define HAVE_PATHCONF 1
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Whether POSIX ACLs are available */
+/* #undef HAVE_POSIX_ACLS */
+
+/* Whether prctl is available */
+#define HAVE_PRCTL 1
+
+/* Define to 1 if you have the `pread' function. */
+#define HAVE_PREAD 1
+
+/* Define to 1 if you have the `pread64' function. */
+/* AR7 #define HAVE_PREAD64 1 */
+
+/* Define to 1 if you have the `putprpwnam' function. */
+/* #undef HAVE_PUTPRPWNAM */
+
+/* Define to 1 if you have the `pututline' function. */
+#define HAVE_PUTUTLINE 1
+
+/* Define to 1 if you have the `pututxline' function. */
+#define HAVE_PUTUTXLINE 1
+
+/* Define to 1 if you have the `pwrite' function. */
+#define HAVE_PWRITE 1
+
+/* Define to 1 if you have the `pwrite64' function. */
+/* AR7 #define HAVE_PWRITE64 1 */
+
+/* Whether CRAY int quotactl (char *spec, int request, char *arg); is
+   available */
+/* #undef HAVE_QUOTACTL_3 */
+
+/* Whether long quotactl(int cmd, char *special, qid_t id, caddr_t addr) is
+   available */
+/* #undef HAVE_QUOTACTL_4A */
+
+/* Whether int quotactl(const char *path, int cmd, int id, char *addr) is
+   available */
+/* #undef HAVE_QUOTACTL_4B */
+
+/* Whether Linux quota support is available */
+/* AR7 #define HAVE_QUOTACTL_LINUX 1 */
+
+/* Define to 1 if you have the `rand' function. */
+#define HAVE_RAND 1
+
+/* Define to 1 if you have the `random' function. */
+#define HAVE_RANDOM 1
+
+/* Define to 1 if you have the `rdchk' function. */
+/* #undef HAVE_RDCHK */
+
+/* Define to 1 if you have the `readdir64' function. */
+/* AR7 #define HAVE_READDIR64 1 */
+
+/* Define to 1 if you have the <readline.h> header file. */
+/* #undef HAVE_READLINE_H */
+
+/* Define to 1 if you have the <readline/history.h> header file. */
+#define HAVE_READLINE_HISTORY_H 1
+
+/* Define to 1 if you have the <readline/readline.h> header file. */
+#define HAVE_READLINE_READLINE_H 1
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `realpath' function. */
+#define HAVE_REALPATH 1
+
+/* Define to 1 if you have the `removexattr' function. */
+/* AR7 #define HAVE_REMOVEXATTR 1 */
+
+/* Define to 1 if you have the `rename' function. */
+#define HAVE_RENAME 1
+
+/* Define to 1 if you have the `rewinddir64' function. */
+/* #undef HAVE_REWINDDIR64 */
+
+/* Define to 1 if you have the `roken_getaddrinfo_hostspec' function. */
+/* #undef HAVE_ROKEN_GETADDRINFO_HOSTSPEC */
+
+/* Whether current user is root */
+/* #undef HAVE_ROOT */
+
+/* Define to 1 if you have the <rpcsvc/nis.h> header file. */
+#define HAVE_RPCSVC_NIS_H 1
+
+/* Define to 1 if you have the <rpcsvc/ypclnt.h> header file. */
+#define HAVE_RPCSVC_YPCLNT_H 1
+
+/* Define to 1 if you have the <rpcsvc/yp_prot.h> header file. */
+#define HAVE_RPCSVC_YP_PROT_H 1
+
+/* Whether there is a conflicting AUTH_ERROR define in rpc/rpc.h */
+/* #undef HAVE_RPC_AUTH_ERROR_CONFLICT */
+
+/* Define to 1 if you have the <rpc/nettype.h> header file. */
+/* #undef HAVE_RPC_NETTYPE_H */
+
+/* Define to 1 if you have the <rpc/rpc.h> header file. */
+#define HAVE_RPC_RPC_H 1
+
+/* Whether mkstemp is secure */
+#define HAVE_SECURE_MKSTEMP 1
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+#define HAVE_SECURITY_PAM_APPL_H 1
+
+/* Define to 1 if you have the <security/pam_modules.h> header file. */
+#define HAVE_SECURITY_PAM_MODULES_H 1
+
+/* Define to 1 if you have the <security/_pam_macros.h> header file. */
+#define HAVE_SECURITY__PAM_MACROS_H 1
+
+/* Define to 1 if you have the `seekdir64' function. */
+/* #undef HAVE_SEEKDIR64 */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Whether sendfile() is available */
+/* #undef HAVE_SENDFILE */
+
+/* Whether sendfile64() is available */
+/* AR7 #define HAVE_SENDFILE64 1 */
+
+/* Whether sendfilev() is available */
+/* #undef HAVE_SENDFILEV */
+
+/* Whether sendfilev64() is available */
+/* #undef HAVE_SENDFILEV64 */
+
+/* Define to 1 if you have the `setbuffer' function. */
+#define HAVE_SETBUFFER 1
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `setgidx' function. */
+/* #undef HAVE_SETGIDX */
+
+/* Define to 1 if you have the `setgroups' function. */
+#define HAVE_SETGROUPS 1
+
+/* Define to 1 if you have the `setlinebuf' function. */
+#define HAVE_SETLINEBUF 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the `setluid' function. */
+/* #undef HAVE_SETLUID */
+
+/* Define to 1 if you have the `setmntent' function. */
+#define HAVE_SETMNTENT 1
+
+/* Define to 1 if you have the `setnetgrent' function. */
+#define HAVE_SETNETGRENT 1
+
+/* Define to 1 if you have the `setpgid' function. */
+#define HAVE_SETPGID 1
+
+/* Define to 1 if you have the `setpriv' function. */
+/* #undef HAVE_SETPRIV */
+
+/* Whether the system has setresgid */
+#define HAVE_SETRESGID 1
+
+/* Whether setresgid() is available */
+#define HAVE_SETRESGID_DECL 1
+
+/* Whether the system has setresuid */
+#define HAVE_SETRESUID 1
+
+/* Whether setresuid() is available */
+#define HAVE_SETRESUID_DECL 1
+
+/* Define to 1 if you have the `setsid' function. */
+#define HAVE_SETSID 1
+
+/* Define to 1 if you have the `setuidx' function. */
+/* #undef HAVE_SETUIDX */
+
+/* Define to 1 if you have the `setxattr' function. */
+/* AR7 #define HAVE_SETXATTR 1 */
+
+/* Define to 1 if you have the `set_auth_parameters' function. */
+/* #undef HAVE_SET_AUTH_PARAMETERS */
+
+/* Define to 1 if you have the <shadow.h> header file. */
+#define HAVE_SHADOW_H 1
+
+/* Define to 1 if you have the `shmget' function. */
+#define HAVE_SHMGET 1
+
+/* Define to 1 if you have the `shm_open' function. */
+/* #undef HAVE_SHM_OPEN */
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `sigblock' function. */
+#define HAVE_SIGBLOCK 1
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#define HAVE_SIGPROCMASK 1
+
+/* Define to 1 if you have the `sigset' function. */
+#define HAVE_SIGSET 1
+
+/* Whether we have the atomic_t variable type */
+#define HAVE_SIG_ATOMIC_T_TYPE 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Whether snprintf() is available */
+#define HAVE_SNPRINTF_DECL 1
+
+/* Whether we have the variable type socklen_t */
+#define HAVE_SOCKLEN_T_TYPE 1
+
+/* Whether the sockaddr_in struct has a sin_len property */
+/* #undef HAVE_SOCK_SIN_LEN */
+
+/* Whether solaris ACLs are available */
+/* #undef HAVE_SOLARIS_ACLS */
+
+/* Define to 1 if you have the `srand' function. */
+#define HAVE_SRAND 1
+
+/* Define to 1 if you have the `srandom' function. */
+#define HAVE_SRANDOM 1
+
+/* Whether stat64() is available */
+/* AR7 #define HAVE_STAT64 1 */
+
+/* whether struct stat has sub-second timestamps */
+/* AR7 #define HAVE_STAT_HIRES_TIMESTAMPS 1 */
+
+/* whether struct stat contains st_atim */
+#define HAVE_STAT_ST_ATIM 1
+
+/* Whether the stat struct has a st_blksize property */
+#define HAVE_STAT_ST_BLKSIZE 1
+
+/* Whether the stat struct has a st_block property */
+#define HAVE_STAT_ST_BLOCKS 1
+
+/* whether struct stat contains st_ctim */
+#define HAVE_STAT_ST_CTIM 1
+
+/* whether struct stat contains st_mtim */
+#define HAVE_STAT_ST_MTIM 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if you have the <stropts.h> header file. */
+/* AR7 #define HAVE_STROPTS_H 1 */
+
+/* Define to 1 if you have the `strpbrk' function. */
+#define HAVE_STRPBRK 1
+
+/* Define to 1 if you have the `strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* Whether the 'DIR64' abstract data type is available */
+/* #undef HAVE_STRUCT_DIR64 */
+
+/* Whether the 'dirent64' struct is available */
+/* AR7 #define HAVE_STRUCT_DIRENT64 1 */
+
+/* Whether the flock64 struct is available */
+/* AR7 #define HAVE_STRUCT_FLOCK64 1 */
+
+/* Define to 1 if `method_attrlist' is member of `struct secmethod_table'. */
+/* #undef HAVE_STRUCT_SECMETHOD_TABLE_METHOD_ATTRLIST */
+
+/* Define to 1 if `method_version' is member of `struct secmethod_table'. */
+/* #undef HAVE_STRUCT_SECMETHOD_TABLE_METHOD_VERSION */
+
+/* Define to 1 if `st_rdev' is member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_RDEV 1
+
+/* Whether we have struct timespec */
+#define HAVE_STRUCT_TIMESPEC 1
+
+/* Define to 1 if your `struct stat' has `st_rdev'. Deprecated, use
+   `HAVE_STRUCT_STAT_ST_RDEV' instead. */
+#define HAVE_ST_RDEV 1
+
+/* Define to 1 if you have the `symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `syscall' function. */
+#define HAVE_SYSCALL 1
+
+/* Define to 1 if you have the <syscall.h> header file. */
+#define HAVE_SYSCALL_H 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the `syslog' function. */
+#define HAVE_SYSLOG 1
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/acl.h> header file. */
+/* #undef HAVE_SYS_ACL_H */
+
+/* Define to 1 if you have the <sys/attributes.h> header file. */
+/* #undef HAVE_SYS_ATTRIBUTES_H */
+
+/* Define to 1 if you have the <sys/capability.h> header file. */
+/* #undef HAVE_SYS_CAPABILITY_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+#define HAVE_SYS_CDEFS_H 1
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/dustat.h> header file. */
+/* #undef HAVE_SYS_DUSTAT_H */
+
+/* Define to 1 if you have the <sys/extattr.h> header file. */
+/* #undef HAVE_SYS_EXTATTR_H */
+
+/* Define to 1 if you have the <sys/fcntl.h> header file. */
+#define HAVE_SYS_FCNTL_H 1
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+/* #undef HAVE_SYS_FILIO_H */
+
+/* Define to 1 if you have the <sys/filsys.h> header file. */
+/* #undef HAVE_SYS_FILSYS_H */
+
+/* Define to 1 if you have the <sys/fs/s5param.h> header file. */
+/* #undef HAVE_SYS_FS_S5PARAM_H */
+
+/* Define to 1 if you have the <sys/fs/vx_quota.h> header file. */
+/* #undef HAVE_SYS_FS_VX_QUOTA_H */
+
+/* Define to 1 if you have the <sys/id.h> header file. */
+/* #undef HAVE_SYS_ID_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/ipc.h> header file. */
+#define HAVE_SYS_IPC_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/mode.h> header file. */
+/* #undef HAVE_SYS_MODE_H */
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+#define HAVE_SYS_MOUNT_H 1
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/prctl.h> header file. */
+#define HAVE_SYS_PRCTL_H 1
+
+/* Define to 1 if you have the <sys/priv.h> header file. */
+/* #undef HAVE_SYS_PRIV_H */
+
+/* Whether the new lib/sysquotas.c interface can be used */
+/* AR7 #define HAVE_SYS_QUOTAS 1 */
+
+/* Define to 1 if you have the <sys/quota.h> header file. */
+/* AR7 #define HAVE_SYS_QUOTA_H 1 */
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/security.h> header file. */
+/* #undef HAVE_SYS_SECURITY_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#define HAVE_SYS_SHM_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/statfs.h> header file. */
+#define HAVE_SYS_STATFS_H 1
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#define HAVE_SYS_STATVFS_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/syscall.h> header file. */
+#define HAVE_SYS_SYSCALL_H 1
+
+/* Define to 1 if you have the <sys/syslog.h> header file. */
+#define HAVE_SYS_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+#define HAVE_SYS_SYSMACROS_H 1
+
+/* Define to 1 if you have the <sys/termio.h> header file. */
+/* #undef HAVE_SYS_TERMIO_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define to 1 if you have the <sys/unistd.h> header file. */
+#define HAVE_SYS_UNISTD_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <sys/vfs.h> header file. */
+#define HAVE_SYS_VFS_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <sys/xattr.h> header file. */
+/* AR7 #define HAVE_SYS_XATTR_H 1 */
+
+/* Define to 1 if you have the `telldir64' function. */
+/* #undef HAVE_TELLDIR64 */
+
+/* Define to 1 if you have the <termios.h> header file. */
+#define HAVE_TERMIOS_H 1
+
+/* Define to 1 if you have the <termio.h> header file. */
+#define HAVE_TERMIO_H 1
+
+/* Define to 1 if you have the `timegm' function. */
+/* AR7 #define HAVE_TIMEGM 1 */
+
+/* Whether Tru64 ACLs are available */
+/* #undef HAVE_TRU64_ACLS */
+
+/* Whether crypt needs truncated salt */
+/* #undef HAVE_TRUNCATED_SALT */
+
+/* Whether uint16 typedef is included by rpc/rpc.h */
+/* #undef HAVE_UINT16_FROM_RPC_RPC_H */
+
+/* Whether uint32 typedef is included by rpc/rpc.h */
+/* #undef HAVE_UINT32_FROM_RPC_RPC_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* If we need to build with unixscoket support */
+#define HAVE_UNIXSOCKET 1
+
+/* Whether UnixWare ACLs are available */
+/* #undef HAVE_UNIXWARE_ACLS */
+
+/* Whether the 'unsigned char' type is available */
+/* #undef HAVE_UNSIGNED_CHAR */
+
+/* Define to 1 if you have the `updwtmp' function. */
+#define HAVE_UPDWTMP 1
+
+/* Define to 1 if you have the `updwtmpx' function. */
+#define HAVE_UPDWTMPX 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Whether struct utimbuf is available */
+#define HAVE_UTIMBUF 1
+
+/* Define to 1 if you have the `utime' function. */
+#define HAVE_UTIME 1
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if you have the <utmpx.h> header file. */
+/* #define HAVE_UTMPX_H 1 */
+
+/* Define to 1 if you have the <utmp.h> header file. */
+#define HAVE_UTMP_H 1
+
+/* Whether the utmp struct has a property ut_addr */
+#define HAVE_UT_UT_ADDR 1
+
+/* Whether the utmp struct has a property ut_exit */
+#define HAVE_UT_UT_EXIT 1
+
+/* Whether the utmp struct has a property ut_host */
+#define HAVE_UT_UT_HOST 1
+
+/* Whether the utmp struct has a property ut_id */
+#define HAVE_UT_UT_ID 1
+
+/* Whether the utmp struct has a property ut_name */
+#define HAVE_UT_UT_NAME 1
+
+/* Whether the utmp struct has a property ut_pid */
+#define HAVE_UT_UT_PID 1
+
+/* Whether the utmp struct has a property ut_time */
+#define HAVE_UT_UT_TIME 1
+
+/* Whether the utmp struct has a property ut_tv */
+#define HAVE_UT_UT_TV 1
+
+/* Whether the utmp struct has a property ut_type */
+#define HAVE_UT_UT_TYPE 1
+
+/* Whether the utmp struct has a property ut_user */
+#define HAVE_UT_UT_USER 1
+
+/* Whether the utmpx struct has a property ut_syslen */
+/* #undef HAVE_UX_UT_SYSLEN */
+
+/* Define to 1 if you have the <valgrind.h> header file. */
+/* #undef HAVE_VALGRIND_H */
+
+/* Define to 1 if you have the <valgrind/memcheck.h> header file. */
+/* #undef HAVE_VALGRIND_MEMCHECK_H */
+
+/* Define to 1 if you have the <valgrind/valgrind.h> header file. */
+/* #undef HAVE_VALGRIND_VALGRIND_H */
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Whether vasprintf() is available */
+#define HAVE_VASPRINTF_DECL 1
+
+/* Whether va_copy() is available */
+#define HAVE_VA_COPY 1
+
+/* Whether the C compiler understands volatile */
+#define HAVE_VOLATILE 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Whether vsnprintf() is available */
+#define HAVE_VSNPRINTF_DECL 1
+
+/* Define to 1 if you have the `vsyslog' function. */
+#define HAVE_VSYSLOG 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define HAVE_WAITPID 1
+
+/* Define if you have working AF_LOCAL sockets */
+#define HAVE_WORKING_AF_LOCAL 1
+
+/* Whether the WRFILE:-keytab is supported */
+/* #undef HAVE_WRFILE_KEYTAB */
+
+/* Whether xfs quota support is available */
+/* AR7 #define HAVE_XFS_QUOTAS 1 */
+
+/* Define to 1 if you have the `yp_get_default_domain' function. */
+#define HAVE_YP_GET_DEFAULT_DOMAIN 1
+
+/* Define to 1 if you have the `_acl' function. */
+/* #undef HAVE__ACL */
+
+/* Define to 1 if you have the `_chdir' function. */
+/* #undef HAVE__CHDIR */
+
+/* Define to 1 if you have the `_close' function. */
+/* #undef HAVE__CLOSE */
+
+/* Define to 1 if you have the `_closedir' function. */
+/* #undef HAVE__CLOSEDIR */
+
+/* Define to 1 if you have the `_dup' function. */
+/* #undef HAVE__DUP */
+
+/* Define to 1 if you have the `_dup2' function. */
+/* #undef HAVE__DUP2 */
+
+/* Define to 1 if you have the `_et_list' function. */
+/* #undef HAVE__ET_LIST */
+
+/* Define to 1 if you have the `_facl' function. */
+/* #undef HAVE__FACL */
+
+/* Define to 1 if you have the `_fchdir' function. */
+/* #undef HAVE__FCHDIR */
+
+/* Define to 1 if you have the `_fcntl' function. */
+/* #undef HAVE__FCNTL */
+
+/* Define to 1 if you have the `_fork' function. */
+/* #undef HAVE__FORK */
+
+/* Define to 1 if you have the `_fstat' function. */
+/* #undef HAVE__FSTAT */
+
+/* Define to 1 if you have the `_fstat64' function. */
+/* #undef HAVE__FSTAT64 */
+
+/* Define to 1 if you have the `_getcwd' function. */
+/* #undef HAVE__GETCWD */
+
+/* Define to 1 if you have the `_getdents' function. */
+/* #undef HAVE__GETDENTS */
+
+/* Define to 1 if you have the `_llseek' function. */
+/* #undef HAVE__LLSEEK */
+
+/* Define to 1 if you have the `_lseek' function. */
+/* #undef HAVE__LSEEK */
+
+/* Define to 1 if you have the `_lstat' function. */
+/* #undef HAVE__LSTAT */
+
+/* Define to 1 if you have the `_lstat64' function. */
+/* #undef HAVE__LSTAT64 */
+
+/* Define to 1 if you have the `_open' function. */
+/* #undef HAVE__OPEN */
+
+/* Define to 1 if you have the `_open64' function. */
+/* #undef HAVE__OPEN64 */
+
+/* Define to 1 if you have the `_opendir' function. */
+/* #undef HAVE__OPENDIR */
+
+/* Define to 1 if you have the `_pread' function. */
+/* #undef HAVE__PREAD */
+
+/* Define to 1 if you have the `_pread64' function. */
+/* #undef HAVE__PREAD64 */
+
+/* Define to 1 if you have the `_pwrite' function. */
+/* #undef HAVE__PWRITE */
+
+/* Define to 1 if you have the `_pwrite64' function. */
+/* #undef HAVE__PWRITE64 */
+
+/* Define to 1 if you have the `_read' function. */
+/* #undef HAVE__READ */
+
+/* Define to 1 if you have the `_readdir' function. */
+/* #undef HAVE__READDIR */
+
+/* Define to 1 if you have the `_readdir64' function. */
+/* #undef HAVE__READDIR64 */
+
+/* Define to 1 if you have the `_seekdir' function. */
+/* #undef HAVE__SEEKDIR */
+
+/* Define to 1 if you have the `_stat' function. */
+/* #undef HAVE__STAT */
+
+/* Define to 1 if you have the `_stat64' function. */
+/* #undef HAVE__STAT64 */
+
+/* Define to 1 if you have the `_telldir' function. */
+/* #undef HAVE__TELLDIR */
+
+/* Define to 1 if you have the `_write' function. */
+/* #undef HAVE__WRITE */
+
+/* Define to 1 if you have the `__acl' function. */
+/* #undef HAVE___ACL */
+
+/* Define to 1 if you have the `__chdir' function. */
+/* #undef HAVE___CHDIR */
+
+/* Define to 1 if you have the `__close' function. */
+#define HAVE___CLOSE 1
+
+/* Define to 1 if you have the `__closedir' function. */
+/* #undef HAVE___CLOSEDIR */
+
+/* Define to 1 if you have the `__dup' function. */
+/* #undef HAVE___DUP */
+
+/* Define to 1 if you have the `__dup2' function. */
+#define HAVE___DUP2 1
+
+/* Define to 1 if you have the `__facl' function. */
+/* #undef HAVE___FACL */
+
+/* Define to 1 if you have the `__fchdir' function. */
+/* #undef HAVE___FCHDIR */
+
+/* Define to 1 if you have the `__fcntl' function. */
+#define HAVE___FCNTL 1
+
+/* Define to 1 if you have the `__fork' function. */
+#define HAVE___FORK 1
+
+/* Define to 1 if you have the `__fstat' function. */
+#define HAVE___FSTAT 1
+
+/* Define to 1 if you have the `__fstat64' function. */
+/* #undef HAVE___FSTAT64 */
+
+/* Define to 1 if you have the `__fxstat' function. */
+#define HAVE___FXSTAT 1
+
+/* Define to 1 if you have the `__getcwd' function. */
+/* #undef HAVE___GETCWD */
+
+/* Define to 1 if you have the `__getdents' function. */
+/* #undef HAVE___GETDENTS */
+
+/* Define to 1 if you have the `__llseek' function. */
+/* #undef HAVE___LLSEEK */
+
+/* Define to 1 if you have the `__lseek' function. */
+#define HAVE___LSEEK 1
+
+/* Define to 1 if you have the `__lstat' function. */
+#define HAVE___LSTAT 1
+
+/* Define to 1 if you have the `__lstat64' function. */
+/* #undef HAVE___LSTAT64 */
+
+/* Define to 1 if you have the `__lxstat' function. */
+#define HAVE___LXSTAT 1
+
+/* Define to 1 if you have the `__open' function. */
+#define HAVE___OPEN 1
+
+/* Define to 1 if you have the `__open64' function. */
+/* AR7 #define HAVE___OPEN64 1 */
+
+/* Define to 1 if you have the `__opendir' function. */
+/* #undef HAVE___OPENDIR */
+
+/* Define to 1 if you have the `__pread' function. */
+/* #undef HAVE___PREAD */
+
+/* Define to 1 if you have the `__pread64' function. */
+/* AR7 #define HAVE___PREAD64 1 */
+
+/* Define to 1 if you have the `__pwrite' function. */
+/* #undef HAVE___PWRITE */
+
+/* Define to 1 if you have the `__pwrite64' function. */
+/* AR7 #define HAVE___PWRITE64 1 */
+
+/* Define to 1 if you have the `__read' function. */
+#define HAVE___READ 1
+
+/* Define to 1 if you have the `__readdir' function. */
+/* #undef HAVE___READDIR */
+
+/* Define to 1 if you have the `__readdir64' function. */
+/* #undef HAVE___READDIR64 */
+
+/* Define to 1 if you have the `__seekdir' function. */
+/* #undef HAVE___SEEKDIR */
+
+/* Define to 1 if you have the `__stat' function. */
+#define HAVE___STAT 1
+
+/* Define to 1 if you have the `__stat64' function. */
+/* #undef HAVE___STAT64 */
+
+/* Define to 1 if you have the `__sys_llseek' function. */
+/* #undef HAVE___SYS_LLSEEK */
+
+/* Define to 1 if you have the `__telldir' function. */
+/* #undef HAVE___TELLDIR */
+
+/* Whether __va_copy() is available */
+/* #undef HAVE___VA_COPY */
+
+/* Define to 1 if you have the `__write' function. */
+#define HAVE___WRITE 1
+
+/* Define to 1 if you have the `__xstat' function. */
+#define HAVE___XSTAT 1
+
+/* Whether the host os is HPUX */
+/* #undef HPUX */
+
+/* Whether the hpux sendfile() API is available */
+/* #undef HPUX_SENDFILE_API */
+
+/* Whether to use intel spinlocks */
+/* #undef INTEL_SPINLOCKS */
+
+/* Whether the host os is irix */
+/* #undef IRIX */
+
+/* Whether the host os is irix6 */
+/* #undef IRIX6 */
+
+/* Whether krb5_princ_realm returns krb5_realm or krb5_data */
+/* #undef KRB5_PRINC_REALM_RETURNS_REALM */
+
+/* Number of arguments to ldap_set_rebind_proc */
+/* #undef LDAP_SET_REBIND_PROC_ARGS */
+
+/* Whether the host os is linux */
+#define LINUX 1
+
+/* Whether (linux) sendfile() is broken */
+/* #undef LINUX_BROKEN_SENDFILE_API */
+
+/* Whether linux sendfile() API is available */
+#define LINUX_SENDFILE_API 1
+
+/* Whether to use mips spinlocks */
+/* #undef MIPS_SPINLOCKS */
+
+/* Whether MMAP is broken */
+/* #undef MMAP_BLACKLIST */
+
+/* Whether the host os is NeXT v2 */
+/* #undef NEXT2 */
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Whether the host os is osf1 */
+/* #undef OSF1 */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Does a POSIX ACL need a mask element */
+/* #undef POSIX_ACL_NEEDS_MASK */
+
+/* Whether to use powerpc spinlocks */
+/* #undef POWERPC_SPINLOCKS */
+
+/* Whether pututline returns pointer */
+#define PUTUTLINE_RETURNS_UTMP 1
+
+/* Whether the host os is qnx */
+/* #undef QNX */
+
+/* Whether the realpath function allows NULL */
+#define REALPATH_TAKES_NULL 1
+
+/* Whether the host os is reliantunix */
+/* #undef RELIANTUNIX */
+
+/* Whether getpass should be replaced */
+#define REPLACE_GETPASS 1
+
+/* Whether inet_ntoa should be replaced */
+/* #undef REPLACE_INET_NTOA */
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Whether the host os is sco unix */
+/* #undef SCO */
+
+/* Whether seekdir returns void */
+#define SEEKDIR_RETURNS_VOID 1
+
+/* The size of the 'ino_t' type */
+/* AR7 #define SIZEOF_INO_T 8 */
+#define SIZEOF_INO_T 4 /* AR7 */
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* The size of the 'off_t' type */
+/* AR7 #define SIZEOF_OFF_T 8 */
+#define SIZEOF_OFF_T 4 /* AR7 */
+
+/* The size of a `short', as computed by sizeof. */
+#define SIZEOF_SHORT 2
+
+/* Use socket wrapper library */
+/* #undef SOCKET_WRAPPER */
+
+/* Whether the solaris sendfile() API is available */
+/* #undef SOLARIS_SENDFILE_API */
+
+/* Whether to use sparc spinlocks */
+/* #undef SPARC_SPINLOCKS */
+
+/* Whether statfs requires two arguments and struct statfs has bsize property
+   */
+/* #undef STAT_STATFS2_BSIZE */
+
+/* Whether statfs requires 2 arguments and struct statfs has fsize */
+/* #undef STAT_STATFS2_FSIZE */
+
+/* Whether statfs requires 2 arguments and struct fs_data is available */
+/* #undef STAT_STATFS2_FS_DATA */
+
+/* Whether statfs requires 3 arguments */
+/* #undef STAT_STATFS3_OSF1 */
+
+/* Whether statfs requires 4 arguments */
+/* #undef STAT_STATFS4 */
+
+/* Whether statvfs() is available */
+#define STAT_STATVFS 1 /* AR7 */
+
+/* Whether statvfs64() is available */
+/* AR7 #define STAT_STATVFS64 1 */
+
+/* The size of a block */
+#define STAT_ST_BLOCKSIZE 512
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* String list of builtin modules */
+#define STRING_STATIC_MODULES " pdb_smbpasswd pdb_tdbsam pdb_guest rpc_lsa rpc_reg rpc_lsa_ds rpc_wks rpc_svcctl rpc_net rpc_dfs rpc_srv rpc_spoolss rpc_eventlog rpc_samr idmap_tdb auth_rhosts auth_sam auth_unix auth_winbind auth_server auth_domain auth_builtin"
+
+/* Whether the host os is sunos4 */
+/* #undef SUNOS4 */
+
+/* Whether the host os is solaris */
+/* #undef SUNOS5 */
+
+/* Whether sysconf(_SC_NGROUPS_MAX) is available */
+#define SYSCONF_SC_NGROUPS_MAX 1
+
+/* Whether sysconf(_SC_NPROC_ONLN) is available */
+/* #undef SYSCONF_SC_NPROC_ONLN */
+
+/* Whether this is a system V system */
+/* #undef SYSV */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Whether the host os is unixware */
+/* #undef UNIXWARE */
+
+/* Whether to use both of HPUX' crypt calls */
+/* #undef USE_BOTH_CRYPT_CALLS */
+
+/* Whether seteuid() is available */
+/* #undef USE_SETEUID */
+
+/* Whether setresuid() is available */
+#define USE_SETRESUID 1
+
+/* Whether setreuid() is available */
+/* #undef USE_SETREUID */
+
+/* Whether setuidx() is available */
+/* #undef USE_SETUIDX */
+
+/* Whether to use spin locks instead of fcntl locks */
+/* #undef USE_SPINLOCKS */
+
+/* Whether to include Active Directory support */
+/* #undef WITH_ADS */
+
+/* Whether to include AFS clear-text auth support */
+/* #undef WITH_AFS */
+
+/* Using asynchronous io */
+/* #undef WITH_AIO */
+
+/* Whether to include automount support */
+/* #undef WITH_AUTOMOUNT */
+
+/* Whether to include DFS support */
+/* #undef WITH_DFS */
+
+/* Whether to include AFS fake-kaserver support */
+/* #undef WITH_FAKE_KASERVER */
+
+/* Whether to include 2.2 compatible LDAP SAM configuration */
+/* #undef WITH_LDAP_SAMCONFIG */
+
+/* Whether to include nisplus_home support */
+/* #undef WITH_NISPLUS_HOME */
+
+/* Whether to include PAM support */
+/* #undef WITH_PAM */
+
+/* Whether to use profiling */
+/* #undef WITH_PROFILE */
+
+/* Whether to use disk quota support */
+/* AR7 #define WITH_QUOTAS 1 */
+
+/* Whether to include sendfile() support */
+#define WITH_SENDFILE 1
+
+/* Whether to build smbmount */
+/* #undef WITH_SMBMOUNT */
+
+/* Whether to include smbwrapper support */
+/* #undef WITH_SMBWRAPPER */
+
+/* Whether to include experimental syslog support */
+/* #undef WITH_SYSLOG */
+
+/* Whether to include experimental utmp accounting */
+#define WITH_UTMP 1
+
+/* Whether to build winbind */
+#define WITH_WINBIND 1
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+/* #undef WORDS_BIGENDIAN */
+
+/* Required alignment */
+/* #undef _ALIGNMENT_REQUIRED */
+
+/* File offset bits */
+/* AR7 #define _FILE_OFFSET_BITS 64 */
+
+/* Whether to use GNU libc extensions */
+#define _GNU_SOURCE 1
+
+/* Whether to use HPUX extensions */
+/* #undef _HPUX_SOURCE */
+
+/* Whether to enable large file support */
+/* AR7 #define _LARGEFILE64_SOURCE 1 */
+
+/* Whether to enable large file support */
+/* #undef _LARGE_FILES */
+
+/* Maximum alignment */
+/* #undef _MAX_ALIGNMENT */
+
+/* Whether to enable POSIX support */
+/* #undef _POSIX_C_SOURCE */
+
+/* Whether to use POSIX compatible functions */
+/* #undef _POSIX_SOURCE */
+
+/* Whether to enable System V compatibility */
+/* #undef _SYSV */
+
+/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
+#ifndef __CHAR_UNSIGNED__
+/* # undef __CHAR_UNSIGNED__ */
+#endif
+
+/* Whether to build auth_builtin as shared module */
+/* #undef auth_builtin_init */
+
+/* Whether to build auth_domain as shared module */
+/* #undef auth_domain_init */
+
+/* Whether to build auth_rhosts as shared module */
+/* #undef auth_rhosts_init */
+
+/* Whether to build auth_sam as shared module */
+/* #undef auth_sam_init */
+
+/* Whether to build auth_server as shared module */
+/* #undef auth_server_init */
+
+/* Whether to build auth_unix as shared module */
+/* #undef auth_unix_init */
+
+/* Whether to build auth_winbind as shared module */
+/* #undef auth_winbind_init */
+
+/* Whether to build charset_CP437 as shared module */
+#define charset_CP437_init init_module
+
+/* Whether to build charset_CP850 as shared module */
+#define charset_CP850_init init_module
+
+/* Whether to build charset_macosxfs as shared module */
+/* #undef charset_macosxfs_init */
+
+/* Whether to build charset_weird as shared module */
+/* #undef charset_weird_init */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Whether to build idmap_ad as shared module */
+/* #undef idmap_ad_init */
+
+/* Whether to build idmap_ldap as shared module */
+/* #undef idmap_ldap_init */
+
+/* Whether to build idmap_rid as shared module */
+/* #undef idmap_rid_init */
+
+/* Whether to build idmap_tdb as shared module */
+/* #undef idmap_tdb_init */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+/* #undef ino_t */
+
+/* Define to `off_t' if <sys/types.h> does not define. */
+/* #undef loff_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `loff_t' if <sys/types.h> does not define. */
+#define offset_t loff_t
+
+/* Whether to build pdb_guest as shared module */
+/* #undef pdb_guest_init */
+
+/* Whether to build pdb_ldap as shared module */
+/* #undef pdb_ldap_init */
+
+/* Whether to build pdb_mysql as shared module */
+/* #undef pdb_mysql_init */
+
+/* Whether to build pdb_pgsql as shared module */
+/* #undef pdb_pgsql_init */
+
+/* Whether to build pdb_smbpasswd as shared module */
+/* #undef pdb_smbpasswd_init */
+
+/* Whether to build pdb_tdbsam as shared module */
+/* #undef pdb_tdbsam_init */
+
+/* Whether to build pdb_xml as shared module */
+/* #undef pdb_xml_init */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Whether to build rpc_dfs as shared module */
+/* #undef rpc_dfs_init */
+
+/* Whether to build rpc_echo as shared module */
+/* #undef rpc_echo_init */
+
+/* Whether to build rpc_eventlog as shared module */
+/* #undef rpc_eventlog_init */
+
+/* Whether to build rpc_lsa_ds as shared module */
+/* #undef rpc_lsa_ds_init */
+
+/* Whether to build rpc_lsa as shared module */
+/* #undef rpc_lsa_init */
+
+/* Whether to build rpc_net as shared module */
+/* #undef rpc_net_init */
+
+/* Whether to build rpc_reg as shared module */
+/* #undef rpc_reg_init */
+
+/* Whether to build rpc_samr as shared module */
+/* #undef rpc_samr_init */
+
+/* Whether to build rpc_spoolss as shared module */
+/* #undef rpc_spoolss_init */
+
+/* Whether to build rpc_srv as shared module */
+/* #undef rpc_srv_init */
+
+/* Whether to build rpc_svcctl as shared module */
+/* #undef rpc_svcctl_init */
+
+/* Whether to build rpc_wks as shared module */
+/* #undef rpc_wks_init */
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef ssize_t */
+
+/* Static init functions */
+/* AR7  #define static_init_auth { auth_rhosts_init(); auth_sam_init(); auth_unix_init(); auth_winbind_init(); auth_server_init(); auth_domain_init(); auth_builtin_init();} */
+#define static_init_auth { auth_sam_init(); auth_builtin_init();}
+
+/* Static init functions */
+#define static_init_charset {}
+
+/* Static init functions */
+#define static_init_idmap { idmap_tdb_init();}
+
+/* Static init functions */
+#define static_init_pdb { pdb_smbpasswd_init(); pdb_tdbsam_init(); /* pdb_guest_init(); */}
+
+/* Static init functions */
+/* AR7 #define static_init_rpc { rpc_lsa_init(); rpc_reg_init(); rpc_lsa_ds_init(); rpc_wks_init(); rpc_svcctl_init(); rpc_net_init(); rpc_dfs_init(); rpc_srv_init(); rpc_spoolss_init(); rpc_eventlog_init(); rpc_samr_init();} */
+#define static_init_rpc { rpc_lsa_init(); /* rpc_reg_init();*/ rpc_lsa_ds_init(); rpc_wks_init(); /* rpc_svcctl_init(); */ rpc_net_init(); rpc_dfs_init(); /* rpc_srv_init(); */ /* rpc_eventlog_init(); */ /* rpc_samr_init(); */}
+
+/* Static init functions */
+#define static_init_vfs {}
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Whether to build vfs_afsacl as shared module */
+/* #undef vfs_afsacl_init */
+
+/* Whether to build vfs_audit as shared module */
+#define vfs_audit_init init_module
+
+/* Whether to build vfs_cap as shared module */
+#define vfs_cap_init init_module
+
+/* Whether to build vfs_catia as shared module */
+/* #undef vfs_catia_init */
+
+/* Whether to build vfs_default_quota as shared module */
+#define vfs_default_quota_init init_module
+
+/* Whether to build vfs_expand_msdfs as shared module */
+#define vfs_expand_msdfs_init init_module
+
+/* Whether to build vfs_extd_audit as shared module */
+#define vfs_extd_audit_init init_module
+
+/* Whether to build vfs_fake_perms as shared module */
+#define vfs_fake_perms_init init_module
+
+/* Whether to build vfs_full_audit as shared module */
+#define vfs_full_audit_init init_module
+
+/* Whether to build vfs_netatalk as shared module */
+#define vfs_netatalk_init init_module
+
+/* Whether to build vfs_readonly as shared module */
+#define vfs_readonly_init init_module
+
+/* Whether to build vfs_recycle as shared module */
+#define vfs_recycle_init init_module
+
+/* Whether to build vfs_shadow_copy as shared module */
+#define vfs_shadow_copy_init init_module
+
+/* Define to `unsigned short' if <sys/types.h> does not define. */
+/* #undef wchar_t */
