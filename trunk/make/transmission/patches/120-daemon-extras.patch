--- daemon/daemon.c	2009-04-27 15:04:10.000000000 +0200
+++ daemon/daemon.c.mod	2009-04-30 22:29:31.213576873 +0200
@@ -30,6 +30,8 @@
 #include <libtransmission/tr-getopt.h>
 #include <libtransmission/utils.h>
 #include <libtransmission/version.h>
+#include <libtransmission/platform.h>
+
 
 #include "watch.h"
 
@@ -42,6 +44,12 @@
 static tr_bool closing = FALSE;
 static tr_session * mySession = NULL;
 
+static char z_seedPath[MAX_PATH_LENGTH] = "";
+static char z_finishPath[MAX_PATH_LENGTH] = "";
+static float z_ratio = TR_RATIO_INF;
+tr_torrent * tr_torrentNext( tr_session *, tr_torrent *);
+
+
 /***
 ****  Config File
 ***/
@@ -87,6 +95,10 @@
     { 'i', "bind-address-ipv4", "Where to listen for peer connections", "i", 1, "<ipv4 address>" },
     { 'I', "bind-address-ipv6", "Where to listen for peer connections", "I", 1, "<ipv6 address" },
     { 'r', "rpc-bind-address", "Where to listen for RPC connections", "r", 1, "<ipv4 address>" },
+    { 913, "z_seed-dir", "Move seeding files to dir if set (Default: NULL)", "z_sd", 1, "<path>" },
+    { 914, "z_finish-dir", "Move completed files (everything done) to dir if set (Default: NULL)", "z_fd", 1, "<path>" },
+    { 915, "z_ratio", "Stop torrent after seeding to ratio (Default: do not stop)", "z_r", 1, "<float>" },
+    { 916, "z_msglevel", "Set log-verbosity (Default: show errors)", "z_msg", 1, "<int>" },
     { 0, NULL, NULL, NULL, 0, NULL }
 };
 
@@ -200,6 +212,158 @@
     }
 }
 
+/***
+
+ Moves all files from one torrent to a new dir and handles everything so torrent can continue in new dir
+
+ params: torrent to change, dir to move files to, old download dir
+ return: # of moved files/dirs or -1 if not moved anything
+
+ 1) torrent is stopped
+ 2) files are moved
+ 3) new downloaddir is set
+ 4) torrent ist started again
+
+***/
+
+typedef enum
+{
+    Z_ACTION_START_TORRENT,
+    Z_ACTION_PAUSE_TORRENT,
+    Z_ACTION_CLOSE_TORRENT,
+    Z_ACTION_REMOVE_TORRENT
+}
+z_torrent_action;
+
+// following is only to prevent compiler warning
+// at some point in the future this could be put into a header if necessary
+int
+z_moveTorrentFiles( tr_torrent *, char *, char *, z_torrent_action );
+
+int
+z_moveTorrentFiles( tr_torrent * tor, char * newdir_p, char * olddir_p, z_torrent_action autostart )
+{
+
+    char olddir[MAX_PATH_LENGTH];
+    char newdir[MAX_PATH_LENGTH];
+    int moved = 0;
+    int notmoved = 0;
+    const tr_info * i = tr_torrentInfo( tor );
+    tr_file_index_t fi;
+
+    if( tor == NULL )
+        return -1;
+
+    if( newdir_p == NULL || newdir_p[0] == '\0' )
+        return -1;
+    else
+        strcpy( newdir, newdir_p );
+
+    if( olddir_p == NULL || olddir_p[0] == '\0' )
+        strcpy( olddir, tr_torrentGetDownloadDir( tor ) );
+    else
+        strcpy( olddir, olddir_p );
+
+    // strip last delemiter because rename() cannot handle multiple delimiters
+    if( *( strchr( olddir, '\0') - 1 ) == TR_PATH_DELIMITER )
+        *( strchr( olddir, '\0') - 1 ) = '\0';
+
+    if( *( strchr( newdir, '\0') - 1 ) == TR_PATH_DELIMITER )
+        *( strchr( newdir, '\0') - 1 ) = '\0';
+
+    // no action if both dirs are the same
+    if( strcmp( olddir, newdir ) == 0 )
+        return -1;
+
+    tr_torrentStop( tor );
+
+    for( fi = 0; fi < i->fileCount; fi++ ) {
+
+        char * oldlocation = NULL;
+        char * newlocation = NULL;
+        char * delim = strchr( i->files[fi].name, TR_PATH_DELIMITER );
+
+        if( !delim ) { // only a file
+
+            oldlocation = tr_buildPath( olddir, i->files[fi].name, NULL );
+            newlocation = tr_buildPath( newdir, i->files[fi].name, NULL );
+
+        } else { // at least one path
+
+            char path[MAX_PATH_LENGTH];
+            path[0] = '\0';
+            strcpy( path, i->files[fi].name );
+            path[delim - i->files[fi].name] = '\0';
+
+            oldlocation = tr_buildPath( olddir, path, NULL );
+            newlocation = tr_buildPath( newdir, path, NULL );
+
+         }
+
+         // now check whether file exists, since it could be moved already (if it's a file in a folder)
+         // also check there is no file already
+         // this check should be splitted and in case of an error the reason should be printed
+         if( access( oldlocation, R_OK ) == 0 && access( newlocation, F_OK ) != 0 ) {
+
+            if( rename( oldlocation, newlocation ) == 0 ) {
+
+                tr_dbg( "moved file %s to %s", oldlocation, newlocation );
+                moved++;
+
+            } else if( errno == EXDEV ) { // cross-device moves not working (old kernel?) - try system-command
+
+                char buf[2*MAX_PATH_LENGTH+8];
+                buf[0] = '\0';
+
+                tr_dbg( "cross-device rename failed, trying system-command: %s", buf );
+
+                if( snprintf( buf, sizeof(buf), "mv \"%s\" \"%s\"", oldlocation, newlocation ) == -1 )
+                    tr_dbg( "writing system command into buffer failed: %s", strerror( errno ) );
+                else
+                    if( system( buf ) == 0 )
+                        moved++;
+                   else
+                        tr_dbg( "system-command returned non-zero value, move possibly failed" );
+
+            } else { // rename() failed because of another reason than cross-device-error
+
+                tr_dbg( "renaming file %s to %s failed, error: %s", oldlocation, newlocation, strerror( errno ) );
+
+            }
+
+        } else {
+
+            tr_dbg( "either file %s exists or file %s not found", newlocation, oldlocation );
+            notmoved++;
+
+        }
+
+        tr_free( oldlocation );
+        tr_free( newlocation );
+
+    }
+
+    if( moved > 0 ) { // it should be checked whether all files moved correctly
+
+        tr_dbg( "Changing downloaddir from %s to %s\n", olddir, newdir );
+        tr_torrentSetDownloadDir( tor, newdir );
+
+        if( autostart == Z_ACTION_START_TORRENT )
+            tr_torrentStart( tor );
+        else if( autostart == Z_ACTION_CLOSE_TORRENT )
+            tr_torrentFree( tor );
+        else if( autostart == Z_ACTION_REMOVE_TORRENT )
+            tr_torrentRemove( tor );
+
+        return moved;
+
+    }
+
+    return -1;
+
+}
+
+
 int
 main( int argc, char ** argv )
 {
@@ -288,6 +452,14 @@
             case 'r':
                       tr_bencDictAddStr( &settings, TR_PREFS_KEY_RPC_BIND_ADDRESS, optarg );
                       break;
+            case 913: strncpy( z_seedPath, optarg, sizeof( z_seedPath ) );
+                      break;
+            case 914: strncpy( z_finishPath, optarg, sizeof( z_finishPath ) );
+                      break;
+            case 915: z_ratio = atof( optarg );
+                      break;
+            case 916: tr_bencDictAddInt( &settings, TR_PREFS_KEY_MSGLEVEL, atoi( optarg ) );
+                      break;
             default:  showUsage( );
                       break;
         }
@@ -339,10 +507,70 @@
         tr_ctorFree( ctor );
     }
 
-    while( !closing )
-    {
-        tr_wait( 1000 ); /* sleep one second */
-        dtr_watchdir_update( watchdir );
+    // be sure our paths have no delemiter at the end
+    if( strlen( z_seedPath ) > 0 && *( strchr( z_seedPath, '\0') - 1 ) == TR_PATH_DELIMITER )
+        *( strchr( z_seedPath, '\0') - 1 ) = '\0';
+
+    if( strlen( z_finishPath ) > 0 && *( strchr( z_finishPath, '\0') - 1 ) == TR_PATH_DELIMITER )
+        *( strchr( z_finishPath, '\0') - 1 ) = '\0';
+
+    while( !closing ) {
+
+        tr_wait( 5000 ); /* sleep some seconds */
+        dtr_watchdir_update( watchdir );
+
+        /* move seeding torrents to seeding-dir */
+        if( strlen( z_seedPath ) > 0 && access( z_seedPath, W_OK ) == 0 ) {
+
+            static tr_torrent * tor;
+            for( tor = tr_torrentNext( mySession, NULL ); tor != NULL; tor = tr_torrentNext( mySession, tor ) ) {
+
+                if( tr_torrentGetActivity( tor ) & TR_STATUS_SEED ) {
+
+                    const char * downloadDir;
+                    char fdownloadDir[MAX_PATH_LENGTH];
+
+                    downloadDir = tr_torrentGetDownloadDir( tor );
+                    strcpy( fdownloadDir, downloadDir );
+
+                    // strip last delemiter in order to compare both dirs correctly
+                    if( *( strchr( fdownloadDir, '\0') - 1 ) == TR_PATH_DELIMITER )
+                        *( strchr( fdownloadDir, '\0') - 1 ) = '\0';
+
+                    if( strcmp( fdownloadDir, z_seedPath ) != 0 ) {
+
+                        z_moveTorrentFiles( tor, z_seedPath, fdownloadDir, Z_ACTION_START_TORRENT );
+
+                    }
+
+                }
+
+            }
+
+        }/* move seeding torrents to seeding-dir */
+
+        /* check ratio and stop if reached, move files to new finish-dir if set */
+        if( z_ratio > 0 ) {
+
+            static tr_torrent * tor;
+            for( tor = tr_torrentNext( mySession, NULL ); tor != NULL; tor = tr_torrentNext( mySession, tor ) ) {
+
+                static const tr_stat * s;
+                s = tr_torrentStatCached( tor );
+
+                if( ( tr_torrentGetActivity( tor ) & TR_STATUS_SEED ) && ( s->ratio == TR_RATIO_INF || s->ratio > z_ratio ) ) {
+
+                  tr_torrentStop( tor );
+
+                  if( strlen( z_finishPath ) > 0 && access( z_finishPath, W_OK ) == 0 )
+                      z_moveTorrentFiles( tor, z_finishPath, NULL, Z_ACTION_PAUSE_TORRENT );
+
+                }
+
+            }
+
+        }/* check ratio and stop if reached */
+
     }
 
     /* shutdown */
