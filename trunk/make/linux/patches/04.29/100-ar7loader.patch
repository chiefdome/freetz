diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/gzip.h linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/gzip.h
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/gzip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/gzip.h	2006-07-02 14:50:30.000000000 +0200
@@ -0,0 +1,51 @@
+//bvb#include "timemmap.h"
+
+#define OF(args)  args
+#define STATIC static
+
+#define WSIZE 0x8000		/* Slideing window size (defined as var
+				 * "window" below) must be at least 32k, 
+				 * and a power of two.  This is the
+				 * data work window used for input buffer
+				 * by the input routine */
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+
+static char *output_data;
+static ulg output_ptr;
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define NOMEMCPY                /* Does routine memcpy exist? */
+
+//bvb static uch *inbuf;		/* input buffer */
+static uch *window;
+
+//bvb static uch outwin[WSIZE];
+
+//bvb static unsigned insize;		/* valid bytes in inbuf */
+static unsigned inptr;		/* index of next byte to process in inbuf */
+
+static unsigned outcnt;		/* bytes in output buffer */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
+#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+#define RESERVED     0xC0 /* bit 6,7:   reserved */
+
+/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
+#define BMAX 16         /* maximum bit length of any code (16 for explode) */
+#define N_MAX 288       /* maximum number of codes in any set */
+
+static char *input_data;
+
+static void *freememstart;
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/ld.script.in linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/ld.script.in
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/ld.script.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/ld.script.in	2006-11-12 23:11:23.000000000 +0100
@@ -0,0 +1,34 @@
+	OUTPUT_FORMAT("@@OUTPUT_FORMAT@@")
+	OUTPUT_ARCH(mips)
+ENTRY(tikernelunzip)
+	SECTIONS
+{
+
+	/* Allocate memory space on top of kernel bss space */
+	. = 0x94400000;
+	.text :
+	{
+		*(.text)
+		*(.rodata)
+		*(.rodata1)
+		*(.gnu.warning)
+		*(.text.init)
+		*(.data.init)
+	}                    
+
+	.data :
+	{
+		*(*)
+	}
+
+	.bss :
+	{
+		*(.dynbss)
+		*(COMMON)
+		*(.bss)
+		*(.sbss)
+		*(.scommon)
+		. = ALIGN (0x8000);
+		workspace = .;
+	}
+}
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/loader.c linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/loader.c
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/loader.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/loader.c	2006-11-12 01:36:10.000000000 +0100
@@ -0,0 +1,133 @@
+/* inflate.c -- Not copyrighted 1992 by Mark Adler
+   version c10p1, 10 January 1993 */
+
+/*
+ * Adapted for booting Linux by Hannu Savolainen 1993
+ * based on gzip-1.0.3
+ *
+ * Nicolas Pitre <nico@visuaide.com>, 1999/04/14 :
+ *   Little mods for all variable to reside either into rodata or bss segments
+ *   by marking constant variables with 'const' and initializing all the others
+ *   at run-time only.  This allows for the kernel uncompressor to run
+ *   directly from Flash or ROM memory on embeded systems.
+ */
+
+/* #include <linux/config.h> */
+#include "gzip.h"
+#include "LzmaDecode.h"
+
+/* Function prototypes */
+unsigned char get_byte(void);
+int tikernelunzip(int,char *[], char *[]);
+static int tidecompress(uch *, uch *);
+
+void kernel_entry(int, char *[], char *[]);
+void (*ke)(int, char *[], char *[]); /* Gen reference to kernel function */
+void (*prnt)(unsigned int, char *);		/* Gen reference to Yamon print function */
+void printf(char *ptr);			/* Generate our own printf */
+
+int tikernelunzip(int argc, char *argv[], char *arge[])
+{
+	extern unsigned int _text;
+	extern uch kernelimage[];
+	uch *in, *out;
+	int status;
+
+	printf("Launching kernel decompressor.\n");
+	out = (unsigned char *) LOADADDR;
+	in = &(kernelimage[0]);
+	status = tidecompress(in, out);
+	if (status == 0) {
+		printf("Kernel decompressor was successful ... launching kernel.\n");
+
+		ke = ( void(*)(int, char *[],char*[]))kernel_entry;
+		(*ke)(argc,argv,arge);
+		return (0);
+	} else {
+		printf("Error in decompression.\n");
+		return(1);
+	}
+}
+
+#if 0
+char hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+void print_i(int i)
+{
+	int j;
+	char buf[11];
+
+	buf[0] = '0';
+	buf[1] = 'x';
+	buf[10] = 0;
+	
+	for (j = 0; j < 8; j++)
+	{
+		buf[2 + 7 - j] = hex[i & 0xf];
+		i = i >> 4;
+	}
+
+	printf(buf);
+}
+#endif
+
+int tidecompress(uch *indata, uch *outdata)
+{
+	extern unsigned int workspace;
+	extern unsigned char kernelimage[], kernelimage_end[];
+	unsigned int i;  /* temp value */
+	unsigned int lc; /* literal context bits */
+	unsigned int lp; /* literal pos state bits */
+	unsigned int pb; /* pos state bits */
+	unsigned int osize; /* uncompressed size */
+	unsigned int wsize; /* window size */
+	unsigned int insize = kernelimage_end - kernelimage;
+	int status;
+	output_ptr = 0;
+	output_data = outdata;
+	input_data = indata;
+
+	/* lzma args */
+	i = get_byte();
+	lc = i % 9, i = i / 9;
+	lp = i % 5, pb = i / 5;
+
+	/* skip rest of the LZMA coder property */
+	for (i = 0; i < 4; i++)
+		get_byte();
+	
+	/* read the lower half of uncompressed size in the header */
+	osize = ((unsigned int)get_byte()) +
+		((unsigned int)get_byte() << 8) +
+		((unsigned int)get_byte() << 16) +
+		((unsigned int)get_byte() << 24);
+
+	/* skip rest of the header (upper half of uncompressed size) */
+	for (i = 0; i < 4; i++)
+		get_byte();
+	
+	i = 0;
+	wsize = (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp))) * sizeof(CProb);
+	if ((status = LzmaDecode((unsigned char *) &workspace, wsize, lc, lp, pb,
+		indata + 13, insize - 13, (unsigned char *) output_data, osize, &i)) == LZMA_RESULT_OK)
+			return 0;
+	return status;
+}
+
+
+void printf(char *ptr)
+{
+	unsigned int *tempptr = (unsigned int  *)0x90000534;
+	prnt = ( void (*)(unsigned int, char *)) *tempptr;
+	(*prnt)(0,ptr);
+}
+
+unsigned char get_byte()
+{
+	unsigned char c;
+	
+	c = *input_data;
+	input_data++;
+
+	return c;
+}
+
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/LzmaDecode.c linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/LzmaDecode.c
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/LzmaDecode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/LzmaDecode.c	2006-07-02 14:50:30.000000000 +0200
@@ -0,0 +1,663 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder
+  
+  LZMA SDK 4.05 Copyright (c) 1999-2004 Igor Pavlov (2004-08-25)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+typedef struct _CRangeDecoder
+{
+  Byte *Buffer;
+  Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+  #ifdef _LZMA_IN_CB
+  ILzmaInCallback *InCallback;
+  int Result;
+  #endif
+  int ExtraBytes;
+} CRangeDecoder;
+
+Byte RangeDecoderReadByte(CRangeDecoder *rd)
+{
+  if (rd->Buffer == rd->BufferLim)
+  {
+    #ifdef _LZMA_IN_CB
+    UInt32 size;
+    rd->Result = rd->InCallback->Read(rd->InCallback, &rd->Buffer, &size);
+    rd->BufferLim = rd->Buffer + size;
+    if (size == 0)
+    #endif
+    {
+      rd->ExtraBytes = 1;
+      return 0xFF;
+    }
+  }
+  return (*rd->Buffer++);
+}
+
+/* #define ReadByte (*rd->Buffer++) */
+#define ReadByte (RangeDecoderReadByte(rd))
+
+void RangeDecoderInit(CRangeDecoder *rd,
+  #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback
+  #else
+    Byte *stream, UInt32 bufferSize
+  #endif
+    )
+{
+  int i;
+  #ifdef _LZMA_IN_CB
+  rd->InCallback = inCallback;
+  rd->Buffer = rd->BufferLim = 0;
+  #else
+  rd->Buffer = stream;
+  rd->BufferLim = stream + bufferSize;
+  #endif
+  rd->ExtraBytes = 0;
+  rd->Code = 0;
+  rd->Range = (0xFFFFFFFF);
+  for(i = 0; i < 5; i++)
+    rd->Code = (rd->Code << 8) | ReadByte;
+}
+
+#define RC_INIT_VAR UInt32 range = rd->Range; UInt32 code = rd->Code;        
+#define RC_FLUSH_VAR rd->Range = range; rd->Code = code;
+#define RC_NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | ReadByte; }
+
+UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+{
+  RC_INIT_VAR
+  UInt32 result = 0;
+  int i;
+  for (i = numTotalBits; i > 0; i--)
+  {
+    /* UInt32 t; */
+    range >>= 1;
+
+    result <<= 1;
+    if (code >= range)
+    {
+      code -= range;
+      result |= 1;
+    }
+    /*
+    t = (code - range) >> 31;
+    t &= 1;
+    code -= range & (t - 1);
+    result = (result + result) | (1 - t);
+    */
+    RC_NORMALIZE
+  }
+  RC_FLUSH_VAR
+  return result;
+}
+
+int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+{
+  UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
+  if (rd->Code < bound)
+  {
+    rd->Range = bound;
+    *prob += (kBitModelTotal - *prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 0;
+  }
+  else
+  {
+    rd->Range -= bound;
+    rd->Code -= bound;
+    *prob -= (*prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 1;
+  }
+}
+
+#define RC_GET_BIT2(prob, mi, A0, A1) \
+  UInt32 bound = (range >> kNumBitModelTotalBits) * *prob; \
+  if (code < bound) \
+    { A0; range = bound; *prob += (kBitModelTotal - *prob) >> kNumMoveBits; mi <<= 1; } \
+  else \
+    { A1; range -= bound; code -= bound; *prob -= (*prob) >> kNumMoveBits; mi = (mi + mi) + 1; } \
+  RC_NORMALIZE
+
+#define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
+
+int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = numLevels; i > 0; i--)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT(prob, mi)
+    #else
+    mi = (mi + mi) + RangeDecoderBitDecode(probs + mi, rd);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return mi - (1 << numLevels);
+}
+
+int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  int symbol = 0;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = 0; i < numLevels; i++)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT2(prob, mi, ; , symbol |= (1 << i))
+    #else
+    int bit = RangeDecoderBitDecode(probs + mi, rd);
+    mi = mi + mi + bit;
+    symbol |= (bit << i);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + symbol;
+    RC_GET_BIT(prob, symbol)
+    #else
+    symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+    #endif
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    int bit;
+    int matchBit = (matchByte >> 7) & 1;
+    matchByte <<= 1;
+    #ifdef _LZMA_LOC_OPT
+    {
+      CProb *prob = probs + ((1 + matchBit) << 8) + symbol;
+      RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
+    }
+    #else
+    bit = RangeDecoderBitDecode(probs + ((1 + matchBit) << 8) + symbol, rd);
+    symbol = (symbol << 1) | bit;
+    #endif
+    if (matchBit != bit)
+    {
+      while (symbol < 0x100)
+      {
+        #ifdef _LZMA_LOC_OPT
+        CProb *prob = probs + symbol;
+        RC_GET_BIT(prob, symbol)
+        #else
+        symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+        #endif
+      }
+      break;
+    }
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+{
+  if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
+    return RangeDecoderBitTreeDecode(p + LenLow +
+        (posState << kLenNumLowBits), kLenNumLowBits, rd);
+  if(RangeDecoderBitDecode(p + LenChoice2, rd) == 0)
+    return kLenNumLowSymbols + RangeDecoderBitTreeDecode(p + LenMid +
+        (posState << kLenNumMidBits), kLenNumMidBits, rd);
+  return kLenNumLowSymbols + kLenNumMidSymbols + 
+      RangeDecoderBitTreeDecode(p + LenHigh, kLenNumHighBits, rd);
+}
+
+#define kNumStates 12
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+#ifdef _LZMA_OUT_READ
+
+typedef struct _LzmaVarState
+{
+  CRangeDecoder RangeDecoder;
+  Byte *Dictionary;
+  UInt32 DictionarySize;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 Reps[4];
+  int lc;
+  int lp;
+  int pb;
+  int State;
+  int PreviousIsMatch;
+  int RemainLen;
+} LzmaVarState;
+
+int LzmaDecoderInit(
+    unsigned char *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    unsigned char *dictionary, UInt32 dictionarySize,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback
+    #else
+    unsigned char *inStream, UInt32 inSize
+    #endif
+    )
+{
+  LzmaVarState *vs = (LzmaVarState *)buffer;
+  CProb *p = (CProb *)(buffer + sizeof(LzmaVarState));
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + lp));
+  UInt32 i;
+  if (bufferSize < numProbs * sizeof(CProb) + sizeof(LzmaVarState))
+    return LZMA_RESULT_NOT_ENOUGH_MEM;
+  vs->Dictionary = dictionary;
+  vs->DictionarySize = dictionarySize;
+  vs->DictionaryPos = 0;
+  vs->GlobalPos = 0;
+  vs->Reps[0] = vs->Reps[1] = vs->Reps[2] = vs->Reps[3] = 1;
+  vs->lc = lc;
+  vs->lp = lp;
+  vs->pb = pb;
+  vs->State = 0;
+  vs->PreviousIsMatch = 0;
+  vs->RemainLen = 0;
+  dictionary[dictionarySize - 1] = 0;
+  for (i = 0; i < numProbs; i++)
+    p[i] = kBitModelTotal >> 1; 
+  RangeDecoderInit(&vs->RangeDecoder, 
+      #ifdef _LZMA_IN_CB
+      inCallback
+      #else
+      inStream, inSize
+      #endif
+  );
+  return LZMA_RESULT_OK;
+}
+
+int LzmaDecode(unsigned char *buffer, 
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed)
+{
+  LzmaVarState *vs = (LzmaVarState *)buffer;
+  CProb *p = (CProb *)(buffer + sizeof(LzmaVarState));
+  CRangeDecoder rd = vs->RangeDecoder;
+  int state = vs->State;
+  int previousIsMatch = vs->PreviousIsMatch;
+  Byte previousByte;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  UInt32 nowPos = 0;
+  UInt32 posStateMask = (1 << (vs->pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->lp)) - 1;
+  int lc = vs->lc;
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  if (len == -1)
+  {
+    *outSizeProcessed = 0;
+    return LZMA_RESULT_OK;
+  }
+
+  while(len > 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+#else
+
+int LzmaDecode(
+    Byte *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    unsigned char *inStream, UInt32 inSize,
+    #endif
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + lp));
+  CProb *p = (CProb *)buffer;
+  CRangeDecoder rd;
+  UInt32 i;
+  int state = 0;
+  int previousIsMatch = 0;
+  Byte previousByte = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  UInt32 nowPos = 0;
+  UInt32 posStateMask = (1 << pb) - 1;
+  UInt32 literalPosMask = (1 << lp) - 1;
+  int len = 0;
+  if (bufferSize < numProbs * sizeof(CProb))
+    return LZMA_RESULT_NOT_ENOUGH_MEM;
+  for (i = 0; i < numProbs; i++)
+    p[i] = kBitModelTotal >> 1; 
+  RangeDecoderInit(&rd, 
+      #ifdef _LZMA_IN_CB
+      inCallback
+      #else
+      inStream, inSize
+      #endif
+      );
+#endif
+
+  *outSizeProcessed = 0;
+  while(nowPos < outSize)
+  {
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+    #ifdef _LZMA_IN_CB
+    if (rd.Result != LZMA_RESULT_OK)
+      return rd.Result;
+    #endif
+    if (rd.ExtraBytes != 0)
+      return LZMA_RESULT_DATA_ERROR;
+    if (RangeDecoderBitDecode(p + IsMatch + (state << kNumPosBitsMax) + posState, &rd) == 0)
+    {
+      CProb *probs = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+      if (previousIsMatch)
+      {
+        Byte matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        previousByte = LzmaLiteralDecodeMatch(probs, &rd, matchByte);
+        previousIsMatch = 0;
+      }
+      else
+        previousByte = LzmaLiteralDecode(probs, &rd);
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+    }
+    else             
+    {
+      previousIsMatch = 1;
+      if (RangeDecoderBitDecode(p + IsRep + state, &rd) == 1)
+      {
+        if (RangeDecoderBitDecode(p + IsRepG0 + state, &rd) == 0)
+        {
+          if (RangeDecoderBitDecode(p + IsRep0Long + (state << kNumPosBitsMax) + posState, &rd) == 0)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            if (
+               (nowPos 
+                #ifdef _LZMA_OUT_READ
+                + globalPos
+                #endif
+               )
+               == 0)
+              return LZMA_RESULT_DATA_ERROR;
+            state = state < 7 ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            continue;
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          if(RangeDecoderBitDecode(p + IsRepG1 + state, &rd) == 0)
+            distance = rep1;
+          else 
+          {
+            if(RangeDecoderBitDecode(p + IsRepG2 + state, &rd) == 0)
+              distance = rep2;
+            else
+            {
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        len = LzmaLenDecode(p + RepLenCoder, &rd, posState);
+        state = state < 7 ? 8 : 11;
+      }
+      else
+      {
+        int posSlot;
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < 7 ? 7 : 10;
+        len = LzmaLenDecode(p + LenCoder, &rd, posState);
+        posSlot = RangeDecoderBitTreeDecode(p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits), kNumPosSlotBits, &rd);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = ((2 | ((UInt32)posSlot & 1)) << numDirectBits);
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 += RangeDecoderReverseBitTreeDecode(
+                p + SpecPos + rep0 - posSlot - 1, numDirectBits, &rd);
+          }
+          else
+          {
+            rep0 += RangeDecoderDecodeDirectBits(&rd, 
+                numDirectBits - kNumAlignBits) << kNumAlignBits;
+            rep0 += RangeDecoderReverseBitTreeDecode(p + Align, kNumAlignBits, &rd);
+          }
+        }
+        else
+          rep0 = posSlot;
+        rep0++;
+      }
+      if (rep0 == (UInt32)(0))
+      {
+        /* it's for stream version */
+        len = -1;
+        break;
+      }
+      if (rep0 > nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+      {
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      len += kMatchMinLen;
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        outStream[nowPos++] = previousByte;
+        len--;
+      }
+      while(len > 0 && nowPos < outSize);
+    }
+  }
+
+  #ifdef _LZMA_OUT_READ
+  vs->RangeDecoder = rd;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + nowPos;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->PreviousIsMatch = previousIsMatch;
+  vs->RemainLen = len;
+  #endif
+
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/LzmaDecode.h linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/LzmaDecode.h
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/LzmaDecode.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/LzmaDecode.h	2006-07-02 14:50:30.000000000 +0200
@@ -0,0 +1,100 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.05 Copyright (c) 1999-2004 Igor Pavlov (2004-08-25)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb unsigned short
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+#define LZMA_RESULT_NOT_ENOUGH_MEM 2
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, unsigned char **buffer, UInt32 *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+/* 
+bufferSize = (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp)))* sizeof(CProb)
+bufferSize += 100 in case of _LZMA_OUT_READ
+by default CProb is unsigned short, 
+but if specify _LZMA_PROB_32, CProb will be UInt32(unsigned int)
+*/
+
+#ifdef _LZMA_OUT_READ
+int LzmaDecoderInit(
+    unsigned char *buffer, UInt32 bufferSize,
+    int lc, int lp, int pb,
+    unsigned char *dictionary, UInt32 dictionarySize,
+  #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback
+  #else
+    unsigned char *inStream, UInt32 inSize
+  #endif
+);
+#endif
+
+int LzmaDecode(
+    unsigned char *buffer, 
+  #ifndef _LZMA_OUT_READ
+    UInt32 bufferSize,
+    int lc, int lp, int pb,
+  #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+  #else
+    unsigned char *inStream, UInt32 inSize,
+  #endif
+  #endif
+    unsigned char *outStream, UInt32 outSize,
+    UInt32 *outSizeProcessed);
+
+#endif
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/Makefile linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/Makefile
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/Makefile	2006-11-13 15:45:44.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# File intended to be called from top level Makefile during kernel build if compressed
+# image for ohio is requested.
+#
+
+LOADADDR := 0x94000000
+#LOADADDR := 0x${shell nm $(TOPDIR)/vmlinux | grep _text | cut -d' ' -fl}
+KERNELENTRY := 0x$(shell nm $(TOPDIR)/vmlinux | grep kernel_entry | cut -d' ' -f1)
+LOCALLINKFLAGS= -static -G 0 --defsym kernel_entry=$(KERNELENTRY) -Map inflate.map
+CFLAGS += -DLOADADDR=$(LOADADDR)
+output-format	= elf32-tradlittlemips
+OBJ_FILES	= loader.o LzmaDecode.o
+INFLATE_DEP	= loader.c LzmaDecode.h
+ZIMAGE_XZ	= zimage.lzma
+
+# Image depends=====================================
+ram_zimage:	$(OBJ_FILES) zimage.o Makefile ld.script
+	$(LD) $(LOCALLINKFLAGS) -no-warn-mismatch -T ld.script $(OBJ_FILES) zimage.o -o inflate
+	$(NM) inflate | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aU] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > ram_zimage.map
+	$(OBJCOPY) -O srec inflate $(TOPDIR)/ram_zimage.sre
+
+# File depends======================================
+loader.o:	$(INFLATE_DEP) Makefile
+
+LzmaDecode.o:	LzmaDecode.c LzmaDecode.h
+
+zimage.o:	$(ZIMAGE_XZ) zimage.script Makefile
+	$(CROSS_COMPILE)ld -T zimage.script -r -b binary $(ZIMAGE_XZ) -o zimage.o
+
+zimage.lzma: Makefile $(TOPDIR)/vmlinux
+	$(CROSS_COMPILE)objcopy -S -O binary $(TOPDIR)/vmlinux zimage
+	if [ -x ../../../../../../../../../../../tools/lzma ]; then \
+		cat zimage | ../../../../../../../../../../../tools/lzma e -si -so -eos -lc1 -lp2 -pb2 > zimage.lzma; \
+	else	\
+		cat zimage | lzma e -si -so -eos -lc1 -lp2 -pb2 > zimage.lzma; \
+	fi
+
+ld.script:	ld.script.in Makefile
+	sed -e 's/@@OUTPUT_FORMAT@@/$(output-format)/' \
+	    -e 's/@@LOADADDR@@/$(LOADADDR)/' <$< >$@
+
+zimage.script:	zimage.script.in Makefile
+	sed -e 's/@@OUTPUT_FORMAT@@/$(output-format)/' \
+	    -e 's/@@LOADADDR@@/$(LOADADDR)/' <$< >$@
+
+clean:	
+	rm -f $(OBJ_FILES) $(ZIMAGE_XZ) inflate inflate.src System.map zimage.o ld.script zimage.script ram_zimage.map
\ Kein Zeilenumbruch am Dateiende.
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/srec2bin.c linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/srec2bin.c
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/srec2bin.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/srec2bin.c	2006-07-02 14:50:30.000000000 +0200
@@ -0,0 +1,523 @@
+#include <stdio.h>
+#include <ctype.h>
+
+//Rev 0.1 Original
+// 8 Jan 2001  MJH  Added code to write data to Binary file
+//                  note: outputfile is name.bin, where name is first part
+//                  of input file.  ie tmp.rec -> tmp.bin
+//
+//   srec2bin <input SREC file> <Output Binary File> <If Present, Big Endian>
+//
+//   TAG   
+//        bit32u TAG_BIG     = 0xDEADBE42;
+//        bit32u TAG_LITTLE  = 0xFEEDFA42;
+//
+//  File Structure
+//
+//  TAG    :   32 Bits
+//  [DATA RECORDS]
+//
+//  Data Records Structure
+//
+//  LENGTH  :  32 Bits    <- Length of DATA, excludes ADDRESS and CHECKSUM
+//  ADDRESS :  32 Bits
+//  DATA    :  8 Bits * LENGTH
+//  CHECKSUM:  32 Bits    <-  0 - (Sum of Length --> End of Data)
+//
+//  Note : If Length == 0, Address will be Program Start
+//
+//
+//  
+//
+//
+
+#define MajRevNum 0
+#define MinRevNum 2
+
+
+#define EndianSwitch(x) ((x >> 24) | (x << 24) | ((x << 8) & (0x00FF0000)) | ((x >> 8) & (0x0000FF00)) )
+
+typedef unsigned char bit8u;
+typedef unsigned int bit32u;
+typedef int bit32;
+
+#define FALSE 0
+#define TRUE (!FALSE)
+
+
+bit32u CheckSum;
+int RecStart;
+int debug;
+int verbose;
+
+FILE *OpenOutputFile( char *Name );
+FILE *fOut;
+bit32u RecLength=0;
+
+bit32u AddressCurrent;
+
+bit32u gh(char *cp,int nibs);
+
+int BigEndian;
+
+int inputline;
+
+// char buf[16*1024];
+
+char buffer[2048];
+char *cur_ptr;
+int cur_line=0;
+int cur_len=0;
+
+int s1s2s3_total=0;
+
+bit32u PBVal;
+int    PBValid;
+bit32u PBAdr;
+
+
+void dumpfTell(char *s, bit32u Value)
+{
+    int Length;
+    Length = (int) RecLength;
+    if (debug)
+          printf("[%s  ] ftell()[0x%08lX] Length[0x%4X] Length[%4d] Value[0x%08x]\n",
+                s, ftell(fOut), Length, Length, Value);
+}
+
+void DispHex(bit32u Hex)
+{
+//    printf("%X", Hex);
+}
+
+void WaitDisplay(void)
+{
+   static int Count=0;
+   static int Index=0;
+   char iline[]={"-\\|/"};
+
+   Count++;
+   if ((Count % 32)==0)
+   {
+     if (verbose)
+        printf("%c%c",iline[Index++],8);
+     Index &= 3;
+   }
+}
+
+
+void binOut32 ( bit32u Data )
+{
+// On UNIX machine all 32bit writes need ENDIAN switched
+//    Data = EndianSwitch(Data);
+//    fwrite( &Data, sizeof(bit32u), 1, fOut);
+
+   char sdat[4];
+   int i;
+
+   for(i=0;i<4;i++)
+    sdat[i]=(char)(Data>>(i*8));
+   fwrite( sdat, 1, 4, fOut);
+   dumpfTell("Out32" , Data);
+}
+
+// Only update RecLength on Byte Writes
+// All 32 bit writes will be for Length etc
+
+void binOut8 ( bit8u Data )
+{
+    int n;
+    dumpfTell("B4Data" , (bit32u) (Data & 0xFF) );
+    n = fwrite( &Data, sizeof(bit8u), 1, fOut);
+    if (n != 1)
+        printf("Error in writing %X for Address 0x%8X\n", Data, AddressCurrent);
+    RecLength += 1;
+}
+
+//  Currently ONLY used for outputting Program Start
+
+void binRecStart(bit32u Address)
+{
+    RecLength      = 0;
+    CheckSum       = Address;
+    RecStart       = TRUE;
+
+    if (debug)
+          printf("[RecStart] CheckSum[0x%08X] Length[%4d] Address[0x%08X]\n",
+                CheckSum, RecLength, Address);
+
+
+    dumpfTell("RecLength", RecLength);
+    binOut32( RecLength );
+    dumpfTell("Address", Address);
+    binOut32( Address );
+}
+
+void binRecEnd(void)
+{
+    long RecEnd;
+
+    if (!RecStart)   //  if no record started, do not end it
+    {
+        return;
+    }
+
+    RecStart = FALSE;
+
+
+    RecEnd = ftell(fOut);         // Save Current position
+
+    if (debug)
+          printf("[RecEnd  ] CheckSum[0x%08X] Length[%4d] Length[0x%X] RecEnd[0x%08lX]\n",
+                CheckSum, RecLength, RecLength, RecEnd);
+
+    fseek( fOut, -((long) RecLength), SEEK_CUR);  // move back Start Of Data
+
+    dumpfTell("Data   ", -1);
+
+    fseek( fOut, -4, SEEK_CUR);  // move back Start Of Address
+
+    dumpfTell("Address   ", -1);
+
+    fseek( fOut, -4, SEEK_CUR);  // move back Start Of Length
+
+    dumpfTell("Length   ", -1);
+
+    binOut32( RecLength );
+
+    fseek( fOut, RecEnd, SEEK_SET);  // move to end of Record
+
+    CheckSum += RecLength;
+
+    CheckSum =  ~CheckSum + 1;  // Two's complement
+
+    binOut32( CheckSum );
+
+    if (verbose)
+        printf("[Created Record of %d Bytes with CheckSum [0x%8X]\n", RecLength, CheckSum);
+}
+
+void binRecOutProgramStart(bit32u Address)
+{
+    if (Address != (AddressCurrent+1))
+    {
+        binRecEnd();
+        binRecStart(Address);
+    }
+    AddressCurrent = Address;
+}
+void binRecOutByte(bit32u Address, bit8u Data)
+{
+    //  If Address is one after Current Address, output Byte
+    //  If not, close out last record, update Length, write checksum
+    //  Then Start New Record, updating Current Address
+
+    if (Address != (AddressCurrent+1))
+    {
+        binRecEnd();
+        binRecStart(Address);
+    }
+    AddressCurrent = Address;
+    CheckSum += Data;
+    binOut8( Data );
+}
+
+//=============================================================================
+//       SUPPORT FUNCTIONS
+//=============================================================================
+int readline(FILE *fil,char *buf,int len)
+{
+    int rlen;
+    
+    rlen=0;
+    if (len==0)  return(0);
+    while(1)
+    {
+      if (cur_len==0)
+      {
+        cur_len=fread(buffer, 1, sizeof(buffer), fil);
+        if (cur_len==0)
+        {
+          if (rlen)
+          {
+            *buf=0;
+            return(rlen);
+          }
+          return(-1);
+        }
+        cur_ptr=buffer;
+      }
+      if (cur_len)
+      {
+        if (*cur_ptr=='\n')
+        {
+          *buf=0;
+          cur_ptr++;
+          cur_len--;
+          return(rlen);
+        }
+         else
+         {
+           if ((len>1)&&(*cur_ptr!='\r'))
+           {
+             *buf++=*cur_ptr++;
+             len--;
+           }
+           else
+             cur_ptr++;
+
+           rlen++;
+           cur_len--;
+         }
+      }
+      else
+      {
+        *buf=0;
+        cur_ptr++;
+        cur_len--;
+        return(rlen);
+      }
+    }
+}
+
+
+int SRLerrorout(char *c1,char *c2)
+{
+  printf("\nERROR: %s - '%s'.",c1,c2);
+  return(FALSE);
+}
+
+
+int checksum(char *cp,int count)
+{
+  char *scp;
+  int cksum;
+  int dum;
+
+  scp=cp;
+  while(*scp)
+  {
+    if (!isxdigit(*scp++))
+      return(SRLerrorout("Invalid hex digits",cp));
+  }
+  scp=cp;
+
+  cksum=count;
+
+  while(count)
+  {
+    cksum += gh(scp,2);
+    if (count == 2)
+        dum = ~cksum;
+    scp += 2;
+    count--;
+  }
+  cksum&=0x0ff; 
+  //  printf("\nCk:%02x",cksum);
+  return(cksum==0x0ff);
+}
+
+bit32u gh(char *cp,int nibs)
+{
+  int i;
+  bit32u j;
+
+  j=0;
+
+  for(i=0;i<nibs;i++)
+  {
+    j<<=4;
+    if ((*cp>='a')&&(*cp<='z')) *cp &= 0x5f;
+    if ((*cp>='0')&&(*cp<='9')) 
+      j += (*cp-0x30);
+     else
+      if ((*cp>='A')&&(*cp<='F'))
+        j += (*cp-0x37);
+       else
+        SRLerrorout("Bad Hex char", cp);
+    cp++;
+  }
+  return(j);
+}
+
+
+//=============================================================================
+//       PROCESS SREC LINE
+//=============================================================================
+
+int srecLine(char *pSrecLine)
+{
+    char *scp,ch;
+    int  itmp,count,dat;
+    bit32u adr;
+    static bit32u RecordCounter=0;
+
+    cur_line++;
+    scp=pSrecLine;
+  
+    if (*pSrecLine!='S')
+      return(SRLerrorout("Not an Srecord file",scp));
+    pSrecLine++;
+    if (strlen(pSrecLine)<4)
+      return(SRLerrorout("Srecord too short",scp));
+  
+    ch=*pSrecLine++;
+  
+    count=gh(pSrecLine,2);
+  
+    pSrecLine += 2;
+  
+  //  if(debug)
+  //        printf("count %d, strlen(pSrecLine) = %d, pSrecLine =[%s]\n", count, strlen(pSrecLine), pSrecLine);
+     RecordCounter++;
+     DispHex(RecordCounter);
+  
+    if ((count*2) != strlen(pSrecLine)) return(SRLerrorout("Count field larger than record",scp));
+  
+    if (!checksum(pSrecLine, count)) return(SRLerrorout("Bad Checksum",scp));
+  
+    switch(ch)
+    {
+        case '0': if (count<3) return(SRLerrorout("Invalid Srecord count field",scp));
+                  itmp=gh(pSrecLine,4); pSrecLine+=4; count-=2;
+                  if (itmp) return(SRLerrorout("Srecord 1 address not zero",scp));
+        break;
+        case '1': if (count<3) return(SRLerrorout("Invalid Srecord count field",scp));
+                  return(SRLerrorout("Srecord Not valid for MIPS",scp));
+        break;
+        case '2': if (count<4) return(SRLerrorout("Invalid Srecord count field",scp));
+                  return(SRLerrorout("Srecord Not valid for MIPS",scp));
+        break;
+        case '3': if (count<5) return(SRLerrorout("Invalid Srecord count field",scp));
+                  adr=gh(pSrecLine,8); pSrecLine+=8; count-=4;
+                  count--;
+                  while(count)
+                  {
+                    dat=gh(pSrecLine,2); pSrecLine+=2; count--;
+                    binRecOutByte(adr, (char) (dat & 0xFF));
+                    adr++;
+                  }
+                  s1s2s3_total++;
+        break;
+        case '4': return(SRLerrorout("Invalid Srecord type",scp));
+        break;
+        case '5': if (count<3) return(SRLerrorout("Invalid Srecord count field",scp));
+                  itmp=gh(pSrecLine,4); pSrecLine+=4; count-=2;
+                  if (itmp|=s1s2s3_total) return(SRLerrorout("Incorrect number of S3 Record processed",scp));
+        break;
+        case '6': return(SRLerrorout("Invalid Srecord type",scp));
+        break;
+        case '7': // PROGRAM START
+                  if (count<5) return(SRLerrorout("Invalid Srecord count field",scp));
+                  adr=gh(pSrecLine,8); pSrecLine+=8; count-=4;
+                  if (count!=1) return(SRLerrorout("Invalid Srecord count field",scp));
+                  binRecOutProgramStart(adr);
+        break;
+        case '8': if (count<4) return(SRLerrorout("Invalid Srecord count field",scp));
+                  return(SRLerrorout("Srecord Not valid for MIPS",scp));
+        break;
+        case '9': if (count<3) return(SRLerrorout("Invalid Srecord count field",scp));
+                  return(SRLerrorout("Srecord Not valid for MIPS",scp));
+        break;
+        default:
+        break;
+    }
+    return(TRUE);
+}
+ 
+
+//=============================================================================
+//       MAIN LOGIC, READS IN LINE AND OUTPUTS BINARY
+//=============================================================================
+
+int srec2bin(int argc,char *argv[],int verbose)
+{
+    int i,rlen,sts;
+    FILE *fp;
+    char ac;
+    char buff[256];
+    bit32u TAG_BIG     = 0xDEADBE42;
+    bit32u TAG_LITTLE  = 0xFEEDFA42;
+
+    bit32u Tag;
+
+  
+    if(argc < 3)
+    {
+      printf("\nError: <srec2bin <srec input file> <bin output file>\n\n");
+      return(0);
+    }
+  
+    if (argc > 3) BigEndian=TRUE; else BigEndian=FALSE;
+
+    if (BigEndian)
+        Tag = TAG_BIG;
+    else
+        Tag = TAG_LITTLE;
+
+    if (verbose)
+       printf("\nEndian: %s, Tag is 0x%8X\n",(BigEndian)?"BIG":"LITTLE", Tag);
+
+    fp = fopen(argv[1],"rt");
+
+    if (fp==NULL)
+    {
+      printf("\nError: Opening input file, %s.", argv[1]);
+      return(0);
+    }
+  
+    fOut = fopen( argv[2], "wb");
+    
+    if (fOut==NULL)
+    {
+      printf("\nError: Opening Output file, %s.", argv[2]);
+      if(fp) fclose(fp);
+      return(0);
+    }
+ 
+    RecStart = FALSE;
+
+    AddressCurrent = 0xFFFFFFFFL;
+
+    // Setup Tag 
+  
+    dumpfTell("Tag", Tag);
+
+    binOut32(Tag);
+
+  
+    inputline=0;
+    sts=TRUE;
+
+    rlen = readline(fp,buff,sizeof buff);
+
+    while( (sts) && (rlen != -1))
+    {
+        if (strlen(buff))
+        {
+            sts &= srecLine(buff);
+            WaitDisplay();
+        }
+       rlen = readline(fp,buff,sizeof buff);
+    }
+
+  
+  //  printf("PC: 0x%08X, Length 0x%08X, Tag 0x%08X\n", ProgramStart, RecLength, TAG_LITTLE);
+  
+    binRecEnd();
+
+    if(fp) fclose(fp);
+    if(fOut) fclose(fOut);
+
+    return(1);
+}
+
+main(int argc, char *argv[])
+{
+    debug = TRUE;
+    debug = FALSE;
+    verbose = FALSE;
+    srec2bin(argc,argv,verbose);
+    return 0;
+}
+
diff -burN linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/zimage.script.in linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/zimage.script.in
--- linux-2.6.13.1.orig/arch/mips/mips-boards/ohio/inflater/zimage.script.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/arch/mips/mips-boards/ohio/inflater/zimage.script.in	2006-07-02 14:50:30.000000000 +0200
@@ -0,0 +1,11 @@
+	OUTPUT_FORMAT("@@OUTPUT_FORMAT@@")
+OUTPUT_ARCH(mips)
+	SECTIONS
+{
+	.data :
+	{
+		kernelimage = .;
+		*(.data)
+		kernelimage_end = .;
+	}
+}
diff -burN linux-2.6.13.1.orig/Makefile linux-2.6.13.1/Makefile
--- linux-2.6.13.1.orig/Makefile	2006-09-30 23:14:09.000000000 +0200
+++ linux-2.6.13.1/Makefile	2006-11-13 15:50:24.000000000 +0100
@@ -504,6 +504,21 @@
 # Defaults vmlinux but it is usually overriden in the arch makefile
 all: vmlinux
 
+INTEL_GCC	= gcc
+DD		= dd
+DD_BS           =  64k
+SREC2BIN	= $(TOPDIR)/srec2bin
+
+ram_zimage:	vmlinux srec2bin
+	$(MAKE) ram_zimage -C arch/$(ARCH)/mips-boards/ohio/inflater
+	$(SREC2BIN) ram_zimage.sre ram_zimage.bin
+
+ram_zimage_pad: ram_zimage
+	$(DD) if=ram_zimage.bin of=ram_zimage_pad.bin bs=$(DD_BS) conv=sync
+
+srec2bin: 
+	$(HOSTCC) -o srec2bin arch/$(ARCH)/mips-boards/ohio/inflater/srec2bin.c
+
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 CFLAGS		+= -Os
 else
@@ -533,6 +548,9 @@
 NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 
+# improve gcc optimization
+CFLAGS += $(call cc-option,-funit-at-a-time,)
+
 # warn about C99 declaration after statement
 CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
@@ -949,7 +967,8 @@
 # Directories & files removed with 'make clean'
 CLEAN_DIRS  += $(MODVERDIR)
 CLEAN_FILES +=	vmlinux System.map \
-                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map
+                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map \
+		ram_zimage* srec2bin
 
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config include2
