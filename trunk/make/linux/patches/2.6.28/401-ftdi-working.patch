--- linux-2.6.28/drivers/usb/serial/ftdi_sio.c	2011-08-21 19:24:43.044719000 +0200
+++ linux-2.6.28/drivers/usb/serial/ftdi_sio.c	2011-08-21 21:32:20.096189000 +0200
@@ -49,7 +49,7 @@
  */
 #define DRIVER_VERSION "v1.4.3"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>, Kuba Ober <kuba@mareimbrium.org>"
-#define DRIVER_DESC "USB FTDI Serial Converters Driver"
+#define DRIVER_DESC "USB FTDI Serial Converters Driver [Mod by http://www.aaf-digital.info]"
 
 static int debug;
 static __u16 vendor = FTDI_VID;
@@ -845,7 +845,7 @@
 							unsigned int clear)
 {
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char *buf;
+	unsigned char *buf;
 	unsigned urb_value;
 	int rv;
 
@@ -854,7 +854,7 @@
 		return 0;	/* no change */
 	}
 
-	buf = kmalloc(1, GFP_NOIO);
+	buf = kzalloc (2, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -1011,13 +1011,13 @@
 static int change_speed(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char *buf;
+	unsigned char *buf;
 	__u16 urb_value;
 	__u16 urb_index;
 	__u32 urb_index_value;
 	int rv;
 
-	buf = kmalloc(1, GFP_NOIO);
+	buf = kzalloc (1, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -1214,7 +1214,9 @@
 	struct usb_serial_port *port = to_usb_serial_port(dev);
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	struct usb_device *udev = port->serial->dev;
-	char buf[1];
+	unsigned char *buf;
+
+	buf = kzalloc (2, GFP_KERNEL);
 	int v = simple_strtoul(valbuf, NULL, 10);
 	int rv = 0;
 
@@ -1243,7 +1245,8 @@
 	struct usb_serial_port *port = to_usb_serial_port(dev);
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	struct usb_device *udev = port->serial->dev;
-	char buf[1];
+	unsigned char *buf;
+	buf = kzalloc (2, GFP_KERNEL);
 	int v = simple_strtoul(valbuf, NULL, 10);
 	int rv = 0;
 
@@ -1260,7 +1263,7 @@
 		dbg("Unable to write event character: %i", rv);
 		return -EIO;
 	}
-
+	kfree(buf);
 	return count;
 }
 
@@ -1490,9 +1493,11 @@
 	struct usb_device *dev = port->serial->dev;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
-
+	unsigned char *buf;
 	int result = 0;
-	char buf[1]; /* Needed for the usb_control_msg I think */
+
+
+	buf = kzalloc (2, GFP_KERNEL);
 
 	dbg("%s", __func__);
 
@@ -1512,7 +1517,7 @@
 			FTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE,
 			FTDI_SIO_RESET_SIO,
 			priv->interface, buf, 0, WDR_TIMEOUT);
-
+	kfree (buf);
 	/* Termios defaults are set by usb_serial_init. We don't change
 	   port->tty->termios - this would lose speed settings, etc.
 	   This is same behaviour as serial.c/rs_open() - Kuba */
@@ -1563,8 +1568,8 @@
 { /* ftdi_close */
 	unsigned int c_cflag = tty->termios->c_cflag;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	char buf[1];
-
+	char *buf;
+	buf = kzalloc (2, GFP_KERNEL);
 	dbg("%s", __func__);
 
 	mutex_lock(&port->serial->disc_mutex);
@@ -1583,7 +1588,7 @@
 		clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);
 	} /* Note change no line if hupcl is off */
 	mutex_unlock(&port->serial->disc_mutex);
-
+	kfree(buf);
 	/* cancel any scheduled reading */
 	cancel_delayed_work(&priv->rx_work);
 	flush_scheduled_work();
@@ -2078,8 +2083,8 @@
 	struct usb_serial_port *port = tty->driver_data;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
 	__u16 urb_value = 0;
-	char buf[1];
-
+	unsigned char *buf;
+	buf = kzalloc (2, GFP_KERNEL);
 	/* break_state = -1 to turn on break, and 0 to turn off break */
 	/* see drivers/char/tty_io.c to see it used */
 	/* last_set_data_urb_value NEVER has the break bit set in it */
@@ -2118,13 +2123,13 @@
 	struct ktermios *termios = tty->termios;
 	unsigned int cflag = termios->c_cflag;
 	__u16 urb_value; /* will hold the new flags */
-	char buf[1]; /* Perhaps I should dynamically alloc this? */
+	unsigned char *buf;
 
 	/* Added for xon/xoff support */
 	unsigned int iflag = termios->c_iflag;
 	unsigned char vstop;
 	unsigned char vstart;
-
+	buf = kzalloc (2, GFP_KERNEL);
 	dbg("%s", __func__);
 
 	/* Force baud rate if this device requires it, unless it is set to
@@ -2271,6 +2276,7 @@
 		}
 
 	}
+	kfree(buf);
 	return;
 }
 
@@ -2278,9 +2284,11 @@
 {
 	struct usb_serial_port *port = tty->driver_data;
 	struct ftdi_private *priv = usb_get_serial_port_data(port);
-	unsigned char buf[2];
+	unsigned char *buf;
 	int ret;
+	int r1;
 
+	buf = kzalloc (3, GFP_KERNEL);
 	dbg("%s TIOCMGET", __func__);
 	switch (priv->chip_type) {
 	case SIO:
@@ -2319,13 +2327,16 @@
 	default:
 		return -EFAULT;
 		break;
-	}
-
-	return  (buf[0] & FTDI_SIO_DSR_MASK ? TIOCM_DSR : 0) |
+	} 
+ 
+	r1 =  (buf[0] & FTDI_SIO_DSR_MASK ? TIOCM_DSR : 0) |
 		(buf[0] & FTDI_SIO_CTS_MASK ? TIOCM_CTS : 0) |
 		(buf[0]  & FTDI_SIO_RI_MASK  ? TIOCM_RI  : 0) |
 		(buf[0]  & FTDI_SIO_RLSD_MASK ? TIOCM_CD  : 0) |
 		priv->last_dtr_rts;
+
+	kfree(buf);
+	return(r1);		
 }
 
 static int ftdi_tiocmset(struct tty_struct *tty, struct file *file,
