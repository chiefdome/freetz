--- linux-2.6.13.1/drivers/net/Kconfig.orig	2007-03-09 10:15:40.000000000 +0100
+++ linux-2.6.13.1/drivers/net/Kconfig	2007-07-28 12:44:49.000000000 +0200
@@ -2512,6 +2512,32 @@
 	  module; it is called bsd_comp and will show up in the directory
 	  modules once you have said "make modules". If unsure, say N.
 
+config PPP_MPPE_MPPC
+	tristate "Microsoft PPP compression/encryption (MPPC/MPPE)"
+	depends on PPP
+	select CRYPTO_SHA1
+	select CRYPTO_ARC4
+	---help---
+	  Support for the Microsoft Point-To-Point Compression (RFC2118) and 
+	  Microsoft Point-To-Point Encryption (RFC3078). These protocols are
+	  supported by Microsoft Windows and wide range of "hardware" access
+	  servers. MPPE is common protocol in Virtual Private Networks. According
+	  to RFC3078, MPPE supports 40, 56 and 128-bit key lengths. Depending on
+	  PPP daemon configuration on both ends of the link, following scenarios
+	  are possible:
+		- only compression (MPPC) is used,
+		- only encryption (MPPE) is used,
+		- compression and encryption (MPPC+MPPE) are used.
+
+	  Please note that Hi/Fn (http://www.hifn.com) holds patent on MPPC so
+	  you should check if this patent is valid in your country in order to
+	  avoid legal problems.
+
+	  For more information please visit http://mppe-mppc.alphacron.de
+
+	  To compile this driver as a module, choose M here. The module will
+	  be called ppp_mppe_mppc.ko.
+
 config PPPOE
 	tristate "PPP over Ethernet (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && PPP
--- linux-2.6.13.1/drivers/net/Makefile.orig	2006-09-29 17:43:16.000000000 +0200
+++ linux-2.6.13.1/drivers/net/Makefile	2007-07-28 12:44:49.000000000 +0200
@@ -109,6 +109,7 @@
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
 obj-$(CONFIG_PPP_DEFLATE) += ppp_deflate.o
 obj-$(CONFIG_PPP_BSDCOMP) += bsd_comp.o
+obj-$(CONFIG_PPP_MPPE_MPPC) += ppp_mppe_mppc.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 
 obj-$(CONFIG_SLIP) += slip.o
--- linux-2.6.13.1/drivers/net/ppp_generic.c.orig	2005-09-14 12:22:35.000000000 +0200
+++ linux-2.6.13.1/drivers/net/ppp_generic.c	2007-07-28 12:44:49.000000000 +0200
@@ -19,7 +19,7 @@
  * PPP driver, written by Michael Callahan and Al Longyear, and
  * subsequently hacked by Paul Mackerras.
  *
- * ==FILEVERSION 20041108==
+ * ==FILEVERSION 20050110==
  */
 
 #include <linux/config.h>
@@ -105,6 +105,7 @@
 	spinlock_t	rlock;		/* lock for receive side 58 */
 	spinlock_t	wlock;		/* lock for transmit side 5c */
 	int		mru;		/* max receive unit 60 */
+	int		mru_alloc;	/* MAX(1500,MRU) for dev_alloc_skb() */
 	unsigned int	flags;		/* control bits 64 */
 	unsigned int	xstate;		/* transmit state bits 68 */
 	unsigned int	rstate;		/* receive state bits 6c */
@@ -632,7 +633,9 @@
 	case PPPIOCSMRU:
 		if (get_user(val, p))
 			break;
-		ppp->mru = val;
+		ppp->mru_alloc = ppp->mru = val;
+		if (ppp->mru_alloc < PPP_MRU)
+		    ppp->mru_alloc = PPP_MRU;	/* increase for broken peers */
 		err = 0;
 		break;
 
@@ -1107,14 +1110,37 @@
 	case PPP_CCP:
 		/* peek at outbound CCP frames */
 		ppp_ccp_peek(ppp, skb, 0);
+		/*
+		 * When LZS or MPPE/MPPC has been negotiated we don't send
+		 * CCP_RESETACK after receiving CCP_RESETREQ; in fact pppd
+		 * sends such a packet but we silently discard it here
+		 */
+		if (CCP_CODE(skb->data+2) == CCP_RESETACK
+		    && (ppp->xcomp->compress_proto == CI_MPPE
+			|| ppp->xcomp->compress_proto == CI_LZS)) {
+		    --ppp->stats.tx_packets;
+		    ppp->stats.tx_bytes -= skb->len - 2;
+		    kfree_skb(skb);
+		    return;
+		}
 		break;
 	}
 
 	/* try to do packet compression */
 	if ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state != 0
 	    && proto != PPP_LCP && proto != PPP_CCP) {
-		new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len,
-				    GFP_ATOMIC);
+		int comp_ovhd = 0;
+		/* 
+		 * because of possible data expansion when MPPC or LZS
+		 * is used, allocate compressor's buffer 12.5% bigger
+		 * than MTU
+		 */
+		if (ppp->xcomp->compress_proto == CI_MPPE)
+		    comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + MPPE_OVHD;
+		else if (ppp->xcomp->compress_proto == CI_LZS)
+		    comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + LZS_OVHD;
+		new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len
+				    + comp_ovhd, GFP_ATOMIC);
 		if (new_skb == 0) {
 			printk(KERN_ERR "PPP: no memory (comp pkt)\n");
 			goto drop;
@@ -1132,9 +1158,21 @@
 			skb = new_skb;
 			skb_put(skb, len);
 			skb_pull(skb, 2);	/* pull off A/C bytes */
-		} else {
+		} else if (len == 0) {
 			/* didn't compress, or CCP not up yet */
 			kfree_skb(new_skb);
+		} else {
+			/*
+			 * (len < 0)
+			 * MPPE requires that we do not send unencrypted
+			 * frames.  The compressor will return -1 if we
+			 * should drop the frame.  We cannot simply test
+			 * the compress_proto because MPPE and MPPC share
+			 * the same number.
+			 */
+			printk(KERN_ERR "ppp: compressor dropped pkt\n");
+			kfree_skb(new_skb);
+			goto drop;
 		}
 	}
 
@@ -1683,14 +1721,15 @@
 		goto err;
 
 	if (proto == PPP_COMP) {
-		ns = dev_alloc_skb(ppp->mru + PPP_HDRLEN);
+		ns = dev_alloc_skb(ppp->mru_alloc + PPP_HDRLEN);
 		if (ns == 0) {
 			printk(KERN_ERR "ppp_decompress_frame: no memory\n");
 			goto err;
 		}
 		/* the decompressor still expects the A/C bytes in the hdr */
 		len = ppp->rcomp->decompress(ppp->rc_state, skb->data - 2,
-				skb->len + 2, ns->data, ppp->mru + PPP_HDRLEN);
+				skb->len + 2, ns->data,
+				ppp->mru_alloc + PPP_HDRLEN);
 		if (len < 0) {
 			/* Pass the compressed frame to pppd as an
 			   error indication. */
@@ -1716,7 +1755,14 @@
 	return skb;
 
  err:
-	ppp->rstate |= SC_DC_ERROR;
+	if (ppp->rcomp->compress_proto != CI_MPPE
+	    && ppp->rcomp->compress_proto != CI_LZS) {
+	    /*
+	     * If decompression protocol isn't MPPE/MPPC or LZS, we set
+	     * SC_DC_ERROR flag and wait for CCP_RESETACK
+	     */
+	    ppp->rstate |= SC_DC_ERROR;
+	}
 	ppp_receive_error(ppp);
 	return skb;
 }
@@ -2392,6 +2438,7 @@
 	memset(ppp, 0, sizeof(struct ppp));
 
 	ppp->mru = PPP_MRU;
+	ppp->mru_alloc = PPP_MRU;
 	init_ppp_file(&ppp->file, INTERFACE);
 	ppp->file.hdrlen = PPP_HDRLEN - 2;	/* don't count proto bytes */
 	for (i = 0; i < NUM_NP; ++i)
--- linux-2.6.13.1/include/linux/ppp-comp.h.orig	2005-09-14 12:22:35.000000000 +0200
+++ linux-2.6.13.1/include/linux/ppp-comp.h	2007-07-28 12:44:49.000000000 +0200
@@ -28,7 +28,7 @@
  */
 
 /*
- *  ==FILEVERSION 980319==
+ *  ==FILEVERSION 20040509==
  *
  *  NOTE TO MAINTAINERS:
  *     If you modify this file at all, please set the above date.
@@ -80,7 +80,7 @@
 
 	/* Compress a packet */
 	int     (*compress) (void *state, unsigned char *rptr,
-			      unsigned char *obuf, int isize, int osize);
+			     unsigned char *obuf, int isize, int osize);
 
 	/* Return compression statistics */
 	void	(*comp_stat) (void *state, struct compstat *stats);
@@ -101,7 +101,7 @@
 
 	/* Decompress a packet. */
 	int	(*decompress) (void *state, unsigned char *ibuf, int isize,
-				unsigned char *obuf, int osize);
+			       unsigned char *obuf, int osize);
 
 	/* Update state for an incompressible packet received */
 	void	(*incomp) (void *state, unsigned char *ibuf, int icnt);
@@ -191,6 +191,42 @@
 #define DEFLATE_CHK_SEQUENCE	0
 
 /*
+ * Definitions for MPPE/MPPC.
+ */
+
+#define CI_MPPE			18	/* config option for MPPE */
+#define CILEN_MPPE		6	/* length of config option */
+
+#define MPPE_OVHD		4	/* MPPE overhead */
+#define MPPE_MAX_KEY_LEN	16	/* largest key length (128-bit) */
+
+#define MPPE_STATELESS          0x01	/* configuration bit H */
+#define MPPE_40BIT              0x20	/* configuration bit L */
+#define MPPE_56BIT              0x80	/* configuration bit M */
+#define MPPE_128BIT             0x40	/* configuration bit S */
+#define MPPE_MPPC               0x01	/* configuration bit C */
+
+/*
+ * Definitions for Stac LZS.
+ */
+
+#define CI_LZS			17	/* config option for Stac LZS */
+#define CILEN_LZS		5	/* length of config option */
+
+#define LZS_OVHD		4	/* max. LZS overhead */
+#define LZS_HIST_LEN		2048	/* LZS history size */
+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
+
+#define LZS_MODE_NONE		0
+#define LZS_MODE_LCB		1
+#define LZS_MODE_CRC		2
+#define LZS_MODE_SEQ		3
+#define LZS_MODE_EXT		4
+
+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
+
+/*
  * Definitions for other, as yet unsupported, compression methods.
  */
 
