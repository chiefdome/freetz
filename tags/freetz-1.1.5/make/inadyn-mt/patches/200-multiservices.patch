diff -bruN src/dyndns.c src/dyndns.c
--- src/dyndns.c	2008-07-30 13:11:55.000000000 +0200
+++ src/dyndns.c	2008-09-03 15:54:02.000000000 +0200
@@ -46,6 +46,7 @@
           service_main.h, debug_service.h.  Changed  inadyn_cmd.c, 
         - get_cmd.c, os_windows.c, main.c.
 */
+
 #define MODULE_TAG      "INADYN: "  
 
 #include <stdlib.h>
@@ -63,6 +64,7 @@
 
 #ifdef _WIN32
 
+#include <process.h>
 #include "debug_service.h"
 #include "unicode_util.h"
 
@@ -76,25 +78,43 @@
 
 #endif
 
+
 /* DNS systems specific configurations*/
 
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dynamic = {"dyndns"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
+/*NOTE:	The multiple systems implementation requires at a --dyndns_system parameter -- otherwise, the corresponding
+		parameter handler isn't called, and that's where 'info_count' is incremented -- if it's not incremented, and
+		therefore 0, all updates iterations failed, no dns updates.  
+
+		TODO:  fix this.
+
+		And, we have no wildcard support -- inadyn to inadyn-prgrmroties -- that is, only inadyn-advanced supported
+		wildcards.
+
+		Also, does not address file ip caching as in inadyn-advanced -- see do_update_alias_table -- the file
+		caching is not in inadyn, and hence, not in inadyn-prgrmroties -- the merging just brought in the FILE
+		variable declaration, but not the implementation that followed in inadyn-advanced.  This problem is in:
+
+		static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self)
+*/
+
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt,  int alcnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+
 
 DYNDNS_SYSTEM_INFO dns_system_table[] = 
 { 
@@ -267,7 +287,7 @@
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {	
 
 	int bytes_stored=0;
@@ -276,98 +296,104 @@
     DYNDNS_ORG_SPECIFIC_DATA *p_dyndns_specific = 
 		(DYNDNS_ORG_SPECIFIC_DATA*) p_sys_info->p_specific_data;	
 
-	memset(p_self->p_req_buffer,0,DYNDNS_HTTP_RESPONSE_BUFFER_SIZE);
-
-
-	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-
-
-		p_self->info.dyndns_server_url,
+	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
 		p_dyndns_specific->p_system,
-		p_self->alias_info.names[cnt].name,
-		p_self->info.my_ip_address.name,
-                p_self->wildcard ? "ON" : "OFF",
-		p_self->alias_info.names[cnt].name,
-        p_self->info.dyndns_server_name.name,
-		p_self->info.credentials.p_enc_usr_passwd_buffer
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].my_ip_address.name,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer
 		);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-		p_self->info.dyndns_server_url,
-		p_self->alias_info.hashes[cnt].str,
-        p_self->info.dyndns_server_name.name);
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].hashes.str,
+		p_self->info[infcnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-		p_self->info.dyndns_server_url,		
-		p_self->alias_info.names[cnt].name,
-        p_self->info.credentials.p_enc_usr_passwd_buffer,
-		p_self->info.dyndns_server_name.name);
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer,
+		p_self->info[infcnt].dyndns_server_name.name);
 }
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-		p_self->info.dyndns_server_url,		
-		p_self->alias_info.names[cnt].name,
-		p_self->info.my_ip_address.name,
-        p_self->info.credentials.p_enc_usr_passwd_buffer,
-		p_self->info.dyndns_server_name.name		
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].my_ip_address.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer,
+		p_self->info[infcnt].dyndns_server_name.name
 		);
 }
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt,  int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-		p_self->info.dyndns_server_url,		
-		p_self->alias_info.names[cnt].name,
-		p_self->info.my_ip_address.name,
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,		
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].my_ip_address.name,
                 p_self->wildcard ? "ON" : "OFF",
-        p_self->info.credentials.p_enc_usr_passwd_buffer,
-		p_self->info.dyndns_server_name.name		
+        p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer,
+		p_self->info[infcnt].dyndns_server_name.name		
 		);
 }
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-		p_self->info.dyndns_server_url,	
-		p_self->info.credentials.my_username,
-		p_self->info.credentials.my_password,
-		p_self->alias_info.names[cnt].name,
-		p_self->info.dyndns_server_name.name		
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,	
+		p_self->info[infcnt].credentials.my_username,
+		p_self->info[infcnt].credentials.my_password,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].dyndns_server_name.name		
 		);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, int infcnt, void *p_specific_data)
 {
     return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-        p_self->info.ip_server_name.name, p_self->info.ip_server_url);
+        p_self->info[infcnt].ip_server_name.name, p_self->info[infcnt].ip_server_name.port, p_self->info[infcnt].ip_server_url);
 }
 
 /* 
 	Send req to IP server and get the response
 */
-static RC_TYPE do_ip_server_transaction(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_ip_server_transaction(DYN_DNS_CLIENT *p_self, int servernum)
 {
 	RC_TYPE rc = RC_OK;
 	HTTP_CLIENT *p_http;
 
-	p_http = &p_self->http_to_ip_server;
+	p_http = &p_self->http_to_ip_server[servernum];
 
-	rc = http_client_init(&p_self->http_to_ip_server);
+	rc = http_client_init(p_http);
 	if (rc != RC_OK)
 	{
 		return rc;
@@ -380,7 +406,8 @@
 			HTTP_TRANSACTION *p_tr = &p_self->http_tr;
 
             p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-                                                     p_self->info.p_dns_system->p_specific_data);
+				servernum,
+				p_self->info[servernum].p_dns_system->p_specific_data);
 			if (p_self->dbg.level > 2) 
 			{
 				DBG_PRINTF((LOG_DEBUG,"The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -390,14 +417,14 @@
 			p_tr->max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
 			p_tr->rsp_len = 0;
 
-			rc = http_client_transaction(&p_self->http_to_ip_server, &p_self->http_tr);		
+			rc = http_client_transaction(p_http, &p_self->http_tr);		
 			p_self->p_work_buffer[p_tr->rsp_len] = 0;
 		}
 	}
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(p_http);
 	
 	return rc;
 }
@@ -409,10 +436,10 @@
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different 
 */
-static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self, int servernum)
 {
 	int ip1 = 0, ip2 = 0, ip3 = 0, ip4 = 0;
-	int count;
+	int count, i;
 	char *p_ip;
 	char *p_current_str = p_self->http_tr.p_rsp;
 	BOOL found;
@@ -455,9 +482,14 @@
 
 	if (found)
 	{        
+		i = 0;
+		do
+		{
         sprintf(new_ip_str, DYNDNS_IP_ADDR_FORMAT, ip1, ip2, ip3, ip4);
-        p_self->info.my_ip_has_changed = (strcmp(new_ip_str, p_self->info.my_ip_address.name) != 0);
-		strcpy(p_self->info.my_ip_address.name, new_ip_str);
+			p_self->info[i].my_ip_has_changed = (strcmp(new_ip_str, p_self->info[i].my_ip_address.name) != 0);
+			strcpy(p_self->info[i].my_ip_address.name, new_ip_str);
+		}
+		while(++i < p_self->info_count);
 		return RC_OK;
 	}
 	else
@@ -477,22 +509,28 @@
 */
 static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
 {
-	int		i;
+	int i, j;
 	int		time_slept=p_self->times_since_last_update * p_self->sleep_sec - ((int)
 						((p_self->time_sleep_lost_ms / 1000)));
 
 
-    if (p_self->info.my_ip_has_changed ||
+	/*uses fix test if ip of server 0 has changed */
+	/*that should be ok even if changes dyn_dns_update_ip to */
+	/*iterate over servernum, but not if it's fix set to =! 0 */
+	if (p_self->info[0].my_ip_has_changed ||
         p_self->force_addr_update || (time_slept >= p_self->forced_update_period_sec)
        )
     {
-        for (i = 0; i < p_self->alias_info.count; ++i)
+		for (i = 0; i < p_self->info_count; i++)
+	    {
+			for (j = 0; j < p_self->info[i].alias_count; j++)
 	    {
-            p_self->alias_info.update_required[i] = TRUE;
+				p_self->info[i].alias_info[j].update_required = TRUE;
 			{
 				DBG_PRINTF((LOG_WARNING,"I:" MODULE_TAG "IP address for alias '%s' needs update to '%s'\n",
-					p_self->alias_info.names[i].name,
-					p_self->info.my_ip_address.name ));
+						p_self->info[i].alias_info[j].names.name,
+						p_self->info[i].my_ip_address.name));
+				}
 			}
         }
     }
@@ -502,7 +540,7 @@
 /* DynDNS org.specific response validator.
     'good' or 'nochange' are the good answers,
 */
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	(void) p_ok_string;
     return ( (strstr(p_rsp, DYNDNS_OK_RESPONSE) != NULL) ||
@@ -514,17 +552,17 @@
     fail blabla and n.n.n.n
     are the good answers. We search our own IP address in response and that's enough.
 */
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	(void) p_ok_string;
-    return (strstr(p_rsp, p_self->info.my_ip_address.name) != NULL);
+    return (strstr(p_rsp, p_self->info[infnr].my_ip_address.name) != NULL);
 }
 
 /** generic http dns server ok parser 
 	parses a given string. If found is ok,
 	Example : 'SUCCESS CODE='
 */
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	if (p_ok_string == NULL)
 	{
@@ -538,7 +576,7 @@
 		CODE=200
 		CODE=707, for duplicated updates
 */
-BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	return 
 	(		
@@ -550,12 +588,12 @@
 /**
 	NOERROR is the OK code here
 */
-BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string)
 {
 	return (strstr(p_rsp, "NOERROR") != NULL);
 }
 
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string)
 {
 
 	return (strstr(p_rsp,"success") != NULL);
@@ -563,20 +601,22 @@
 
 static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self)
 {
-	int i;
+	int i, j;
 	RC_TYPE rc = RC_OK;
 	FILE *fp;
 	
 	do 
 	{			
-		for (i = 0; i < p_self->alias_info.count; ++i)
+		for (i = 0; i < p_self->info_count; i++)
 		{
-			if (p_self->alias_info.update_required[i] != TRUE)
+			for (j = 0; j < p_self->info[i].alias_count; j++)
+		{
+				if (p_self->info[i].alias_info[j].update_required != TRUE)
 			{
 				continue;
 			}	
 			
-			rc = http_client_init(&p_self->http_to_dyndns);
+			rc = http_client_init(&p_self->http_to_dyndns[i]);
 			if (rc != RC_OK)
 			{
 				break;
@@ -585,9 +625,9 @@
 			/*build dyndns transaction*/
 			{
 				HTTP_TRANSACTION http_tr;
-				http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-                        (struct _DYN_DNS_CLIENT*) p_self,i,
-						(struct DYNDNS_SYSTEM*) p_self->info.p_dns_system);
+					http_tr.req_len = p_self->info[i].p_dns_system->p_dns_update_req_func(
+						(struct _DYN_DNS_CLIENT*) p_self, i, j,
+						(struct DYNDNS_SYSTEM*) p_self->info[i].p_dns_system);
 				http_tr.p_req = (char*) p_self->p_req_buffer;
 				http_tr.p_rsp = (char*) p_self->p_work_buffer;
 				http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
@@ -595,7 +635,7 @@
 				p_self->p_work_buffer[http_tr.rsp_len+1] = 0;
 				
 				/*send it*/
-				rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);					
+				rc = http_client_transaction(&p_self->http_to_dyndns[i], &http_tr);					
 
 				if (p_self->dbg.level > 2)
 				{
@@ -606,26 +646,26 @@
 				if (rc == RC_OK)
 				{
 					BOOL update_ok = 
-                        p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self, 
+							p_self->info[i].p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self, 
                             http_tr.p_rsp, 
-							p_self->info.p_dns_system->p_success_string);
+							i,
+							p_self->info[i].p_dns_system->p_success_string);
 					if (update_ok)
 					{
-			                        p_self->alias_info.update_required[i] = FALSE;
+							p_self->info[i].alias_info[j].update_required = FALSE;
 
-						DBG_PRINTF((LOG_WARNING,"I:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n", 
-							p_self->alias_info.names[i].name,
-							p_self->info.my_ip_address.name));                        
+						DBG_PRINTF((LOG_WARNING,"I:" MODULE_TAG "Alias '%s' to IP '%s' updated successful.\n", 
+								p_self->info[i].alias_info[j].names.name,
+								p_self->info[i].my_ip_address.name));                        
 						p_self->times_since_last_update = 0;
 						p_self->time_sleep_lost_ms=0;
 						/*recalc forced update period*/
 						p_self->forced_update_period_sec = p_self->forced_update_period_sec_orig;
 						p_self->forced_update_times = p_self->forced_update_period_sec / p_self->sleep_sec;
-
 #ifndef _WIN32
 						if ((fp=fopen(p_self->ip_cache, "w")))
 						{
-							fprintf(fp,"%s", p_self->info.my_ip_address.name);
+							fprintf(fp,"%s", p_self->info[i].my_ip_address.name);
 							fclose(fp);
 						}
 
@@ -639,10 +679,9 @@
  #ifndef UNICOWS						
 							if ((fp=fopen(p_self->ip_cache, "w")))
 							{
-								fprintf(fp,"%s", p_self->info.my_ip_address.name);
+							fprintf(fp,"%s", p_self->info[i].my_ip_address.name);
 								fclose(fp);
 							}
-
 							if ((fp=fopen(p_self->time_cache, "w")))
 							{
 								fprintf(fp,"%ld", time (NULL));
@@ -687,6 +726,7 @@
 							free(utf_16);
 						}
 #endif
+
 						if (strlen(p_self->external_command) > 0)
 							os_shell_execute(p_self->external_command);
 					}
@@ -705,7 +745,7 @@
 			}
 			
 			{
-				RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+				RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns[i]);
 				if (rc == RC_OK)
 				{
 					rc = rc2;
@@ -717,6 +757,7 @@
 			}
 			os_sleep_ms(1000);
 		}
+		}
 		if (rc != RC_OK)
 		{
 			break;
@@ -733,8 +774,8 @@
 
 	do
 	{
-        p_self->info.p_dns_system = p_self->info.p_dns_system ? p_self->info.p_dns_system: get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-        if (p_self->info.p_dns_system == NULL)
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);	
+		if (p_self->info[0].p_dns_system == NULL)
         {
             rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
             break;
@@ -766,14 +807,13 @@
 	return rc;
 }
 
-
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char *str_uri_encoded,int str_size)
+static RC_TYPE do_get_encoded_user_passwd(DYNDNS_INFO_TYPE *info,char *str_uri_encoded,int str_size)
 {
 	RC_TYPE rc = RC_OK;
 	const char* format = "%s:%s";
 	char *p_tmp_buff = NULL;
-	int size = strlen(p_self->info.credentials.my_password) + 
-			   strlen(p_self->info.credentials.my_username) + 
+	int			size = strlen(info->credentials.my_password) + 
+				strlen(info->credentials.my_username) + 
 			   strlen(format) + 1;
 	int actual_len;
 
@@ -788,8 +828,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format, 
-				p_self->info.credentials.my_username, 
-				p_self->info.credentials.my_password);
+				info->credentials.my_username, 
+				info->credentials.my_password);
 		if (actual_len >= size)
 		{
 			rc = RC_OUT_BUFFER_OVERFLOW;
@@ -800,12 +840,12 @@
 
 		memset(str_uri_encoded,0,str_size);
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = 
+		info->credentials.p_enc_usr_passwd_buffer = 
 			b64encode(utf_8_uri_encoded(str_uri_encoded,p_tmp_buff,"&#",";"));
 
-		p_self->info.credentials.encoded = 
-			(p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		info->credentials.encoded = 
+			(info->credentials.p_enc_usr_passwd_buffer != NULL);
+		info->credentials.size = strlen(info->credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -817,6 +857,26 @@
 	return rc;	
 }
 
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char *str_uri_encoded,int str_size)
+{
+
+	DYNDNS_INFO_TYPE	*p_info=p_self->info;
+	int					i;
+	int					rc=RC_OK;
+
+
+	for (i=0;i<p_self->info_count;i++) {
+
+		rc=do_get_encoded_user_passwd(p_info++,str_uri_encoded,str_size);
+
+		if (!(rc==RC_OK))
+
+			break;
+	}
+
+	return rc;
+}
+
 /*************PUBLIC FUNCTIONS ******************/
 
 /*
@@ -838,6 +898,7 @@
 	DYN_DNS_CLIENT *p_self;
     BOOL http_to_dyndns_constructed = FALSE;
     BOOL http_to_ip_constructed = FALSE;
+	int i;
 
 	if (pp_self == NULL)
 	{
@@ -873,21 +934,28 @@
 			break;
 		}
 		
-        
-		rc = http_client_construct(&p_self->http_to_ip_server);
+		i = 0;		
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			rc = http_client_construct(&p_self->http_to_ip_server[i++]);
 		if (rc != RC_OK)
 		{	
 			rc = RC_OUT_OF_MEMORY;
 			break;
 		}
+		}
         http_to_ip_constructed = TRUE;
 	
-		rc = http_client_construct(&p_self->http_to_dyndns);
+		i = 0;
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			rc = http_client_construct(&p_self->http_to_dyndns[i++]);
 		if (rc != RC_OK)
 		{		
 			rc = RC_OUT_OF_MEMORY;
 			break;
 		}
+		}
         http_to_dyndns_constructed = TRUE;
 	
 		(p_self)->cmd = NO_CMD;
@@ -895,10 +963,11 @@
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;	
 		(p_self)->initialized = FALSE;
 	
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
-		p_self->lang_file = NULL;
-
+		i = 0;		
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			p_self->info[i++].credentials.p_enc_usr_passwd_buffer = NULL;
+		}
 	}
 	while(0);
 
@@ -918,11 +987,11 @@
         }
         if (http_to_dyndns_constructed) 
         {
-            http_client_destruct(&p_self->http_to_dyndns);
+			http_client_destruct(p_self->http_to_dyndns, DYNDNS_MAX_SERVER_NUMBER);
         }
         if (http_to_ip_constructed) 
         {
-            http_client_destruct(&p_self->http_to_ip_server);
+			http_client_destruct(p_self->http_to_ip_server, DYNDNS_MAX_SERVER_NUMBER);
         }            
     }
 
@@ -935,6 +1004,7 @@
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
+	int i;
 	RC_TYPE rc;
 	if (p_self == NULL)
 	{
@@ -946,13 +1016,13 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
+	rc = http_client_destruct(p_self->http_to_ip_server, DYNDNS_MAX_SERVER_NUMBER);
 	if (rc != RC_OK)
 	{		
 		
 	}
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
+	rc = http_client_destruct(p_self->http_to_dyndns, DYNDNS_MAX_SERVER_NUMBER);
 	if (rc != RC_OK)
 	{	
 		
@@ -970,19 +1040,16 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
+	i = 0;		
+	while(i < DYNDNS_MAX_SERVER_NUMBER)
 	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
-
-	if (p_self->lang_file != NULL)
+		if (p_self->info[i].credentials.p_enc_usr_passwd_buffer != NULL)
 	{
-
-		free(p_self->lang_file);
-		p_self->lang_file = NULL;
+			free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
+		}
+		i++;
 	}
-
 
 	free(p_self);
 	p_self = NULL;
@@ -998,6 +1065,8 @@
 */
 RC_TYPE dyn_dns_init(DYN_DNS_CLIENT *p_self)
 {
+	int i = 0;
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
@@ -1011,22 +1080,26 @@
 	p_self->abort_on_network_errors = FALSE;
 	p_self->force_addr_update = FALSE;
 
-    if (strlen(p_self->info.proxy_server_name.name) > 0)
+	do
+    {
+		if (strlen(p_self->info[i].proxy_server_name.name) > 0)
     {
-        http_client_set_port(&p_self->http_to_ip_server, p_self->info.proxy_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_ip_server, p_self->info.proxy_server_name.name);
+			http_client_set_port(&p_self->http_to_ip_server[i], p_self->info[i].proxy_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_ip_server[i], p_self->info[i].proxy_server_name.name);
 
-        http_client_set_port(&p_self->http_to_dyndns, p_self->info.proxy_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_dyndns, p_self->info.proxy_server_name.name);
+			http_client_set_port(&p_self->http_to_dyndns[i], p_self->info[i].proxy_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_dyndns[i], p_self->info[i].proxy_server_name.name);
     }
     else
     {
-        http_client_set_port(&p_self->http_to_ip_server, p_self->info.ip_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_ip_server, p_self->info.ip_server_name.name);
+			http_client_set_port(&p_self->http_to_ip_server[i], p_self->info[i].ip_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_ip_server[i], p_self->info[i].ip_server_name.name);
 
-        http_client_set_port(&p_self->http_to_dyndns, p_self->info.dyndns_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_dyndns, p_self->info.dyndns_server_name.name);    
+			http_client_set_port(&p_self->http_to_dyndns[i], p_self->info[i].dyndns_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_dyndns[i], p_self->info[i].dyndns_server_name.name);    
     }
+    }
+	while(++i < p_self->info_count);
 
 	p_self->cmd = NO_CMD;
     if (p_self->cmd_check_period == 0)
@@ -1083,7 +1156,7 @@
 	}
 }
 
-/*
+/* the real action:
 	- increment the forced update times counter
 	- detect current IP
 		- connect to an HTTP server 
@@ -1103,7 +1176,9 @@
 
 #endif
 {
-	RC_TYPE rc;
+	int servernum = 0; /* server to use for requesting IP */
+                     /*use server 0 by default, should be always exist */
+	RC_TYPE rc = RC_OK;
 	int		net_attempts=1;
 
 
@@ -1124,7 +1199,7 @@
 
 #endif
 			/*ask IP server something so he will respond and give me my IP */
-			rc = do_ip_server_transaction(p_self);
+			rc = do_ip_server_transaction(p_self,servernum);
 
 			if (rc==RC_OK)
 
@@ -1154,7 +1229,7 @@
 		}
 
 		/*extract my IP, check if different than previous one*/
-		rc = do_parse_my_ip_address(p_self);
+		rc = do_parse_my_ip_address(p_self,servernum);
 		if (rc != RC_OK)
 		{	
 			break;
@@ -1162,7 +1237,7 @@
 		
 		if (p_self->dbg.level >= LOG_INFO)
 		{
-			DBG_PRINTF((LOG_INFO,"W:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name));		
+			DBG_PRINTF((LOG_INFO,"W:DYNDNS: My IP address: %s\n", p_self->info[servernum].my_ip_address.name));		
 		}
 
 		/*step through aliases list, resolve them and check if they point to my IP*/
@@ -1177,7 +1252,7 @@
 		while (!(p_self->cmd==CMD_STOP)) {
 
 #else
-		while(!(returnSignaled) && !(p_self->cmd==CMD_STOP) && is_online(p_ras_thread_data,
+		while (!(returnSignaled) && !(p_self->cmd==CMD_STOP) && is_online(p_ras_thread_data,
 				p_self->http_to_ip_server.super.super.p_remote_host_name,p_self->dbg.level)) {
 
 #endif
@@ -1198,12 +1273,11 @@
 
 				DBG_PRINTF((LOG_INFO,"W:DYNDNS: Failed updating alias table... iterating after retry interval...\n"));
 
-
 			sleep_lightly_ms(p_self);
 		}
 
 	}
-	while(0);
+		while (0);
 
 	return rc;
 }
@@ -1290,6 +1364,51 @@
   DWORD              wait_ret=0;
 
 
+  wait_ret=WaitForSingleObject(hUpdateMutex,0);
+
+  if (!(wait_ret==WAIT_OBJECT_0)) {
+
+    if (!(wait_ret==WAIT_TIMEOUT))
+
+      dbg_printf_and_err_str(NULL,"C:" MODULE_TAG "WaitForSingleObject failed in RAS update handler.",GetLastError(),LOG_CRIT,p_dyndns->dbg.level);
+
+  }
+  else {
+
+
+    update_ret=do_attempt_update(p_dyndns,p_ras_thread_data);
+
+
+    if (update_ret==RC_OK) 
+
+      if (!(p_dyndns->cmd==CMD_STOP))
+
+        p_dyndns->cmd=CMD_UPDTED;
+
+
+    if (!(ReleaseMutex(hUpdateMutex)))
+
+      dbg_printf_and_err_str(NULL,"C:" MODULE_TAG "Failed ReleaseMutex.  Low resources?  System is unstable...",GetLastError(),LOG_CRIT,p_dyndns->dbg.level);
+
+  else
+
+      if (p_dyndns->dbg.level>=LOG_INFO)
+
+        DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Update handler released mutex...\n"));
+  }
+
+  return update_ret;
+}
+
+
+static RC_TYPE attempt_update(DYN_DNS_CLIENT *p_dyndns,RAS_THREAD_DATA *p_ras_thread_data)
+{
+
+  RC_TYPE            update_ret=0;
+
+  DWORD              wait_ret=0;
+
+
   if (p_dyndns->dbg.level>=LOG_INFO)
 
     DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Attempting ip update...\n"));
@@ -1311,7 +1430,7 @@
       DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Got mutex...\n"));
 
 
-    if (!(is_online(p_ras_thread_data,p_dyndns->http_to_ip_server.super.super.p_remote_host_name,
+    if (!(is_online(p_ras_thread_data,,p_dyndns->http_to_ip_server.super.super.p_remote_host_name,
                     p_dyndns->dbg.level))) {
 
       if (p_dyndns->dbg.level>=LOG_INFO)
@@ -1382,6 +1501,7 @@
 
   }
 
+
   return update_ret;
 }
 
@@ -1515,14 +1635,15 @@
 
 #ifndef _WIN32
 
+
 	if ((fp=fopen(p_dyndns->ip_cache, "r")))
 	{
-		fgets (p_dyndns->info.my_ip_address.name, sizeof (p_dyndns->info.my_ip_address.name),fp);
+		fgets (p_dyndns->info[0].my_ip_address.name, sizeof (p_dyndns->info[0].my_ip_address.name),fp);
 
 		fclose(fp);
 
 		
-		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "IP read from cache file is '%s'...\n", p_dyndns->info.my_ip_address.name));
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "IP read from cache file is '%s'...\n", p_dyndns->info[0].my_ip_address.name));
 	}
 
 #else
@@ -1580,7 +1701,6 @@
 
 
 #ifdef _WIN32
-
 	get_mutex_wait(p_dyndns,&hUpdateMutex);
 #endif
 
@@ -1707,18 +1827,6 @@
     }
   }
 
-  if (p_dyndns->change_persona)
-  {
-    OS_USER_INFO os_usr_info;
-    memset(&os_usr_info, 0, sizeof(os_usr_info));
-    os_usr_info.gid = p_dyndns->sys_usr_info.gid;
-    os_usr_info.uid = p_dyndns->sys_usr_info.uid;
-    rc = os_change_persona(&os_usr_info);
-    if (rc != RC_OK)
-    {
-      return rc;
-    }
-  }
 
   /*if silent required, close console window*/
   if (p_dyndns->run_in_background == TRUE)
@@ -1734,6 +1842,45 @@
     }
   }
 
+  /*if pid-file wanted, create it*/
+  if (p_dyndns->p_pidfilename && strlen(p_dyndns->p_pidfilename) != 0)
+  {
+	FILE *fp;
+	int obj;
+	char pid[7];
+
+	if ((fp = fopen(p_dyndns->p_pidfilename, "w")))
+	{
+
+#ifndef _WIN32
+		sprintf(pid, "%d\n", getpid());
+#else
+		sprintf(pid, "%d\n", _getpid());
+#endif
+		obj = fwrite(pid, strlen(pid), 1, fp);
+		fclose(fp);
+	}
+	free(p_dyndns->p_pidfilename);
+	p_dyndns->p_pidfilename = NULL;
+	if (!fp || obj != 1)
+	{
+		return RC_FILE_IO_OPEN_ERROR;
+	}
+  }
+
+  if (p_dyndns->change_persona)
+  {
+    OS_USER_INFO os_usr_info;
+    memset(&os_usr_info, 0, sizeof(os_usr_info));
+    os_usr_info.gid = p_dyndns->sys_usr_info.gid;
+    os_usr_info.uid = p_dyndns->sys_usr_info.uid;
+    rc = os_change_persona(&os_usr_info);
+    if (rc != RC_OK)
+    {
+      return rc;
+    }
+  }
+
   dyn_dns_print_hello(NULL);
 
 /*  now that log is open, report any command line errors eventhough registry params made up for them --
diff -bruN src/dyndns.h src/dyndns.h
--- src/dyndns.h	2008-07-30 13:11:55.000000000 +0200
+++ src/dyndns.h	2008-09-03 15:19:11.000000000 +0200
@@ -43,7 +43,7 @@
 
 #endif
 
-#define DYNDNS_VERSION_STRING  "02.12.24"
+#define DYNDNS_VERSION_STRING  "02.12.24 with multi services- & pid-patch"
 #define DYNDNS_AGENT_NAME  "inadyn-mt/" DYNDNS_VERSION_STRING
 #define DYNDNS_EMAIL_ADDR  "bhoover@wecs.com"
 
@@ -106,16 +106,16 @@
 
 /* Conversation with the IP server */
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST  \
-	"GET http://%s%s HTTP/1.0\r\n\r\n"
+	"GET http://%s:%d%s HTTP/1.0\r\n\r\n"
 
 /* dyndns.org specific update address format */
 /* 3322.org has the same parameters ...*/
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT \
-	"GET %s" \
+	"GET http://%s:%d%s" \
 		"system=%s&" \
 		"hostname=%s&" \
 		"myip=%s&" \
-		"wildcard=%s&" \
+		"wildcard=ON&" \
 		"mx=%s&" \
 	  "backmx=NO&" \
 	  "offline=NO " \
@@ -126,7 +126,7 @@
     
 /*freedns.afraid.org specific update request format */    
 #define FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT \
-    "GET %s" \
+    "GET http://%s:%d%s" \
     "%s " \
 	 "HTTP/1.0\r\n" \
 	"Host: %s\r\n" \
@@ -140,14 +140,14 @@
 	The parameter here is the entire request but NOT including the alias.
 */
 #define GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT \
-    "GET %s%s " \
+    "GET http://%s:%d%s%s " \
 	 "HTTP/1.0\r\n" \
 	"Authorization: Basic %s\r\n" \
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
 #define GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT \
-    "GET %s%s&myip=%s " \
+    "GET http://%s:%d%s%s&myip=%s " \
 	 "HTTP/1.0\r\n" \
 	"Authorization: Basic %s\r\n" \
 	"Host: %s\r\n" \
@@ -156,7 +156,7 @@
 /** dont ask me why easydns is so picky
 */
 #define GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT \
-    "GET %s%s&" \
+    "GET http://%s:%d%s%s&" \
 		"myip=%s&" \
 		"wildcard=%s "\
 	 "HTTP/1.0\r\n" \
@@ -166,7 +166,7 @@
 
 /* sitelutions.com specific update address format */
 #define SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT \
-	"GET %s" \
+	"GET http://%s:%d%s" \
 		"user=%s&" \
 		"pass=%s&" \
 		"id=%s&" \
@@ -190,7 +190,8 @@
 #define DYNDNS_RETRY_INTERVAL	1000
 #define DYNDNS_HTTP_RESPONSE_BUFFER_SIZE	(2500) /*Bytes*/
 #define DYNDNS_HTTP_REQUEST_BUFFER_SIZE		(2500) /*Bytes*/
-#define DYNDNS_MAX_ALIAS_NUMBER		10 /*maximum number of aliases that can be maintained*/
+#define DYNDNS_MAX_ALIAS_NUMBER		10 /*maximum number of aliases per server that can be maintained*/
+#define DYNDNS_MAX_SERVER_NUMBER	5 /*maximum number of servers that can be maintained*/
 
 /*local configs*/
 #define DYNDNS_MY_IP_ADDRESS_LENGTH	20 /*chars*/
@@ -211,8 +212,8 @@
 /** Function to prepare DNS system specific server requests 
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, int infnr, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int infnr, int alnr, struct DYNDNS_SYSTEM *p_sys_info);
 typedef struct 
 {
     const char* p_key;
@@ -268,6 +269,13 @@
 
 typedef struct 
 {
+	DYNDNS_SERVER_NAME names;
+	int update_required;
+	DYNDNS_HASH_TYPE hashes; 
+} DYNDNS_ALIAS_INFO;
+
+typedef struct 
+{
     BOOL my_ip_has_changed;
 	DYNDNS_SERVER_NAME my_ip_address;
 	DYNDNS_CREDENTIALS credentials;
@@ -277,18 +285,12 @@
 	DYNDNS_SERVER_NAME ip_server_name;
 	char ip_server_url[DYNDNS_SERVER_URL_LENGTH];
 	DYNDNS_SERVER_NAME proxy_server_name;
+	DYNDNS_ALIAS_INFO alias_info[DYNDNS_MAX_ALIAS_NUMBER];
+	int alias_count;
 } DYNDNS_INFO_TYPE;
 
 typedef struct 
 {
-	DYNDNS_SERVER_NAME names[DYNDNS_MAX_ALIAS_NUMBER];
-	int update_required[DYNDNS_MAX_ALIAS_NUMBER];
-	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER]; 
-	int count;
-} DYNDNS_ALIAS_INFO;
-
-typedef struct
-{
 	int uid;
 	int gid;
 } USER_INFO;
@@ -314,8 +316,8 @@
 	BOOL debug_to_syslog;
 	BOOL change_persona;
 
-	HTTP_CLIENT http_to_ip_server;
-	HTTP_CLIENT http_to_dyndns;
+	HTTP_CLIENT http_to_ip_server[DYNDNS_MAX_SERVER_NUMBER];
+	HTTP_CLIENT http_to_dyndns[DYNDNS_MAX_SERVER_NUMBER];
 	HTTP_TRANSACTION http_tr;
 	char *p_work_buffer; /* for HTTP responses*/
 	int work_buffer_size;
@@ -327,8 +329,8 @@
 
 
 	USER_INFO sys_usr_info; /*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE info; /*servers, names, passwd*/
-	DYNDNS_ALIAS_INFO alias_info;
+	DYNDNS_INFO_TYPE info[DYNDNS_MAX_SERVER_NUMBER]; /*servers, names, passwd*/
+	int info_count;
 
 	BOOL abort_on_network_errors;
 	BOOL force_addr_update;
@@ -336,6 +338,7 @@
 	BOOL abort;
 	BOOL wildcard;
 
+	char *p_pidfilename;
 	/*dbg*/
 	DBG_TYPE dbg;
 } DYN_DNS_CLIENT;
@@ -408,7 +411,6 @@
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-
 #ifndef _WIN32
 
 RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self);
diff -bruN src/http_client.c src/http_client.c
--- src/http_client.c	2008-07-30 13:11:55.000000000 +0200
+++ src/http_client.c	2008-09-03 11:49:54.000000000 +0200
@@ -56,10 +56,16 @@
 /*
 	Resource free.
 */	
-RC_TYPE http_client_destruct(HTTP_CLIENT *p_self)
+RC_TYPE http_client_destruct(HTTP_CLIENT *p_self, int num)
 {
+	int i = 0, rv;
+
 	/*free*/
-	return super_destruct(&p_self->super);
+	while(i < num)
+	{
+		rv = super_destruct(&p_self[i++].super);
+	}
+	return rv;
 }
 
 
diff -bruN src/http_client.h src/http_client.h
--- src/http_client.h	2008-07-30 13:11:55.000000000 +0200
+++ src/http_client.h	2008-09-03 11:49:54.000000000 +0200
@@ -61,7 +61,7 @@
 /*
 	Resource free.
 */	
-RC_TYPE http_client_destruct(HTTP_CLIENT *p_self);
+RC_TYPE http_client_destruct(HTTP_CLIENT *p_self, int num);
 
 /* 
 	Sets up the object.
diff -bruN src/inadyn_cmd.c src/inadyn_cmd.c
--- src/inadyn_cmd.c	2008-07-30 13:11:55.000000000 +0200
+++ src/inadyn_cmd.c	2008-09-03 12:41:39.000000000 +0200
@@ -51,6 +51,8 @@
 #include "safe_mem.h"
 #include "path.h"
 
+static int curr_info;
+
 /* command line options */
 #define DYNDNS_INPUT_FILE_OPT_STRING "--input_file"
 
@@ -68,6 +70,7 @@
 static RC_TYPE get_update_period_sec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -152,8 +155,9 @@
 	{"--update_period_sec",	1,	{get_update_period_sec_handler, NULL,0},	"how often the IP is checked. The period is in [sec]. Default is about 1 min. Max is 10 days"},
 	{"--forced_update_period", 1,   {get_forced_update_period_handler, NULL,0},"how often the IP is updated even if it is not changed. [in sec]"},
 
-	{"--log_file",	1,	{get_logfile_name, NULL,0},		"log file path abd name"},
-	{"--background", 0,	{set_silent_handler, NULL,0},		"run in background. output to log file or to syslog"},
+	{"--log_file",	1,	{get_logfile_name, NULL},		"log file path abd name"},
+	{"--pid_file",	1,	{get_pidfile_name, NULL},		"pid file path abd name"},
+	{"--background", 0,	{set_silent_handler, NULL},		"run in background. output to log file or to syslog"},
 
 	{"--verbose",	1,	{set_verbose_handler, NULL,0},	"set dbg level. 0 to 5"},
 
@@ -268,7 +272,6 @@
 	return RC_OK;
 }
 
-
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -285,6 +288,22 @@
 	return RC_OK;
 }
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *)malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 static RC_TYPE get_username_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
@@ -295,11 +314,11 @@
 	}
 
 	/*user*/
-	if (sizeof(p_self->info.credentials.my_username) < strlen(p_cmd->argv[current_nr]))
+	if (sizeof(p_self->info[curr_info].credentials.my_username) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[curr_info].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -312,13 +331,13 @@
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.credentials.my_password) < strlen(p_cmd->argv[current_nr]))
+	/*password*/
+	if (sizeof(p_self->info[curr_info].credentials.my_password) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
 
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	strcpy(p_self->info[curr_info].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -339,7 +358,7 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count >= DYNDNS_MAX_ALIAS_NUMBER)
+	if (p_self->info[curr_info].alias_count >= DYNDNS_MAX_ALIAS_NUMBER)
 	{
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -348,23 +367,23 @@
         p_hash = strstr(p_cmd->argv[current_nr],",");
         if (p_hash)
 	{
-	    if (sizeof(*p_self->alias_info.hashes) < strlen(p_hash))
+	    if (sizeof(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].hashes) < strlen(p_hash))
 	    {
 		return RC_DYNDNS_BUFFER_TOO_SMALL;
 	    }
-	    strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str, p_hash);
+	    strcpy(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].hashes.str, p_hash);
 	    *p_hash = '\0';
 	}
 
 
 	/*user*/
-	if (sizeof(p_self->alias_info.names[p_self->alias_info.count]) < strlen(p_cmd->argv[current_nr]))
+	if (sizeof(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].name, (p_cmd->argv[current_nr]));
+	strcpy(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names.name, (p_cmd->argv[current_nr]));
 
-	p_self->alias_info.count ++;
+	p_self->info[curr_info].alias_count++;
 	return RC_OK;
 }
 
@@ -406,24 +425,24 @@
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.ip_server_name) < strlen(p_cmd->argv[current_nr]) + 1)
+	/*ip_server_name*/
+	if (sizeof(p_self->info[curr_info].ip_server_name) < strlen(p_cmd->argv[current_nr]) + 1)
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
 
-    p_self->info.ip_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.ip_server_name.name, &port);
+    p_self->info[curr_info].ip_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].ip_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.ip_server_name.port = port;
+        p_self->info[curr_info].ip_server_name.port = port;
     }        
 
-	if (sizeof(p_self->info.ip_server_url) < strlen(p_cmd->argv[current_nr + 1]) + 1)
+	if (sizeof(p_self->info[curr_info].ip_server_url) < strlen(p_cmd->argv[current_nr + 1]) + 1)
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.ip_server_url, p_cmd->argv[current_nr + 1]);
+	strcpy(p_self->info[curr_info].ip_server_url, p_cmd->argv[current_nr + 1]);
 
 	return rc;
 }
@@ -439,17 +458,17 @@
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.dyndns_server_name) < strlen(p_cmd->argv[current_nr]))
+	/*dyndns_server_name*/
+	if (sizeof(p_self->info[curr_info].dyndns_server_name) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.dyndns_server_name.name, &port);
+    p_self->info[curr_info].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].dyndns_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.dyndns_server_name.port = port;
+        p_self->info[curr_info].dyndns_server_name.port = port;
     }                                   
 	return rc;
 }
@@ -462,12 +481,12 @@
 		return RC_INVALID_POINTER;
 	}
 
-	/*name*/
-	if (sizeof(p_self->info.dyndns_server_url) < strlen(p_cmd->argv[current_nr]))
+	/*dyndns_server_url*/
+	if (sizeof(p_self->info[curr_info].dyndns_server_url) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[curr_info].dyndns_server_url, p_cmd->argv[current_nr]);
 	return RC_OK;
 }
 
@@ -484,17 +503,17 @@
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.proxy_server_name) < strlen(p_cmd->argv[current_nr]))
+	/*proxy_server_name*/
+	if (sizeof(p_self->info[curr_info].proxy_server_name) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.proxy_server_name.name, &port);
+    p_self->info[curr_info].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[curr_info].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -674,6 +693,7 @@
 {
     DYNDNS_SYSTEM *p_dns_system = NULL;
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
@@ -695,7 +715,21 @@
         return RC_DYNDNS_INVALID_OPTION;
     }
 
-    p_self->info.p_dns_system = p_dns_system;
+	for (curr_info = 0; curr_info < p_self->info_count &&
+	     curr_info < DYNDNS_MAX_SERVER_NUMBER &&
+	     p_self->info[curr_info].p_dns_system != p_dns_system; curr_info++)
+	{
+	}
+	if (curr_info >= p_self->info_count)
+	{
+		if (curr_info < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			p_self->info_count++;
+			p_self->info[curr_info].p_dns_system = p_dns_system;
+		}
+	   	else
+			return RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
 	
 	return RC_OK;
 }
@@ -1450,6 +1484,7 @@
 	return rc;
 }
 
+
 /* 
 	Set up all details:
 		- ip server name
@@ -1467,6 +1502,7 @@
 */
 RC_TYPE get_config_data_with_error_handling(DYN_DNS_CLIENT *p_self, int argc, char** argv,CMD_OPTION_ERR_HANDLER_FUNC pf_err_handler)
 {
+	int i;
 	RC_TYPE rc = RC_OK;
 	FILE *fp;
 	char cached_time[80];
@@ -1492,7 +1528,6 @@
 		/* in case of no options, assume the default cfg file may be present */
 		if (argc == 1)
 		{
-
 			rc = get_default_infile_config(p_self,pf_err_handler);
 		}
 		else
@@ -1507,49 +1542,53 @@
 		}	
 
         /*settings that may change due to cmd line options*/
+	i = 0;
+	do
         {
     		/*ip server*/
-            if (strlen(p_self->info.ip_server_name.name) == 0)
+            if (strlen(p_self->info[i].ip_server_name.name) == 0)
             {
-                if (sizeof(p_self->info.ip_server_name.name) < strlen(p_self->info.p_dns_system->p_ip_server_name))
+                if (sizeof(p_self->info[i].ip_server_name.name) < strlen(p_self->info[i].p_dns_system->p_ip_server_name))
                 {
                     rc = RC_DYNDNS_BUFFER_TOO_SMALL;
                     break;
                 }
-                strcpy(p_self->info.ip_server_name.name, p_self->info.p_dns_system->p_ip_server_name);
+                strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
 
-                if (sizeof(p_self->info.ip_server_url) < strlen(p_self->info.p_dns_system->p_ip_server_url))
+                if (sizeof(p_self->info[i].ip_server_url) < strlen(p_self->info[i].p_dns_system->p_ip_server_url))
                 {
                     rc = RC_DYNDNS_BUFFER_TOO_SMALL;
                     break;
                 }
-                strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+                strcpy(p_self->info[i].ip_server_url, p_self->info[i].p_dns_system->p_ip_server_url);				
             }
 
     		/*dyndns server*/
-            if (strlen(p_self->info.dyndns_server_name.name) == 0)
+            if (strlen(p_self->info[i].dyndns_server_name.name) == 0)
             {
-        		if (sizeof(p_self->info.dyndns_server_name.name) < strlen(p_self->info.p_dns_system->p_dyndns_server_name))
+		if (sizeof(p_self->info[i].dyndns_server_name.name) < strlen(p_self->info[i].p_dns_system->p_dyndns_server_name))
         		{
         			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
         			break;
         		}
-        		strcpy(p_self->info.dyndns_server_name.name, p_self->info.p_dns_system->p_dyndns_server_name);
+		strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
 
-        		if (sizeof(p_self->info.dyndns_server_url) < strlen(p_self->info.p_dns_system->p_dyndns_server_url))
+		if (sizeof(p_self->info[i].dyndns_server_url) < strlen(p_self->info[i].p_dns_system->p_dyndns_server_url))
         		{
         			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
         			break;
         		}
-        		strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+		strcpy(p_self->info[i].dyndns_server_url, p_self->info[i].p_dns_system->p_dyndns_server_url);
             }
         }
+	while(++i < p_self->info_count);
 
 		/*check if the neccessary params have been provided*/
 		if ( 
-			(strlen(p_self->info.dyndns_server_name.name) == 0)  ||
-			(strlen(p_self->info.ip_server_name.name)	  == 0)  ||
-			(p_self->alias_info.count == 0)
+			(p_self->info_count == 0) ||
+			(p_self->info[0].alias_count == 0) ||
+			(strlen(p_self->info[0].dyndns_server_name.name) == 0)  ||
+			(strlen(p_self->info[0].ip_server_name.name)	 == 0)
 			)
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
diff -bruN src/service.c src/service.c
--- src/service.c	2008-07-30 13:11:55.000000000 +0200
+++ src/service.c	2008-09-03 11:50:19.000000000 +0200
@@ -129,6 +129,39 @@
   return hService;
 }
 
+SC_HANDLE get_service_handle(wchar_t *szName,DWORD access_type)
+{
+
+  SC_HANDLE      hService=NULL;
+  SC_HANDLE      hSCManager;
+
+
+  SetLastError(0);
+  
+
+  hSCManager=OpenSCManager(NULL,NULL,access_type);
+
+
+  if (!hSCManager) {
+
+    dbg_printf_and_err_str(NULL,"E:" MODULE_TAG "Could not open scm.  Could not get service handle",GetLastError(),LOG_ERR,LOG_DEBUG);
+
+  }
+  else {
+
+    hService=OpenService(hSCManager,szName,SERVICE_ALL_ACCESS);
+
+    if (!(hService)) {
+
+      CloseServiceHandle(hSCManager);
+
+      dbg_printf_and_err_str(NULL,"E:" MODULE_TAG "Could not open service.  Could not get service handle",GetLastError(),LOG_ERR,LOG_DEBUG);
+    }
+  }
+
+  return hService;
+}
+
 int start_service(wchar_t *szName,int argc,wchar_t *argv[]) 
 {
 
diff -bruN src/service_main.c src/service_main.c
--- src/service_main.c	2008-07-30 13:11:55.000000000 +0200
+++ src/service_main.c	2008-09-03 11:50:19.000000000 +0200
@@ -656,6 +656,54 @@
 	}
 }
 
+/*if still in running state, then 
+  ask scm to stop service
+*/
+static void request_stop_if_needed()
+{
+
+	SERVICE_STATUS	service_status;
+	DWORD			status_ret=NO_ERROR;
+	SC_HANDLE		hService=NULL;
+	
+
+	memset(&service_status,0,sizeof(SERVICE_STATUS));
+
+
+	if (!(hService=get_service_handle(szServiceName,SC_MANAGER_ALL_ACCESS)))
+
+		DBG_SERVICE_PRINTF((pLOG_FILE,"C:" MODULE_TAG "Could not get handle to service in request_stop_if_needed...\n"));
+
+	else {
+
+		if (!(QueryServiceStatus(hService,&service_status)))
+		
+			dbg_printf_and_err_str(pLOG_FILE,"C:" MODULE_TAG "QueryServiceStatus failed in request_stop_if_client_return"\
+									"...\n",GetLastError(),LOG_CRIT,LOG_DEBUG);
+
+		else {
+
+			if (service_status.dwCurrentState==SERVICE_RUNNING) {
+
+				DBG_SERVICE_PRINTF((pLOG_FILE,"I:" MODULE_TAG "Service client exited.  Stopping service...\n"));
+
+
+				if (!(status_ret=ControlService(hService,SERVICE_CONTROL_STOP,(LPSERVICE_STATUS) &service_status)))
+
+					dbg_printf_and_err_str(pLOG_FILE,"C:" MODULE_TAG "ControlService failed in request_stop_if_client_return"\
+											"...\n",GetLastError(),LOG_CRIT,LOG_DEBUG);
+
+				else
+
+					DBG_SERVICE_PRINTF((pLOG_FILE,"I:" MODULE_TAG "Request for service stop succeded...\n"));
+			
+			}
+		}
+
+		CloseServiceHandle(hService);
+	}
+}
+
 static void service_work_thread(void *worker_args)
 {
   
@@ -679,6 +727,8 @@
 
   request_stop_if_needed();
 
+  request_stop_if_needed();
+
   utf_free_ar(utf_8_ar,p_worker_args->argc);
 
   DBG_SERVICE_PRINTF((pLOG_FILE,"I:" MODULE_TAG "Service client thread returned from client...\n"));  
