--- linux-2.6.13.1/fs/Kconfig.orig	2007-07-29 03:52:03.000000000 +0200
+++ linux-2.6.13.1/fs/Kconfig	2007-07-29 03:52:04.000000000 +0200
@@ -1362,6 +1362,16 @@
 	  Say Y here if you want to try writing to UFS partitions. This is
 	  experimental, so you should back up your UFS partitions beforehand.
 
+config UNION_FS
+	tristate "Union fs support"
+	depends on EXPERIMENTAL
+	help
+	  Unionfs is a stackable unification file system, which can
+	  appear to merge the contents of several directories (branches),
+	  while keeping their physical content separate.
+
+	  see <http://www.fsl.cs.sunysb.edu/project-unionfs.html> for details
+
 endmenu
 
 menu "Network File Systems"
--- linux-2.6.13.1/fs/Makefile.orig	2007-07-29 03:52:03.000000000 +0200
+++ linux-2.6.13.1/fs/Makefile	2007-07-29 03:52:04.000000000 +0200
@@ -101,3 +101,4 @@
 obj-$(CONFIG_HPPFS)		+= hppfs/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_YFFS_FS)		+= yaffs2/
+obj-$(CONFIG_UNION_FS)          += unionfs/
--- linux-2.6.13.1/fs/unionfs/branchman.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/branchman.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,563 @@
+/* 
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: branchman.c,v 1.62 2006/02/13 00:18:40 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+struct dentry **alloc_new_dentries(int objs)
+{
+	if (!objs)
+		return NULL;
+
+	return KZALLOC(sizeof(struct dentry *) * objs, GFP_KERNEL);
+}
+
+struct unionfs_usi_data *alloc_new_data(int objs)
+{
+	if (!objs)
+		return NULL;
+
+	return KZALLOC(sizeof(struct unionfs_usi_data) * objs, GFP_KERNEL);
+}
+
+static void fixputmaps(struct super_block *sb)
+{
+	struct unionfs_sb_info *spd;
+	struct putmap *cur;
+	int gen;
+	int i;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	cur = spd->usi_putmaps[spd->usi_lastputmap - spd->usi_firstputmap];
+
+	for (gen = 0; gen < spd->usi_lastputmap - spd->usi_firstputmap; gen++) {
+		if (!spd->usi_putmaps[gen])
+			continue;
+		for (i = 0; i <= spd->usi_putmaps[gen]->bend; i++)
+			spd->usi_putmaps[gen]->map[i] =
+			    cur->map[spd->usi_putmaps[gen]->map[i]];
+	}
+
+	print_exit_location();
+}
+
+static int newputmap(struct super_block *sb)
+{
+	struct unionfs_sb_info *spd;
+	struct putmap *newmap;
+	int count = 0;
+	int i;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	i = sizeof(int) * (sbend(sb) + 1);
+	newmap = KMALLOC(sizeof(struct putmap) + i, GFP_KERNEL);
+	if (!newmap) {
+		print_exit_status(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	if (!spd->usi_firstputmap) {
+		spd->usi_firstputmap = 1;
+		spd->usi_lastputmap = 1;
+
+		spd->usi_putmaps = KMALLOC(sizeof(struct putmap *), GFP_KERNEL);
+		if (!spd->usi_putmaps) {
+			KFREE(newmap);
+			print_exit_status(-ENOMEM);
+			return -ENOMEM;
+		}
+	} else {
+		struct putmap **newlist;
+		int newfirst = spd->usi_firstputmap;
+
+		while (!spd->usi_putmaps[newfirst - spd->usi_firstputmap] &&
+		       newfirst <= spd->usi_lastputmap) {
+			newfirst++;
+		}
+
+		newlist =
+		    KMALLOC(sizeof(struct putmap *) *
+			    (1 + spd->usi_lastputmap - newfirst), GFP_KERNEL);
+		if (!newlist) {
+			KFREE(newmap);
+			print_exit_status(-ENOMEM);
+			return -ENOMEM;
+		}
+
+		for (i = newfirst; i <= spd->usi_lastputmap; i++) {
+			newlist[i - newfirst] =
+			    spd->usi_putmaps[i - spd->usi_firstputmap];
+		}
+
+		KFREE(spd->usi_putmaps);
+		spd->usi_putmaps = newlist;
+		spd->usi_firstputmap = newfirst;
+		spd->usi_lastputmap++;
+	}
+
+	newmap->bend = sbend(sb);
+	for (i = 0; i <= sbend(sb); i++) {
+		count += branch_count(sb, i);
+		newmap->map[i] = i;
+	}
+	for (i = spd->usi_firstputmap; i < spd->usi_lastputmap; i++) {
+		struct putmap *cur;
+		cur = spd->usi_putmaps[i - spd->usi_firstputmap];
+		if (!cur)
+			continue;
+		count -= atomic_read(&cur->count);
+	}
+	atomic_set(&newmap->count, count);
+	spd->usi_putmaps[spd->usi_lastputmap - spd->usi_firstputmap] = newmap;
+
+	print_exit_status(0);
+	return 0;
+}
+
+int unionfs_ioctl_branchcount(struct file *file, unsigned int cmd,
+			      unsigned long arg)
+{
+	int err = 0;
+	int bstart, bend;
+	int i;
+	struct super_block *sb = file->f_dentry->d_sb;
+
+	print_entry_location();
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	err = bend + 1;
+	if (!arg)
+		goto out;
+
+	for (i = bstart; i <= bend; i++) {
+		if (put_user(branch_count(sb, i), ((int __user *)arg) + i)) {
+			err = -EFAULT;
+			goto out;
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_ioctl_incgen(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	struct super_block *sb;
+
+	print_entry_location();
+
+	sb = file->f_dentry->d_sb;
+
+	unionfs_write_lock(sb);
+	if ((err = newputmap(sb)))
+		goto out;
+
+	atomic_inc(&stopd(sb)->usi_generation);
+	err = atomic_read(&stopd(sb)->usi_generation);
+
+	atomic_set(&dtopd(sb->s_root)->udi_generation, err);
+	atomic_set(&itopd(sb->s_root->d_inode)->uii_generation, err);
+
+      out:
+	unionfs_write_unlock(sb);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_ioctl_addbranch(struct inode *inode, unsigned int cmd,
+			    unsigned long arg)
+{
+	int err;
+	struct unionfs_addbranch_args *addargs = NULL;
+	struct nameidata nd;
+	char *path = NULL;
+	int gen;
+	int i;
+
+	int pobjects;
+
+	struct unionfs_usi_data *new_data = NULL;
+	struct dentry **new_udi_dentry = NULL;
+	struct inode **new_uii_inode = NULL;
+
+	struct dentry *root = NULL;
+	struct dentry *hidden_root = NULL;
+
+	print_entry_location();
+
+	err = -ENOMEM;
+	addargs = KMALLOC(sizeof(struct unionfs_addbranch_args), GFP_KERNEL);
+	if (!addargs)
+		goto out;
+
+	err = -EFAULT;
+	if (copy_from_user
+	    (addargs, (const void __user *)arg,
+	     sizeof(struct unionfs_addbranch_args)))
+		goto out;
+
+	err = -EINVAL;
+	if (addargs->ab_perms & ~(MAY_READ | MAY_WRITE | MAY_NFSRO))
+		goto out;
+	if (!(addargs->ab_perms & MAY_READ))
+		goto out;
+
+	err = -E2BIG;
+	if (sbend(inode->i_sb) > FD_SETSIZE)
+		goto out;
+
+	err = -ENOMEM;
+	if (!(path = getname((const char __user *)addargs->ab_path)))
+		goto out;
+
+	err = path_lookup(path, LOOKUP_FOLLOW, &nd);
+
+	RECORD_PATH_LOOKUP(&nd);
+	if (err)
+		goto out;
+	if ((err = check_branch(&nd))) {
+		path_release(&nd);
+		RECORD_PATH_RELEASE(&nd);
+		goto out;
+	}
+
+	unionfs_write_lock(inode->i_sb);
+	lock_dentry(inode->i_sb->s_root);
+
+	root = inode->i_sb->s_root;
+	for (i = dbstart(inode->i_sb->s_root); i <= dbend(inode->i_sb->s_root);
+	     i++) {
+		hidden_root = dtohd_index(root, i);
+		if (is_branch_overlap(hidden_root, nd.dentry)) {
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	err = -EINVAL;
+	if (addargs->ab_branch < 0
+	    || (addargs->ab_branch > (sbend(inode->i_sb) + 1)))
+		goto out;
+
+	if ((err = newputmap(inode->i_sb)))
+		goto out;
+
+	stopd(inode->i_sb)->b_end++;
+	dtopd(inode->i_sb->s_root)->udi_bcount++;
+	set_dbend(inode->i_sb->s_root, dbend(inode->i_sb->s_root) + 1);
+	itopd(inode->i_sb->s_root->d_inode)->b_end++;
+
+	atomic_inc(&stopd(inode->i_sb)->usi_generation);
+	gen = atomic_read(&stopd(inode->i_sb)->usi_generation);
+
+	pobjects = sbend(inode->i_sb) + 1;
+
+	/* Reallocate the dynamic structures. */
+	new_data = alloc_new_data(pobjects);
+	new_udi_dentry = alloc_new_dentries(pobjects);
+	new_uii_inode = KZALLOC(sizeof(struct inode *) * pobjects, GFP_KERNEL);
+
+	if (!new_udi_dentry || !new_uii_inode || !new_data) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Copy the in-place values to our new structure. */
+	for (i = 0; i < addargs->ab_branch; i++) {
+		atomic_set(&(new_data[i].sbcount),
+			   branch_count(inode->i_sb, i));
+
+		new_data[i].branchperms = branchperms(inode->i_sb, i);
+		new_data[i].hidden_mnt = stohiddenmnt_index(inode->i_sb, i);
+		new_data[i].sb = stohs_index(inode->i_sb, i);
+
+		new_udi_dentry[i] = dtohd_index(inode->i_sb->s_root, i);
+		new_uii_inode[i] = itohi_index(inode->i_sb->s_root->d_inode, i);
+	}
+
+	/* Shift the ends to the right (only handle reallocated bits). */
+	for (i = sbend(inode->i_sb) - 1; i >= (int)addargs->ab_branch; i--) {
+		int j = i + 1;
+		int pmindex;
+
+		atomic_set(&new_data[j].sbcount, branch_count(inode->i_sb, i));
+
+		new_data[j].branchperms = branchperms(inode->i_sb, i);
+		new_data[j].hidden_mnt = stohiddenmnt_index(inode->i_sb, i);
+		new_data[j].sb = stohs_index(inode->i_sb, i);
+		new_udi_dentry[j] = dtohd_index(inode->i_sb->s_root, i);
+		new_uii_inode[j] = itohi_index(inode->i_sb->s_root->d_inode, i);
+
+		/* Update the newest putmap, so it is correct for later. */
+		pmindex = stopd(inode->i_sb)->usi_lastputmap;
+		pmindex -= stopd(inode->i_sb)->usi_firstputmap;
+		stopd(inode->i_sb)->usi_putmaps[pmindex]->map[i] = j;
+
+	}
+
+	/* Now we can free the old ones. */
+	KFREE(dtopd(inode->i_sb->s_root)->udi_dentry);
+	KFREE(itopd(inode->i_sb->s_root->d_inode)->uii_inode);
+	KFREE(stopd(inode->i_sb)->usi_data);
+
+	/* Update the real pointers. */
+	dtohd_ptr(inode->i_sb->s_root) = new_udi_dentry;
+	itohi_ptr(inode->i_sb->s_root->d_inode) = new_uii_inode;
+	stopd(inode->i_sb)->usi_data = new_data;
+
+	/* Re-NULL the new ones so we don't try to free them. */
+	new_data = NULL;
+	new_udi_dentry = NULL;
+	new_uii_inode = NULL;
+
+	/* Put the new dentry information into it's slot. */
+	set_dtohd_index(inode->i_sb->s_root, addargs->ab_branch, nd.dentry);
+	set_itohi_index(inode->i_sb->s_root->d_inode, addargs->ab_branch,
+			IGRAB(nd.dentry->d_inode));
+	set_branchperms(inode->i_sb, addargs->ab_branch, addargs->ab_perms);
+	set_branch_count(inode->i_sb, addargs->ab_branch, 0);
+	set_stohiddenmnt_index(inode->i_sb, addargs->ab_branch, nd.mnt);
+	set_stohs_index(inode->i_sb, addargs->ab_branch, nd.dentry->d_sb);
+
+	atomic_set(&dtopd(inode->i_sb->s_root)->udi_generation, gen);
+	atomic_set(&itopd(inode->i_sb->s_root->d_inode)->uii_generation, gen);
+
+	fixputmaps(inode->i_sb);
+
+      out:
+	unlock_dentry(inode->i_sb->s_root);
+	unionfs_write_unlock(inode->i_sb);
+
+	KFREE(new_udi_dentry);
+	KFREE(new_uii_inode);
+	KFREE(new_data);
+	KFREE(addargs);
+	if (path)
+		putname(path);
+
+	print_exit_status(err);
+
+	return err;
+}
+
+/* This must be called with the super block already locked. */
+int unionfs_ioctl_delbranch(struct super_block *sb, unsigned long arg)
+{
+	struct dentry *hidden_dentry;
+	struct inode *hidden_inode;
+	struct vfsmount *hidden_mnt;
+	struct dentry *root_dentry;
+	struct inode *root_inode;
+	int err = 0;
+	int pmindex, i, gen;
+
+	print_entry("branch = %lu ", arg);
+	lock_dentry(sb->s_root);
+
+	err = -EBUSY;
+	if (sbmax(sb) == 1)
+		goto out;
+	err = -EINVAL;
+	if (arg < 0 || arg > stopd(sb)->b_end)
+		goto out;
+	err = -EBUSY;
+	if (branch_count(sb, arg))
+		goto out;
+
+	if ((err = newputmap(sb)))
+		goto out;
+
+	pmindex = stopd(sb)->usi_lastputmap;
+	pmindex -= stopd(sb)->usi_firstputmap;
+
+	atomic_inc(&stopd(sb)->usi_generation);
+	gen = atomic_read(&stopd(sb)->usi_generation);
+
+	root_dentry = sb->s_root;
+	root_inode = sb->s_root->d_inode;
+
+	hidden_dentry = dtohd_index(root_dentry, arg);
+	hidden_mnt = stohiddenmnt_index(sb, arg);
+	hidden_inode = itohi_index(root_inode, arg);
+
+	DPUT(hidden_dentry);
+	IPUT(hidden_inode);
+	mntput(hidden_mnt);
+
+	for (i = arg; i <= (sbend(sb) - 1); i++) {
+		set_branch_count(sb, i, branch_count(sb, i + 1));
+		set_stohiddenmnt_index(sb, i, stohiddenmnt_index(sb, i + 1));
+		set_stohs_index(sb, i, stohs_index(sb, i + 1));
+		set_branchperms(sb, i, branchperms(sb, i + 1));
+		set_dtohd_index(root_dentry, i,
+				dtohd_index(root_dentry, i + 1));
+		set_itohi_index(root_inode, i, itohi_index(root_inode, i + 1));
+		stopd(sb)->usi_putmaps[pmindex]->map[i + 1] = i;
+	}
+
+	set_dtohd_index(root_dentry, sbend(sb), NULL);
+	set_itohi_index(root_inode, sbend(sb), NULL);
+	set_stohiddenmnt_index(sb, sbend(sb), NULL);
+	set_stohs_index(sb, sbend(sb), NULL);
+
+	//XXX: Place check for inode maps and removal of branch here
+
+	stopd(sb)->b_end--;
+	set_dbend(root_dentry, dbend(root_dentry) - 1);
+	dtopd(root_dentry)->udi_bcount--;
+	itopd(root_inode)->b_end--;
+
+	atomic_set(&dtopd(root_dentry)->udi_generation, gen);
+	atomic_set(&itopd(root_inode)->uii_generation, gen);
+
+	fixputmaps(sb);
+
+	/* This doesn't open a file, so we might have to free the map here. */
+	if (atomic_read(&stopd(sb)->usi_putmaps[pmindex]->count) == 0) {
+		KFREE(stopd(sb)->usi_putmaps[pmindex]);
+		stopd(sb)->usi_putmaps[pmindex] = NULL;
+	}
+
+      out:
+	unlock_dentry(sb->s_root);
+	print_exit_status(err);
+
+	return err;
+}
+
+int unionfs_ioctl_rdwrbranch(struct inode *inode, unsigned int cmd,
+			     unsigned long arg)
+{
+	int err;
+	struct unionfs_rdwrbranch_args *rdwrargs = NULL;
+	int gen;
+
+	print_entry_location();
+
+	unionfs_write_lock(inode->i_sb);
+	lock_dentry(inode->i_sb->s_root);
+
+	if ((err = newputmap(inode->i_sb)))
+		goto out;
+
+	err = -ENOMEM;
+	rdwrargs = KMALLOC(sizeof(struct unionfs_rdwrbranch_args), GFP_KERNEL);
+	if (!rdwrargs)
+		goto out;
+
+	err = -EFAULT;
+	if (copy_from_user
+	    (rdwrargs, (const void __user *)arg,
+	     sizeof(struct unionfs_rdwrbranch_args)))
+		goto out;
+
+	err = -EINVAL;
+	if (rdwrargs->rwb_branch < 0
+	    || (rdwrargs->rwb_branch > (sbend(inode->i_sb) + 1)))
+		goto out;
+	if (rdwrargs->rwb_perms & ~(MAY_READ | MAY_WRITE | MAY_NFSRO))
+		goto out;
+	if (!(rdwrargs->rwb_perms & MAY_READ))
+		goto out;
+
+	set_branchperms(inode->i_sb, rdwrargs->rwb_branch, rdwrargs->rwb_perms);
+
+	atomic_inc(&stopd(inode->i_sb)->usi_generation);
+	gen = atomic_read(&stopd(inode->i_sb)->usi_generation);
+	atomic_set(&dtopd(inode->i_sb->s_root)->udi_generation, gen);
+	atomic_set(&itopd(inode->i_sb->s_root->d_inode)->uii_generation, gen);
+
+	err = 0;
+
+      out:
+	unlock_dentry(inode->i_sb->s_root);
+	unionfs_write_unlock(inode->i_sb);
+	KFREE(rdwrargs);
+
+	print_exit_status(err);
+
+	return err;
+}
+
+int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	int err = 0;
+	fd_set branchlist;
+
+	int bstart = 0, bend = 0, bindex = 0;
+	struct dentry *dentry, *hidden_dentry;
+
+	print_entry_location();
+
+	dentry = file->f_dentry;
+	lock_dentry(dentry);
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	FD_ZERO(&branchlist);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (hidden_dentry->d_inode)
+			FD_SET(bindex, &branchlist);
+	}
+
+	err = copy_to_user((void __user *)arg, &branchlist, sizeof(fd_set));
+	if (err) {
+		err = -EFAULT;
+		goto out;
+	}
+
+      out:
+	unlock_dentry(dentry);
+	err = err < 0 ? err : bend;
+	print_exit_status(err);
+	return (err);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/commonfops.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/commonfops.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,716 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: commonfops.c,v 1.56 2006/02/15 09:07:28 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* We only need this function here, but it could get promoted to unionfs.h, if
+ * other things need a generation specific branch putting function. */
+static inline void branchput_gen(int generation, struct super_block *sb,
+				 int index)
+{
+	struct putmap *putmap;
+
+	if (generation == atomic_read(&stopd(sb)->usi_generation)) {
+		branchput(sb, index);
+		return;
+	}
+
+	BUG_ON(stopd(sb)->usi_firstputmap > generation);
+	BUG_ON(stopd(sb)->usi_lastputmap < generation);
+
+	putmap =
+	    stopd(sb)->usi_putmaps[generation - stopd(sb)->usi_firstputmap];
+	BUG_ON(index < 0);
+	BUG_ON(index > putmap->bend);
+	BUG_ON(putmap->map[index] < 0);
+	branchput(sb, putmap->map[index]);
+	if (atomic_dec_and_test(&putmap->count)) {
+		stopd(sb)->usi_putmaps[generation - stopd(sb)->usi_firstputmap]
+		    = NULL;
+		fist_dprint(8, "Freeing putmap %d.\n", generation);
+		KFREE(putmap);
+	}
+}
+
+static char *get_random_name(int size, unsigned char *name)
+{
+	int i;
+	int j;
+	unsigned char *tmpbuf = NULL;
+
+	if (size <= WHLEN)
+		return NULL;
+
+	if (!name)
+		name = KMALLOC(size + 1, GFP_KERNEL);
+	if (!name) {
+		name = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	strncpy(name, WHPFX, WHLEN);
+
+	tmpbuf = KMALLOC(size, GFP_KERNEL);
+	if (!tmpbuf) {
+		KFREE(name);
+		name = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	get_random_bytes((void *)tmpbuf, (size - 3) / 2);
+
+	j = WHLEN;
+	i = 0;
+	while ((i < (size - 3) / 2) && (j < size)) {
+		/* get characters in the 0-9, A-F range */
+
+		name[j] =
+		    (tmpbuf[i] % 16) <
+		    10 ? (tmpbuf[i] % 16) + '0' : (tmpbuf[i] % 16) + 'a';
+		j++;
+		if (j == size)
+			break;
+		name[j] =
+		    (tmpbuf[i] >> 4) <
+		    10 ? (tmpbuf[i] >> 4) + '0' : (tmpbuf[i] >> 4) + 'a';
+		j++;
+
+		i++;
+	}
+
+	name[size] = '\0';
+
+      out:
+	KFREE(tmpbuf);
+	return (name);
+
+}
+
+static int copyup_deleted_file(struct file *file, struct dentry *dentry,
+			       int bstart, int bindex)
+{
+	int attempts = 0;
+	int err;
+	int exists = 1;
+	char *name = NULL;
+	struct dentry *tmp_dentry = NULL;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+
+	print_entry_location();
+
+	/* Try five times to get a unique file name, fail after that.  Five is
+	 * simply a magic number, because we shouldn't try forever.  */
+	while (exists) {
+		/* The first call allocates, the subsequent ones reuse. */
+		name = get_random_name(UNIONFS_TMPNAM_LEN, name);
+		err = -ENOMEM;
+		if (!name)
+			goto out;
+
+		hidden_dentry = dtohd_index(dentry, bstart);
+
+		tmp_dentry = LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+					    UNIONFS_TMPNAM_LEN);
+		err = PTR_ERR(tmp_dentry);
+		if (IS_ERR(tmp_dentry))
+			goto out;
+		exists = tmp_dentry->d_inode ? 1 : 0;
+		DPUT(tmp_dentry);
+
+		err = -EEXIST;
+		if (++attempts > 5)
+			goto out;
+	}
+
+	err = copyup_named_file(dentry->d_parent->d_inode, file, name, bstart,
+				bindex, file->f_dentry->d_inode->i_size);
+	if (err)
+		goto out;
+
+	/* bring it to the same state as an unlinked file */
+	hidden_dentry = dtohd_index(dentry, dbstart(dentry));
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+	err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
+	unlock_dir(hidden_dir_dentry);
+
+      out:
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_file_revalidate(struct file *file, int willwrite)
+{
+	struct super_block *sb;
+	struct dentry *dentry;
+	int sbgen, fgen, dgen;
+	int bindex, bstart, bend;
+	struct file *hidden_file;
+	struct dentry *hidden_dentry;
+	int size;
+
+	int err = 0;
+
+	print_entry(" file = %p", file);
+
+	dentry = file->f_dentry;
+	lock_dentry(dentry);
+	sb = dentry->d_sb;
+	unionfs_read_lock(sb);
+	if (!unionfs_d_revalidate(dentry, NULL) && !d_deleted(dentry)) {
+		err = -ESTALE;
+		goto out;
+	}
+	fist_print_dentry("file revalidate in", dentry);
+
+	sbgen = atomic_read(&stopd(sb)->usi_generation);
+	dgen = atomic_read(&dtopd(dentry)->udi_generation);
+	fgen = atomic_read(&ftopd(file)->ufi_generation);
+
+	BUG_ON(sbgen > dgen);
+
+	/* There are two cases we are interested in.  The first is if the
+	 * generation is lower than the super-block.  The second is if someone
+	 * has copied up this file from underneath us, we also need to refresh
+	 * things. */
+	if (!d_deleted(dentry) &&
+	    ((sbgen > fgen) || (dbstart(dentry) != fbstart(file)))) {
+		/* First we throw out the existing files. */
+		bstart = fbstart(file);
+		bend = fbend(file);
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			if (ftohf_index(file, bindex)) {
+				branchput_gen(fgen, dentry->d_sb, bindex);
+				fput(ftohf_index(file, bindex));
+			}
+		}
+
+		if (ftohf_ptr(file)) {
+			KFREE(ftohf_ptr(file));
+			ftohf_ptr(file) = NULL;
+		}
+
+		/* Now we reopen the file(s) as in unionfs_open. */
+		bstart = fbstart(file) = dbstart(dentry);
+		bend = fbend(file) = dbend(dentry);
+
+		size = sizeof(struct file *) * sbmax(sb);
+		ftohf_ptr(file) = KZALLOC(size, GFP_KERNEL);
+		if (!ftohf_ptr(file)) {
+			err = -ENOMEM;
+			goto out;
+		}
+
+		if (S_ISDIR(dentry->d_inode->i_mode)) {
+			/* We need to open all the files. */
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				hidden_dentry = dtohd_index(dentry, bindex);
+				if (!hidden_dentry)
+					continue;
+
+				DGET(hidden_dentry);
+				mntget(stohiddenmnt_index(sb, bindex));
+				branchget(sb, bindex);
+
+				hidden_file =
+				    DENTRY_OPEN(hidden_dentry,
+						stohiddenmnt_index(sb, bindex),
+						file->f_flags);
+				if (IS_ERR(hidden_file)) {
+					err = PTR_ERR(hidden_file);
+					goto out;
+				} else {
+					set_ftohf_index(file, bindex,
+							hidden_file);
+				}
+			}
+		} else {
+			/* We only open the highest priority branch. */
+			hidden_dentry = dtohd(dentry);
+			if (willwrite && IS_WRITE_FLAG(file->f_flags)
+			    && is_robranch(dentry)) {
+				for (bindex = bstart - 1; bindex >= 0; bindex--) {
+
+					err = copyup_file(dentry->
+							  d_parent->
+							  d_inode,
+							  file,
+							  bstart,
+							  bindex,
+							  file->
+							  f_dentry->
+							  d_inode->i_size);
+
+					if (!err)
+						break;
+					else
+						continue;
+
+				}
+				atomic_set(&ftopd(file)->ufi_generation,
+					   atomic_read(&itopd(dentry->d_inode)->
+						       uii_generation));
+				goto out;
+			}
+
+			DGET(hidden_dentry);
+			mntget(stohiddenmnt_index(sb, bstart));
+			branchget(sb, bstart);
+			hidden_file =
+			    DENTRY_OPEN(hidden_dentry,
+					stohiddenmnt_index(sb, bstart),
+					file->f_flags);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				goto out;
+			}
+			set_ftohf(file, hidden_file);
+			/* Fix up the position. */
+			hidden_file->f_pos = file->f_pos;
+
+			memcpy(&(hidden_file->f_ra), &(file->f_ra),
+			       sizeof(struct file_ra_state));
+		}
+		atomic_set(&ftopd(file)->ufi_generation,
+			   atomic_read(&itopd(dentry->d_inode)->
+				       uii_generation));
+	}
+
+	/* Copyup on the first write to a file on a readonly branch. */
+	if (willwrite && IS_WRITE_FLAG(file->f_flags)
+	    && !IS_WRITE_FLAG(ftohf(file)->f_flags) && is_robranch(dentry)) {
+		fist_dprint(3,
+			    "Doing delayed copyup of a read-write file on a read-only branch.\n");
+		bstart = fbstart(file);
+		bend = fbend(file);
+
+		BUG_ON(!S_ISREG(file->f_dentry->d_inode->i_mode));
+
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			if (!d_deleted(file->f_dentry)) {
+				err =
+				    copyup_file(dentry->d_parent->
+						d_inode, file, bstart,
+						bindex,
+						file->f_dentry->
+						d_inode->i_size);
+			} else {
+				err =
+				    copyup_deleted_file(file, dentry, bstart,
+							bindex);
+			}
+
+			if (!err)
+				break;
+			else
+				continue;
+
+		}
+		if (!err && (bstart > fbstart(file))) {
+			bend = fbend(file);
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				if (ftohf_index(file, bindex)) {
+					branchput(dentry->d_sb, bindex);
+					fput(ftohf_index(file, bindex));
+					set_ftohf_index(file, bindex, NULL);
+				}
+			}
+			fbend(file) = bend;
+		}
+	}
+
+      out:
+	fist_print_dentry("file revalidate out", dentry);
+	unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	int hidden_flags;
+	struct file *hidden_file = NULL;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *dentry = NULL;
+	int bindex = 0, bstart = 0, bend = 0;
+	int locked = 0;
+	int size;
+
+	print_entry_location();
+
+	ftopd_lhs(file) = KZALLOC(sizeof(struct unionfs_file_info), GFP_KERNEL);
+	if (!ftopd(file)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	fbstart(file) = -1;
+	fbend(file) = -1;
+	atomic_set(&ftopd(file)->ufi_generation,
+		   atomic_read(&itopd(inode)->uii_generation));
+
+	size = sizeof(struct file *) * sbmax(inode->i_sb);
+	ftohf_ptr(file) = KZALLOC(size, GFP_KERNEL);
+	if (!ftohf_ptr(file)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	hidden_flags = file->f_flags;
+
+	dentry = file->f_dentry;
+	fist_dprint(8, "dentry to open is %p\n", dentry);
+	lock_dentry(dentry);
+	unionfs_read_lock(inode->i_sb);
+	locked = 1;
+
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	/* increment to show the kind of open, so that we can
+	 * flush appropriately
+	 */
+	atomic_inc(&itopd(dentry->d_inode)->uii_totalopens);
+
+	/* open all directories and make the unionfs file struct point to these hidden file structs */
+	if (S_ISDIR(inode->i_mode)) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_dentry = dtohd_index(dentry, bindex);
+			if (!hidden_dentry)
+				continue;
+
+			DGET(hidden_dentry);
+			mntget(stohiddenmnt_index(inode->i_sb, bindex));
+			hidden_file =
+			    DENTRY_OPEN(hidden_dentry,
+					stohiddenmnt_index(inode->i_sb, bindex),
+					hidden_flags);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				goto out;
+			}
+
+			set_ftohf_index(file, bindex, hidden_file);
+			/* The branchget goes after the open, because otherwise
+			 * we would miss the reference on release. */
+			branchget(inode->i_sb, bindex);
+		}
+	} else {
+		/* open a file */
+		hidden_dentry = dtohd(dentry);
+
+		/* check for the permission for hidden file.  If the error is COPYUP_ERR,
+		 * copyup the file.
+		 */
+		if (hidden_dentry->d_inode && is_robranch(dentry)) {
+			/* if the open will change the file, copy it up otherwise defer it. */
+			if (hidden_flags & O_TRUNC) {
+				int size = 0;
+
+				err = -EROFS;
+				/* copyup the file */
+				for (bindex = bstart - 1; bindex >= 0; bindex--) {
+					err =
+					    copyup_file(dentry->
+							d_parent->
+							d_inode, file,
+							bstart, bindex, size);
+					if (!err) {
+						break;
+					}
+				}
+				goto out;
+			} else {
+				hidden_flags &= ~(OPEN_WRITE_FLAGS);
+			}
+		}
+
+		DGET(hidden_dentry);
+		/* dentry_open will decrement mnt refcnt if err.
+		 * otherwise fput() will do an mntput() for us upon file close.
+		 */
+		mntget(stohiddenmnt_index(inode->i_sb, bstart));
+		hidden_file = DENTRY_OPEN(hidden_dentry,
+					  stohiddenmnt_index(inode->i_sb,
+							     bstart),
+					  hidden_flags);
+		if (IS_ERR(hidden_file)) {
+			err = PTR_ERR(hidden_file);
+			goto out;
+		} else {
+			set_ftohf(file, hidden_file);
+			branchget(inode->i_sb, bstart);
+		}
+	}
+
+      out:
+	/* freeing the allocated resources, and fput the opened files */
+	if (err < 0 && ftopd(file)) {
+		if (!locked)
+			unionfs_read_lock(file->f_dentry->d_sb);
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_file = ftohf_index(file, bindex);
+			if (hidden_file) {
+				branchput(file->f_dentry->d_sb, bindex);
+				/* fput calls dput for hidden_dentry */
+				fput(hidden_file);
+			}
+		}
+		if (!locked)
+			unionfs_read_unlock(file->f_dentry->d_sb);
+		KFREE(ftohf_ptr(file));
+		KFREE(ftopd(file));
+	}
+
+	fist_print_file("OUT: unionfs_open", file);
+
+	if (locked) {
+		unlock_dentry(dentry);
+		unionfs_read_unlock(inode->i_sb);
+	}
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_file_release(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+	int bindex, bstart, bend;
+	int fgen;
+
+	print_entry_location();
+
+	fist_checkinode(inode, "unionfs_release");
+
+	/* fput all the hidden files */
+	fgen = atomic_read(&ftopd(file)->ufi_generation);
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_file = ftohf_index(file, bindex);
+
+		if (hidden_file) {
+			fput(hidden_file);
+			unionfs_read_lock(inode->i_sb);
+			branchput_gen(fgen, inode->i_sb, bindex);
+			unionfs_read_unlock(inode->i_sb);
+		}
+	}
+	KFREE(ftohf_ptr(file));
+
+	if (ftopd(file)->rdstate) {
+		ftopd(file)->rdstate->uds_access = jiffies;
+		fist_dprint(1, "Saving rdstate with cookie %u [%d.%lld]\n",
+			    ftopd(file)->rdstate->uds_cookie,
+			    ftopd(file)->rdstate->uds_bindex,
+			    (long long)ftopd(file)->rdstate->uds_dirpos);
+		spin_lock(&itopd(inode)->uii_rdlock);
+		itopd(inode)->uii_rdcount++;
+		list_add_tail(&ftopd(file)->rdstate->uds_cache,
+			      &itopd(inode)->uii_readdircache);
+		mark_inode_dirty(inode);
+		spin_unlock(&itopd(inode)->uii_rdlock);
+		ftopd(file)->rdstate = NULL;
+	}
+	KFREE(ftopd(file));
+
+	fist_checkinode(inode, "post unionfs_release");
+
+	print_exit_status(err);
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+long unionfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#else
+int unionfs_ioctl(struct inode *unused, struct file *file,
+		  unsigned int cmd, unsigned long arg)
+#endif
+{
+	long err = 0;		/* don't fail by default */
+	struct file *hidden_file = NULL;
+	int val;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	/* check if asked for local commands */
+	switch (cmd) {
+	case FIST_IOCTL_GET_DEBUG_VALUE:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		val = fist_get_debug_value();
+		err = put_user(val, (int __user *)arg);
+		break;
+
+	case FIST_IOCTL_SET_DEBUG_VALUE:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = get_user(val, (int __user *)arg);
+		if (err)
+			break;
+		fist_dprint(6, "IOCTL SET: got arg %d\n", val);
+		if (val < 0 || val > 20) {
+			err = -EINVAL;
+			break;
+		}
+		fist_set_debug_value(val);
+		break;
+
+		/* add non-debugging fist ioctl's here */
+
+	case UNIONFS_IOCTL_BRANCH_COUNT:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = unionfs_ioctl_branchcount(file, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_INCGEN:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = unionfs_ioctl_incgen(file, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_ADDBRANCH:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err =
+		    unionfs_ioctl_addbranch(file->f_dentry->d_inode, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_RDWRBRANCH:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err =
+		    unionfs_ioctl_rdwrbranch(file->f_dentry->d_inode, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_QUERYFILE:
+		/* XXX: This should take the file. */
+		err = unionfs_ioctl_queryfile(file, cmd, arg);
+		break;
+
+	default:
+		hidden_file = ftohf(file);
+
+		err = security_file_ioctl(hidden_file, cmd, arg);
+		if (err)
+			goto out;
+		err = -ENOTTY;
+		if (!hidden_file || !hidden_file->f_op)
+			goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+		if (hidden_file->f_op->unlocked_ioctl) {
+			err =
+			    hidden_file->f_op->unlocked_ioctl(hidden_file, cmd,
+							      arg);
+		} else
+#endif
+		if (hidden_file->f_op->ioctl) {
+			lock_kernel();
+			err =
+			    hidden_file->f_op->ioctl(hidden_file->f_dentry->
+						     d_inode, hidden_file, cmd,
+						     arg);
+			unlock_kernel();
+		}
+	}			/* end of outer switch statement */
+
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+
+int unionfs_flush(struct file *file)
+{
+	int err = 0;		/* assume ok (see open.c:close_fp) */
+	struct file *hidden_file = NULL;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+	if (!atomic_dec_and_test
+	    (&itopd(file->f_dentry->d_inode)->uii_totalopens))
+		goto out;
+
+	lock_dentry(file->f_dentry);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_file = ftohf_index(file, bindex);
+
+		if (hidden_file && hidden_file->f_op
+		    && hidden_file->f_op->flush) {
+			err = hidden_file->f_op->flush(hidden_file);
+			if (err)
+				goto out_lock;
+			/* This was earlier done in the unlink_all function in unlink.c */
+			/* if there are no more references to the dentry, dput it */
+			if (d_deleted(file->f_dentry)) {
+				DPUT(dtohd_index(file->f_dentry, bindex));
+				set_dtohd_index(file->f_dentry, bindex, NULL);
+			}
+		}
+
+	}
+
+      out_lock:
+	unlock_dentry(file->f_dentry);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/copyup.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/copyup.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,749 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York*
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: copyup.c,v 1.65 2006/02/08 21:33:40 dquigley Exp $
+ */
+
+#include "unionfs.h"
+
+/*Not Working Yet*/
+static int copyup_xattrs(struct dentry *old_hidden_dentry,
+			 struct dentry *new_hidden_dentry)
+{
+	int err = 0;
+	ssize_t list_size = -1;
+	char *name_list = NULL;
+	char *attr_value = NULL;
+	char *name_list_orig = NULL;
+
+	print_entry_location();
+
+	if (!old_hidden_dentry->d_inode->i_op->getxattr ||
+	    !old_hidden_dentry->d_inode->i_op->listxattr ||
+	    !new_hidden_dentry->d_inode->i_op->setxattr) {
+		err = -ENOTSUPP;
+		goto out;
+	}
+
+	list_size =
+	    old_hidden_dentry->d_inode->i_op->listxattr(old_hidden_dentry, NULL,
+							0);
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	name_list = xattr_alloc(list_size + 1, XATTR_LIST_MAX);
+	if (!name_list || IS_ERR(name_list)) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+	list_size =
+	    old_hidden_dentry->d_inode->i_op->listxattr(old_hidden_dentry,
+							name_list, list_size);
+	attr_value = xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);
+	if (!attr_value || IS_ERR(attr_value)) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+	name_list_orig = name_list;
+	while (*name_list) {
+		ssize_t size;
+		down(&old_hidden_dentry->d_inode->i_sem);
+		err = security_inode_getxattr(old_hidden_dentry, name_list);
+		if (err)
+			size = err;
+		else
+			size =
+			    old_hidden_dentry->d_inode->i_op->
+			    getxattr(old_hidden_dentry, name_list, attr_value,
+				     XATTR_SIZE_MAX);
+		up(&old_hidden_dentry->d_inode->i_sem);
+		if (size < 0) {
+			err = size;
+			goto out;
+		}
+
+		if (size > XATTR_SIZE_MAX) {
+			err = -E2BIG;
+			goto out;
+		}
+
+		down(&new_hidden_dentry->d_inode->i_sem);
+
+		err =
+		    security_inode_setxattr(old_hidden_dentry, name_list,
+					    attr_value, size, 0);
+
+		if (!err) {
+			err =
+			    new_hidden_dentry->d_inode->i_op->
+			    setxattr(new_hidden_dentry, name_list, attr_value,
+				     size, 0);
+			if (!err)
+				security_inode_post_setxattr(old_hidden_dentry,
+							     name_list,
+							     attr_value, size,
+							     0);
+		}
+		up(&new_hidden_dentry->d_inode->i_sem);
+
+		if (err < 0)
+			goto out;
+		name_list += strlen(name_list) + 1;
+	}
+      out:
+	name_list = name_list_orig;
+
+	if (name_list)
+		xattr_free(name_list, list_size + 1);
+	if (attr_value)
+		xattr_free(attr_value, XATTR_SIZE_MAX);
+	/* It is no big deal if this fails, we just roll with the punches. */
+	if (err == -ENOTSUPP)
+		err = 0;
+	return err;
+}
+
+/* Determine the mode based on the copyup flags, and the existing dentry. */
+static int copyup_permissions(struct super_block *sb,
+			      struct dentry *old_hidden_dentry,
+			      struct dentry *new_hidden_dentry)
+{
+	struct iattr newattrs;
+	int err;
+
+	print_entry_location();
+
+	newattrs.ia_atime = old_hidden_dentry->d_inode->i_atime;
+	newattrs.ia_mtime = old_hidden_dentry->d_inode->i_mtime;
+	newattrs.ia_ctime = old_hidden_dentry->d_inode->i_ctime;
+	newattrs.ia_valid = ATTR_CTIME | ATTR_ATIME | ATTR_MTIME |
+	    ATTR_ATIME_SET | ATTR_MTIME_SET;
+	if (IS_SET(sb, COPYUP_CURRENT_USER)) {
+		/* current file permission */
+		newattrs.ia_mode = ~current->fs->umask & S_IRWXUGO;
+		newattrs.ia_valid |= ATTR_FORCE | ATTR_MODE;
+	} else {
+		/* original mode of old file */
+		newattrs.ia_mode = old_hidden_dentry->d_inode->i_mode;
+		newattrs.ia_gid = old_hidden_dentry->d_inode->i_gid;
+		newattrs.ia_uid = old_hidden_dentry->d_inode->i_uid;
+		newattrs.ia_valid |=
+		    ATTR_FORCE | ATTR_GID | ATTR_UID | ATTR_MODE;
+	}
+	if (newattrs.ia_valid & ATTR_MODE) {
+		newattrs.ia_mode =
+		    (newattrs.ia_mode & S_IALLUGO) | (old_hidden_dentry->
+						      d_inode->
+						      i_mode & ~S_IALLUGO);
+	}
+
+	err = notify_change(new_hidden_dentry, &newattrs);
+
+	print_exit_status(err);
+	return err;
+}
+
+int copyup_dentry(struct inode *dir, struct dentry *dentry,
+		  int bstart, int new_bindex,
+		  struct file **copyup_file, loff_t len)
+{
+	return copyup_named_dentry(dir, dentry, bstart, new_bindex,
+				   dentry->d_name.name,
+				   dentry->d_name.len, copyup_file, len);
+}
+
+int copyup_named_dentry(struct inode *dir, struct dentry *dentry,
+			int bstart, int new_bindex, const char *name,
+			int namelen, struct file **copyup_file, loff_t len)
+{
+	struct dentry *new_hidden_dentry;
+	struct dentry *old_hidden_dentry = NULL;
+	struct super_block *sb;
+	struct file *input_file = NULL;
+	struct file *output_file = NULL;
+	ssize_t read_bytes, write_bytes;
+	mm_segment_t old_fs;
+	int err = 0;
+	char *buf;
+	int old_bindex;
+	int got_branch_input = -1;
+	int got_branch_output = -1;
+	int old_bstart;
+	int old_bend;
+	int size = len;
+	struct dentry *new_hidden_parent_dentry = NULL;
+	mm_segment_t oldfs;
+	char *symbuf = NULL;
+	uid_t saved_uid = current->fsuid;
+	gid_t saved_gid = current->fsgid;
+
+	print_entry_location();
+	verify_locked(dentry);
+	fist_print_dentry("IN: copyup_named_dentry", dentry);
+
+	old_bindex = bstart;
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	BUG_ON(new_bindex < 0);
+	BUG_ON(new_bindex >= old_bindex);
+
+	sb = dir->i_sb;
+
+	unionfs_read_lock(sb);
+
+	if ((err = is_robranch_super(sb, new_bindex)))
+		goto out;
+
+	/* Create the directory structure above this dentry. */
+	new_hidden_dentry = create_parents_named(dir, dentry, name, new_bindex);
+	if (IS_ERR(new_hidden_dentry)) {
+		err = PTR_ERR(new_hidden_dentry);
+		goto out;
+	}
+
+	fist_print_generic_dentry("Copyup Object", new_hidden_dentry);
+
+	/* Now we actually create the object. */
+	old_hidden_dentry = dtohd_index(dentry, old_bindex);
+	DGET(old_hidden_dentry);
+
+	/* For symlinks, we must read the link before we lock the directory. */
+	if (S_ISLNK(old_hidden_dentry->d_inode->i_mode)) {
+
+		symbuf = KMALLOC(PATH_MAX, GFP_KERNEL);
+		if (!symbuf) {
+			err = -ENOMEM;
+			goto copyup_readlink_err;
+		}
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		err =
+		    old_hidden_dentry->d_inode->i_op->
+		    readlink(old_hidden_dentry, (char __user *)symbuf,
+			     PATH_MAX);
+		set_fs(oldfs);
+		if (err < 0)
+			goto copyup_readlink_err;
+		symbuf[err] = '\0';
+	}
+
+	/* Now we lock the parent, and create the object in the new branch. */
+	new_hidden_parent_dentry = lock_parent(new_hidden_dentry);
+	current->fsuid = new_hidden_parent_dentry->d_inode->i_uid;
+	current->fsgid = new_hidden_parent_dentry->d_inode->i_gid;
+	if (S_ISDIR(old_hidden_dentry->d_inode->i_mode)) {
+		err = vfs_mkdir(new_hidden_parent_dentry->d_inode,
+				new_hidden_dentry, S_IRWXU);
+	} else if (S_ISLNK(old_hidden_dentry->d_inode->i_mode)) {
+		err = vfs_symlink(new_hidden_parent_dentry->d_inode,
+				  new_hidden_dentry, symbuf, S_IRWXU);
+	} else if (S_ISBLK(old_hidden_dentry->d_inode->i_mode)
+		   || S_ISCHR(old_hidden_dentry->d_inode->i_mode)
+		   || S_ISFIFO(old_hidden_dentry->d_inode->i_mode)
+		   || S_ISSOCK(old_hidden_dentry->d_inode->i_mode)) {
+		err = vfs_mknod(new_hidden_parent_dentry->d_inode,
+				new_hidden_dentry,
+				old_hidden_dentry->d_inode->i_mode,
+				old_hidden_dentry->d_inode->i_rdev);
+	} else if (S_ISREG(old_hidden_dentry->d_inode->i_mode)) {
+		err = vfs_create(new_hidden_parent_dentry->d_inode,
+				 new_hidden_dentry, S_IRWXU, NULL);
+	} else {
+		char diemsg[100];
+		snprintf(diemsg, sizeof(diemsg), "Unknown inode type %d\n",
+			 old_hidden_dentry->d_inode->i_mode);
+		printk(KERN_ERR "%s\n", diemsg);
+		BUG();
+	}
+	current->fsuid = saved_uid;
+	current->fsgid = saved_gid;
+      copyup_readlink_err:
+	KFREE(symbuf);
+	if (err) {
+		/* get rid of the hidden dentry and all its traces */
+		DPUT(new_hidden_dentry);
+		set_dtohd_index(dentry, new_bindex, NULL);
+		set_dbstart(dentry, old_bstart);
+		set_dbend(dentry, old_bend);
+		goto out_dir;
+	}
+#ifdef UNIONFS_IMAP
+	if (stopd(sb)->usi_persistent) {
+		err = write_uin(dentry->d_sb, dentry->d_inode->i_ino,
+				new_bindex, new_hidden_dentry->d_inode->i_ino);
+		if (err)
+			goto out_dir;
+	}
+#endif
+	/* We actually copyup the file here. */
+	if (S_ISREG(old_hidden_dentry->d_inode->i_mode)) {
+		mntget(stohiddenmnt_index(sb, old_bindex));
+		branchget(sb, old_bindex);
+		got_branch_input = old_bindex;
+		input_file =
+		    DENTRY_OPEN(old_hidden_dentry,
+				stohiddenmnt_index(sb, old_bindex), O_RDONLY);
+		if (IS_ERR(input_file)) {
+			err = PTR_ERR(input_file);
+			goto out_dir;
+		}
+		if (!input_file->f_op || !input_file->f_op->read) {
+			err = -EINVAL;
+			goto out_dir;
+		}
+
+		/* copy the new file */
+		DGET(new_hidden_dentry);
+		mntget(stohiddenmnt_index(sb, new_bindex));
+		branchget(sb, new_bindex);
+		got_branch_output = new_bindex;
+		output_file =
+		    DENTRY_OPEN(new_hidden_dentry,
+				stohiddenmnt_index(sb, new_bindex), O_WRONLY);
+		if (IS_ERR(output_file)) {
+			err = PTR_ERR(output_file);
+			goto out_dir;
+		}
+		if (!output_file->f_op || !output_file->f_op->write) {
+			err = -EINVAL;
+			goto out_dir;
+		}
+
+		/* allocating a buffer */
+		buf = (char *)KMALLOC(PAGE_SIZE, GFP_KERNEL);
+		if (!buf) {
+			err = -ENOMEM;
+			goto out_dir;
+		}
+
+		/* now read PAGE_SIZE bytes from offset 0 in a loop */
+		old_fs = get_fs();
+
+		input_file->f_pos = 0;
+		output_file->f_pos = 0;
+
+		err = 0;	// reset error just in case
+		set_fs(KERNEL_DS);
+		do {
+			if (len >= PAGE_SIZE)
+				size = PAGE_SIZE;
+			else if ((len < PAGE_SIZE) && (len > 0))
+				size = len;
+
+			len -= PAGE_SIZE;
+
+			read_bytes =
+			    input_file->f_op->read(input_file,
+						   (char __user *)buf, size,
+						   &input_file->f_pos);
+			if (read_bytes <= 0) {
+				err = read_bytes;
+				break;
+			}
+
+			write_bytes =
+			    output_file->f_op->write(output_file,
+						     (char __user *)buf,
+						     read_bytes,
+						     &output_file->f_pos);
+			if (write_bytes < 0 || (write_bytes < read_bytes)) {
+				err = write_bytes;
+				break;
+			}
+		} while ((read_bytes > 0) && (len > 0));
+		set_fs(old_fs);
+		KFREE(buf);
+
+		if (err) {
+			/* copyup failed, because we ran out of space or quota,
+			 * or something else happened so let's unlink; we don't
+			 * really care about the return value of vfs_unlink */
+			vfs_unlink(new_hidden_parent_dentry->d_inode,
+				   new_hidden_dentry);
+
+			goto out_dir;
+		}
+	}
+
+	/* Set permissions. */
+	if ((err =
+	     copyup_permissions(sb, old_hidden_dentry, new_hidden_dentry)))
+		goto out_dir;
+	/* Selinux uses extended attributes for permissions. */
+	if ((err = copyup_xattrs(old_hidden_dentry, new_hidden_dentry)))
+		goto out_dir;
+
+	/* do not allow files getting deleted to be reinterposed */
+	if (!d_deleted(dentry))
+		unionfs_reinterpose(dentry);
+
+      out_dir:
+	if (new_hidden_parent_dentry)
+		unlock_dir(new_hidden_parent_dentry);
+
+      out:
+	if (input_file && !IS_ERR(input_file)) {
+		fput(input_file);
+	} else {
+		/* since input file was not opened, we need to explicitly
+		 * dput the old_hidden_dentry
+		 */
+		DPUT(old_hidden_dentry);
+	}
+
+	/* in any case, we have to branchput */
+	if (got_branch_input >= 0)
+		branchput(sb, got_branch_input);
+
+	if (output_file) {
+		if (copyup_file && !err) {
+			*copyup_file = output_file;
+		} else {
+			/* close the file if there was no error, or if we ran
+			 * out of space in which case we unlinked the file */
+			if (!IS_ERR(output_file))
+				fput(output_file);
+			branchput(sb, got_branch_output);
+		}
+	}
+
+	unionfs_read_unlock(sb);
+
+	fist_print_dentry("OUT: copyup_dentry", dentry);
+	fist_print_inode("OUT: copyup_dentry", dentry->d_inode);
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function creates a copy of a file represented by 'file' which currently
+ * resides in branch 'bstart' to branch 'new_bindex.  The copy will be named
+ * "name".  */
+int copyup_named_file(struct inode *dir, struct file *file, char *name,
+		      int bstart, int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	print_entry_location();
+
+	err = copyup_named_dentry(dir, file->f_dentry, bstart,
+				  new_bindex, name, strlen(name), &output_file,
+				  len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		set_ftohf_index(file, new_bindex, output_file);
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function creates a copy of a file represented by 'file' which currently
+ * resides in branch 'bstart' to branch 'new_bindex.
+ */
+int copyup_file(struct inode *dir, struct file *file, int bstart,
+		int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	print_entry_location();
+
+	err = copyup_dentry(dir, file->f_dentry, bstart, new_bindex,
+			    &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		set_ftohf_index(file, new_bindex, output_file);
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function replicates the directory structure upto given dentry
+ * in the bindex branch. Can create directory structure recursively to the right
+ * also.
+ */
+struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+			      int bindex)
+{
+	struct dentry *hidden_dentry;
+
+	print_entry_location();
+	hidden_dentry =
+	    create_parents_named(dir, dentry, dentry->d_name.name, bindex);
+	print_exit_location();
+
+	return (hidden_dentry);
+}
+
+/* This function replicates the directory structure upto given dentry
+ * in the bindex branch.  */
+struct dentry *create_parents_named(struct inode *dir, struct dentry *dentry,
+				    const char *name, int bindex)
+{
+	int err;
+	struct dentry *child_dentry;
+	struct dentry *parent_dentry;
+	struct dentry *hidden_parent_dentry = NULL;
+	struct dentry *hidden_dentry = NULL;
+	const char *childname;
+	unsigned int childnamelen;
+
+	int old_kmalloc_size;
+	int kmalloc_size;
+	int num_dentry;
+	int count;
+
+	int old_bstart;
+	int old_bend;
+	struct dentry **path = NULL;
+	struct dentry **tmp_path;
+	struct super_block *sb;
+#ifdef UNIONFS_IMAP
+	int persistent;
+#endif
+	print_entry_location();
+
+	verify_locked(dentry);
+
+	/* There is no sense allocating any less than the minimum. */
+	kmalloc_size = malloc_sizes[0].cs_size;
+	num_dentry = kmalloc_size / sizeof(struct dentry *);
+
+	if ((err = is_robranch_super(dir->i_sb, bindex))) {
+		hidden_dentry = ERR_PTR(err);
+		goto out;
+	}
+
+	fist_print_dentry("IN: create_parents_named", dentry);
+	fist_dprint(8, "name = %s\n", name);
+
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	hidden_dentry = ERR_PTR(-ENOMEM);
+	path = (struct dentry **)KZALLOC(kmalloc_size, GFP_KERNEL);
+	if (!path)
+		goto out;
+
+	/* assume the negative dentry of unionfs as the parent dentry */
+	parent_dentry = dentry;
+
+	count = 0;
+	/* This loop finds the first parent that exists in the given branch.
+	 * We start building the directory structure from there.  At the end
+	 * of the loop, the following should hold:
+	 *      child_dentry is the first nonexistent child
+	 *      parent_dentry is the first existent parent
+	 *      path[0] is the = deepest child
+	 *      path[count] is the first child to create
+	 */
+	do {
+		child_dentry = parent_dentry;
+
+		/* find the parent directory dentry in unionfs */
+		parent_dentry = child_dentry->d_parent;
+		lock_dentry(parent_dentry);
+
+		/* find out the hidden_parent_dentry in the given branch */
+		hidden_parent_dentry = dtohd_index(parent_dentry, bindex);
+
+		/* store the child dentry */
+		path[count++] = child_dentry;
+		if (count == num_dentry) {
+			old_kmalloc_size = kmalloc_size;
+			kmalloc_size *= 2;
+			num_dentry = kmalloc_size / sizeof(struct dentry *);
+
+			tmp_path =
+			    (struct dentry **)KZALLOC(kmalloc_size, GFP_KERNEL);
+			if (!tmp_path) {
+				hidden_dentry = ERR_PTR(-ENOMEM);
+				goto out;
+			}
+			memcpy(tmp_path, path, old_kmalloc_size);
+			KFREE(path);
+			path = tmp_path;
+			tmp_path = NULL;
+		}
+
+	} while (!hidden_parent_dentry);
+	count--;
+
+	sb = dentry->d_sb;
+#ifdef UNIONFS_IMAP
+	persistent = stopd(sb)->usi_persistent;
+#endif
+	/* This is basically while(child_dentry != dentry).  This loop is
+	 * horrible to follow and should be replaced with cleaner code. */
+	while (1) {
+		// get hidden parent dir in the current branch
+		hidden_parent_dentry = dtohd_index(parent_dentry, bindex);
+		unlock_dentry(parent_dentry);
+
+		// init the values to lookup
+		childname = child_dentry->d_name.name;
+		childnamelen = child_dentry->d_name.len;
+
+		if (child_dentry != dentry) {
+			// lookup child in the underlying file system
+			hidden_dentry =
+			    LOOKUP_ONE_LEN(childname, hidden_parent_dentry,
+					   childnamelen);
+			if (IS_ERR(hidden_dentry))
+				goto out;
+		} else {
+			int loop_start;
+			int loop_end;
+			int new_bstart = -1;
+			int new_bend = -1;
+			int i;
+
+			/* is the name a whiteout of the childname ? */
+			//lookup the whiteout child in the underlying file system
+			hidden_dentry =
+			    LOOKUP_ONE_LEN(name, hidden_parent_dentry,
+					   strlen(name));
+			if (IS_ERR(hidden_dentry))
+				goto out;
+
+			/* Replace the current dentry (if any) with the new one. */
+			DPUT(dtohd_index(dentry, bindex));
+			set_dtohd_index(dentry, bindex, hidden_dentry);
+
+			loop_start =
+			    (old_bstart < bindex) ? old_bstart : bindex;
+			loop_end = (old_bend > bindex) ? old_bend : bindex;
+
+			/* This loop sets the bstart and bend for the new
+			 * dentry by traversing from left to right.
+			 * It also dputs all negative dentries except
+			 * bindex (the newly looked dentry
+			 */
+			for (i = loop_start; i <= loop_end; i++) {
+				if (!dtohd_index(dentry, i))
+					continue;
+
+				if (i == bindex) {
+					new_bend = i;
+					if (new_bstart < 0)
+						new_bstart = i;
+					continue;
+				}
+
+				if (!dtohd_index(dentry, i)->d_inode) {
+					DPUT(dtohd_index(dentry, i));
+					set_dtohd_index(dentry, i, NULL);
+				} else {
+					if (new_bstart < 0)
+						new_bstart = i;
+					new_bend = i;
+				}
+			}
+
+			if (new_bstart < 0)
+				new_bstart = bindex;
+			if (new_bend < 0)
+				new_bend = bindex;
+			set_dbstart(dentry, new_bstart);
+			set_dbend(dentry, new_bend);
+			break;
+		}
+
+		if (hidden_dentry->d_inode) {
+			/* since this already exists we dput to avoid
+			 * multiple references on the same dentry */
+			DPUT(hidden_dentry);
+		} else {
+			uid_t saved_uid = current->fsuid;
+			gid_t saved_gid = current->fsgid;
+
+			/* its a negative dentry, create a new dir */
+			hidden_parent_dentry = lock_parent(hidden_dentry);
+			current->fsuid = hidden_parent_dentry->d_inode->i_uid;
+			current->fsgid = hidden_parent_dentry->d_inode->i_gid;
+			err = vfs_mkdir(hidden_parent_dentry->d_inode,
+					hidden_dentry, S_IRWXUGO);
+			current->fsuid = saved_uid;
+			current->fsgid = saved_gid;
+			if (!err)
+				err = copyup_permissions
+				    (dir->i_sb, child_dentry, hidden_dentry);
+			unlock_dir(hidden_parent_dentry);
+			if (err) {
+				DPUT(hidden_dentry);
+				hidden_dentry = ERR_PTR(err);
+				goto out;
+			}
+#ifdef UNIONFS_IMAP
+			if (persistent) {
+				err = write_uin
+				    (sb, child_dentry->d_inode->i_ino,
+				     bindex, hidden_dentry->d_inode->i_ino);
+				if (err) {
+					DPUT(hidden_dentry);
+					hidden_dentry = ERR_PTR(err);
+					goto out;
+				}
+			}
+#endif
+			set_itohi_index(child_dentry->d_inode, bindex,
+					IGRAB(hidden_dentry->d_inode));
+			if (ibstart(child_dentry->d_inode) > bindex)
+				ibstart(child_dentry->d_inode) = bindex;
+			if (ibend(child_dentry->d_inode) < bindex)
+				ibend(child_dentry->d_inode) = bindex;
+
+			set_dtohd_index(child_dentry, bindex, hidden_dentry);
+			if (dbstart(child_dentry) > bindex)
+				set_dbstart(child_dentry, bindex);
+			if (dbend(child_dentry) < bindex)
+				set_dbend(child_dentry, bindex);
+		}
+
+		parent_dentry = child_dentry;
+		child_dentry = path[--count];
+	}
+      out:
+	KFREE(path);
+	fist_print_dentry("OUT: create_parents_named", dentry);
+	print_exit_pointer(hidden_dentry);
+	return hidden_dentry;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/dentry.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/dentry.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dentry.c,v 1.74 2006/02/13 00:18:40 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations added for "sparse" */
+extern int unionfs_d_revalidate_wrap(struct dentry *dentry,
+				     struct nameidata *nd);
+extern void unionfs_d_release(struct dentry *dentry);
+extern void unionfs_d_iput(struct dentry *dentry, struct inode *inode);
+
+/*
+ * THIS IS A BOOLEAN FUNCTION: returns 1 if valid, 0 otherwise.
+ */
+int unionfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+{
+	int valid = 1;		/* default is valid (1); invalid is 0. */
+	struct dentry *hidden_dentry;
+	int bindex, bstart, bend;
+	int sbgen, dgen;
+	int positive = 0;
+	int locked = 0;
+	int restart = 0;
+	int interpose_flag;
+
+	print_util_entry_location();
+
+      restart:
+	verify_locked(dentry);
+
+	/* if the dentry is unhashed, do NOT revalidate */
+	if (d_deleted(dentry)) {
+		fist_dprint(6, "unhashed dentry being revalidated: %*s\n",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out;
+	}
+
+	BUG_ON(dbstart(dentry) == -1);
+	if (dentry->d_inode)
+		positive = 1;
+	dgen = atomic_read(&dtopd(dentry)->udi_generation);
+	sbgen = atomic_read(&stopd(dentry->d_sb)->usi_generation);
+	/* If we are working on an unconnected dentry, then there is no
+	 * revalidation to be done, because this file does not exist within the
+	 * namespace, and Unionfs operates on the namespace, not data.
+	 */
+	if (sbgen != dgen) {
+		struct dentry *result;
+		int pdgen;
+
+		unionfs_read_lock(dentry->d_sb);
+		locked = 1;
+
+		/* The root entry should always be valid */
+		BUG_ON(IS_ROOT(dentry));
+
+		/* We can't work correctly if our parent isn't valid. */
+		pdgen = atomic_read(&dtopd(dentry->d_parent)->udi_generation);
+		if (!restart && (pdgen != sbgen)) {
+			unionfs_read_unlock(dentry->d_sb);
+			locked = 0;
+			/* We must be locked before our parent. */
+			if (!
+			    (dentry->d_parent->d_op->
+			     d_revalidate(dentry->d_parent, nd))) {
+				valid = 0;
+				goto out;
+			}
+			restart = 1;
+			goto restart;
+		}
+		BUG_ON(pdgen != sbgen);
+
+		/* Free the pointers for our inodes and this dentry. */
+		bstart = dbstart(dentry);
+		bend = dbend(dentry);
+		if (bstart >= 0) {
+			struct dentry *hidden_dentry;
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				hidden_dentry =
+				    dtohd_index_nocheck(dentry, bindex);
+				if (!hidden_dentry)
+					continue;
+				DPUT(hidden_dentry);
+			}
+		}
+		set_dbstart(dentry, -1);
+		set_dbend(dentry, -1);
+
+		interpose_flag = INTERPOSE_REVAL_NEG;
+		if (positive) {
+			interpose_flag = INTERPOSE_REVAL;
+			down(&dentry->d_inode->i_sem);
+			bstart = ibstart(dentry->d_inode);
+			bend = ibend(dentry->d_inode);
+			if (bstart >= 0) {
+				struct inode *hidden_inode;
+				for (bindex = bstart; bindex <= bend; bindex++) {
+					hidden_inode =
+					    itohi_index(dentry->d_inode,
+							bindex);
+					if (!hidden_inode)
+						continue;
+					IPUT(hidden_inode);
+				}
+			}
+			KFREE(itohi_ptr(dentry->d_inode));
+			itohi_ptr(dentry->d_inode) = NULL;
+			ibstart(dentry->d_inode) = -1;
+			ibend(dentry->d_inode) = -1;
+			up(&dentry->d_inode->i_sem);
+		}
+
+		result = unionfs_lookup_backend(dentry, interpose_flag);
+		if (result) {
+			if (IS_ERR(result)) {
+				valid = 0;
+				goto out;
+			}
+			/* current unionfs_lookup_backend() doesn't return
+			   a valid dentry */
+			DPUT(dentry);
+			dentry = result;
+		}
+
+		if (positive && itopd(dentry->d_inode)->uii_stale) {
+			make_stale_inode(dentry->d_inode);
+			d_drop(dentry);
+			valid = 0;
+			goto out;
+		}
+		goto out;
+	}
+
+	/* The revalidation must occur across all branches */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart == -1);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry || !hidden_dentry->d_op
+		    || !hidden_dentry->d_op->d_revalidate)
+			continue;
+
+		if (!hidden_dentry->d_op->d_revalidate(hidden_dentry, nd))
+			valid = 0;
+	}
+
+	if (!dentry->d_inode)
+		valid = 0;
+	if (valid)
+		fist_copy_attr_all(dentry->d_inode, itohi(dentry->d_inode));
+
+      out:
+	if (locked)
+		unionfs_read_unlock(dentry->d_sb);
+	fist_print_dentry("revalidate out", dentry);
+	print_util_exit_status(valid);
+	return valid;
+}
+
+int unionfs_d_revalidate_wrap(struct dentry *dentry, struct nameidata *nd)
+{
+	int err;
+
+	print_entry_location();
+	lock_dentry(dentry);
+
+	err = unionfs_d_revalidate(dentry, nd);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+void unionfs_d_release(struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+	/* There is no reason to lock the dentry, because we have the only
+	 * reference, but the printing functions verify that we have a lock
+	 * on the dentry before calling dbstart, etc. */
+	lock_dentry(dentry);
+	__fist_print_dentry("unionfs_d_release IN dentry", dentry, 0);
+
+	/* this could be a negative dentry, so check first */
+	if (!dtopd(dentry)) {
+		fist_dprint(6, "dentry without private data: %*s",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out;
+	} else if (dbstart(dentry) < 0) {
+		/* this is due to a failed lookup */
+		/* the failed lookup has a dtohd_ptr set to null,
+		   but this is a better check */
+		fist_dprint(6, "dentry without hidden dentries : %*s",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out_free;
+	}
+
+	/* Release all the hidden dentries */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	}
+	/* free private data (unionfs_dentry_info) here */
+	KFREE(dtohd_ptr(dentry));
+	dtohd_ptr(dentry) = NULL;
+      out_free:
+	/* No need to unlock it, because it is disappeared. */
+#ifdef TRACKLOCK
+	printk("DESTROYLOCK:%p\n", dentry);
+#endif
+	free_dentry_private_data(dtopd(dentry));
+	dtopd_lhs(dentry) = NULL;	/* just to be safe */
+      out:
+	print_exit_location();
+}
+
+/*
+ * we don't really need unionfs_d_iput, because dentry_iput will call iput() if
+ * unionfs_d_iput is not defined. We left this implemented for ease of
+ * tracing/debugging.
+ */
+void unionfs_d_iput(struct dentry *dentry, struct inode *inode)
+{
+	print_entry_location();
+	IPUT(inode);
+	print_exit_location();
+}
+
+struct dentry_operations unionfs_dops = {
+	.d_revalidate = unionfs_d_revalidate_wrap,
+	.d_release = unionfs_d_release,
+	.d_iput = unionfs_d_iput,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/dirfops.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/dirfops.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,331 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dirfops.c,v 1.22 2006/02/07 23:21:50 dquigley Exp $
+ */
+
+#include "unionfs.h"
+
+/* Make sure our rdstate is playing by the rules. */
+static void verify_rdstate_offset(struct unionfs_dir_state *rdstate)
+{
+	BUG_ON(rdstate->uds_offset >= DIREOF);
+	BUG_ON(rdstate->uds_cookie >= MAXRDCOOKIE);
+}
+
+struct unionfs_getdents_callback {
+	struct unionfs_dir_state *rdstate;
+	void *dirent;
+	int entries_written;
+	int filldir_called;
+	int filldir_error;
+	filldir_t filldir;
+	struct super_block *sb;
+};
+
+/* copied from generic filldir in fs/readir.c */
+static int unionfs_filldir(void *dirent, const char *name, int namelen,
+			   loff_t offset, ino_t ino, unsigned int d_type)
+{
+	struct unionfs_getdents_callback *buf =
+	    (struct unionfs_getdents_callback *)dirent;
+	struct filldir_node *found = NULL;
+	int err = 0;
+	int is_wh_entry = 0;
+
+	fist_dprint(9, "unionfs_filldir name=%*s\n", namelen, name);
+
+	buf->filldir_called++;
+
+	if ((namelen > WHLEN) && !strncmp(name, WHPFX, WHLEN)) {
+		name += WHLEN;
+		namelen -= WHLEN;
+		is_wh_entry = 1;
+	}
+
+	found = find_filldir_node(buf->rdstate, name, namelen);
+
+	if (found)
+		goto out;
+
+	/* if 'name' isn't a whiteout filldir it. */
+	if (!is_wh_entry) {
+		off_t pos = rdstate2offset(buf->rdstate);
+		ino_t unionfs_ino = ino;
+#ifdef UNIONFS_IMAP
+		if (stopd(buf->sb)->usi_persistent)
+			err = read_uin(buf->sb, buf->rdstate->uds_bindex,
+				       ino, O_CREAT, &unionfs_ino);
+#endif
+		if (!err) {
+			err = buf->filldir(buf->dirent, name, namelen, pos,
+					   unionfs_ino, d_type);
+			buf->rdstate->uds_offset++;
+			verify_rdstate_offset(buf->rdstate);
+		}
+	}
+	/* If we did fill it, stuff it in our hash, otherwise return an error */
+	if (err) {
+		buf->filldir_error = err;
+		goto out;
+	}
+	buf->entries_written++;
+	if ((err = add_filldir_node(buf->rdstate, name, namelen,
+				    buf->rdstate->uds_bindex, is_wh_entry)))
+		buf->filldir_error = err;
+
+      out:
+	return err;
+}
+
+static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+	struct inode *inode = NULL;
+	struct unionfs_getdents_callback buf;
+	struct unionfs_dir_state *uds;
+	int bend;
+	loff_t offset;
+
+	print_entry("file = %p, pos = %llx", file, file->f_pos);
+
+	fist_print_file("In unionfs_readdir()", file);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	inode = file->f_dentry->d_inode;
+	fist_checkinode(inode, "unionfs_readdir");
+
+	uds = ftopd(file)->rdstate;
+	if (!uds) {
+		if (file->f_pos == DIREOF) {
+			goto out;
+		} else if (file->f_pos > 0) {
+			uds = find_rdstate(inode, file->f_pos);
+			if (!uds) {
+				err = -ESTALE;
+				goto out;
+			}
+			ftopd(file)->rdstate = uds;
+		} else {
+			init_rdstate(file);
+			uds = ftopd(file)->rdstate;
+		}
+	}
+	bend = fbend(file);
+
+	while (uds->uds_bindex <= bend) {
+		hidden_file = ftohf_index(file, uds->uds_bindex);
+		if (!hidden_file) {
+			fist_dprint(7,
+				    "Incremented bindex to %d of %d,"
+				    " because hidden file is NULL.\n",
+				    uds->uds_bindex, bend);
+			uds->uds_bindex++;
+			uds->uds_dirpos = 0;
+			continue;
+		}
+
+		/* prepare callback buffer */
+		buf.filldir_called = 0;
+		buf.filldir_error = 0;
+		buf.entries_written = 0;
+		buf.dirent = dirent;
+		buf.filldir = filldir;
+		buf.rdstate = uds;
+		buf.sb = inode->i_sb;
+
+		/* Read starting from where we last left off. */
+		offset = vfs_llseek(hidden_file, uds->uds_dirpos, 0);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		fist_dprint(7, "calling readdir for %d.%lld (offset = %lld)\n",
+			    uds->uds_bindex, uds->uds_dirpos, offset);
+		err = vfs_readdir(hidden_file, unionfs_filldir, (void *)&buf);
+		fist_dprint(7,
+			    "readdir on %d.%lld = %d (entries written %d, filldir called %d)\n",
+			    uds->uds_bindex, (long long)uds->uds_dirpos, err,
+			    buf.entries_written, buf.filldir_called);
+		/* Save the position for when we continue. */
+
+		offset = vfs_llseek(hidden_file, 0, 1);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		uds->uds_dirpos = offset;
+
+		/* Copy the atime. */
+		fist_copy_attr_atime(inode, hidden_file->f_dentry->d_inode);
+
+		if (err < 0) {
+			goto out;
+		}
+
+		if (buf.filldir_error) {
+			break;
+		}
+
+		if (!buf.entries_written) {
+			uds->uds_bindex++;
+			uds->uds_dirpos = 0;
+		}
+	}
+
+	if (!buf.filldir_error && uds->uds_bindex >= bend) {
+		fist_dprint(3,
+			    "Discarding rdstate because readdir is over (hashsize = %d)\n",
+			    uds->uds_hashentries);
+		/* Save the number of hash entries for next time. */
+		itopd(inode)->uii_hashsize = uds->uds_hashentries;
+		free_rdstate(uds);
+		ftopd(file)->rdstate = NULL;
+		file->f_pos = DIREOF;
+	} else {
+		file->f_pos = rdstate2offset(uds);
+		fist_dprint(3, "rdstate now has a cookie of %u (err = %d)\n",
+			    uds->uds_cookie, err);
+	}
+
+      out:
+	fist_checkinode(inode, "post unionfs_readdir");
+	print_exit_status(err);
+	return err;
+}
+
+/* This is not meant to be a generic repositioning function.  If you do
+ * things that aren't supported, then we return EINVAL.
+ *
+ * What is allowed:
+ *  (1) seeking to the same position that you are currently at
+ *	This really has no effect, but returns where you are.
+ *  (2) seeking to the end of the file, if you've read everything
+ *	This really has no effect, but returns where you are.
+ *  (3) seeking to the beginning of the file
+ *	This throws out all state, and lets you begin again.
+ */
+static loff_t unionfs_dir_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct unionfs_dir_state *rdstate;
+	loff_t err;
+
+	print_entry(" file=%p, offset=0x%llx, origin = %d", file, offset,
+		    origin);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	rdstate = ftopd(file)->rdstate;
+
+	/* We let users seek to their current position, but not anywhere else. */
+	if (!offset) {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				free_rdstate(rdstate);
+				ftopd(file)->rdstate = NULL;
+			}
+			init_rdstate(file);
+			err = 0;
+			break;
+		case SEEK_CUR:
+			if (file->f_pos) {
+				if (file->f_pos == DIREOF)
+					err = DIREOF;
+				else
+					BUG_ON(file->f_pos !=
+					       rdstate2offset(rdstate));
+				err = file->f_pos;
+			} else {
+				err = 0;
+			}
+			break;
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	} else {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				if (offset == rdstate2offset(rdstate)) {
+					err = offset;
+				} else if (file->f_pos == DIREOF) {
+					err = DIREOF;
+				} else {
+					err = -EINVAL;
+				}
+			} else {
+				if ((rdstate =
+				     find_rdstate(file->f_dentry->d_inode,
+						  offset))) {
+					ftopd(file)->rdstate = rdstate;
+					err = rdstate->uds_offset;
+				} else {
+					err = -EINVAL;
+				}
+			}
+			break;
+		case SEEK_CUR:
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	}
+
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+
+/* Trimmed directory options, we shouldn't pass everything down since
+ * we don't want to operate on partial directories.
+ */
+struct file_operations unionfs_dir_fops = {
+	.llseek = unionfs_dir_llseek,
+	.read = generic_read_dir,
+	.readdir = unionfs_readdir,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+	.unlocked_ioctl = unionfs_ioctl,
+#endif
+	.open = unionfs_open,
+	.release = unionfs_file_release,
+	.flush = unionfs_flush,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/dirhelper.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/dirhelper.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,266 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dirhelper.c,v 1.27 2006/02/09 04:41:00 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* Delete all of the whiteouts in a given directory for rmdir. */
+int delete_whiteouts(struct dentry *dentry, int bindex,
+		     struct unionfs_dir_state *namelist)
+{
+	int err = 0;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *hidden_dentry;
+	struct super_block *sb;
+	char *name = NULL;
+
+	int i;
+	struct list_head *pos;
+	struct filldir_node *cursor;
+
+	print_entry_location();
+
+	sb = dentry->d_sb;
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+	BUG_ON(bindex < dbstart(dentry));
+	BUG_ON(bindex > dbend(dentry));
+
+	/* Find out hidden parent dentry */
+	hidden_dir_dentry = dtohd_index(dentry, bindex);
+	BUG_ON(!S_ISDIR(hidden_dir_dentry->d_inode->i_mode));
+
+	name = (char *)__get_free_page(GFP_KERNEL);
+	if (!name) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < namelist->uds_size; i++) {
+		list_for_each(pos, &namelist->uds_list[i]) {
+			cursor =
+			    list_entry(pos, struct filldir_node, file_list);
+			/* Only operate on whiteouts in this branch. */
+			if (cursor->bindex != bindex)
+				continue;
+			if (!cursor->whiteout)
+				continue;
+
+			strcpy(name, WHPFX);
+			strncpy(name + WHLEN, cursor->name, PAGE_SIZE - WHLEN);
+
+			hidden_dentry =
+			    LOOKUP_ONE_LEN(name, hidden_dir_dentry,
+					   cursor->namelen + WHLEN);
+			if (IS_ERR(hidden_dentry)) {
+				err = PTR_ERR(hidden_dentry);
+				goto out;
+			}
+			if (!hidden_dentry->d_inode) {
+				DPUT(hidden_dentry);
+				continue;
+			}
+
+			down(&hidden_dir_dentry->d_inode->i_sem);
+			err =
+			    vfs_unlink(hidden_dir_dentry->d_inode,
+				       hidden_dentry);
+			up(&hidden_dir_dentry->d_inode->i_sem);
+			DPUT(hidden_dentry);
+
+			if (err && !IS_COPYUP_ERR(err))
+				goto out;
+		}
+	}
+
+      out:
+	/* After all of the removals, we should copy the attributes once. */
+	fist_copy_attr_times(dentry->d_inode, hidden_dir_dentry->d_inode);
+	dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+
+	if (name)
+		free_page((unsigned long)name);
+	print_exit_status(err);
+	return err;
+}
+
+#define RD_NONE 0
+#define RD_CHECK_EMPTY 1
+/* The callback structure for check_empty. */
+struct unionfs_rdutil_callback {
+	int err;
+	int filldir_called;
+	struct unionfs_dir_state *rdstate;
+	int mode;
+};
+
+/* This filldir function makes sure only whiteouts exist within a directory. */
+static int readdir_util_callback(void *dirent, const char *name, int namelen,
+				 loff_t offset, ino_t ino, unsigned int d_type)
+{
+	int err = 0;
+	struct unionfs_rdutil_callback *buf =
+	    (struct unionfs_rdutil_callback *)dirent;
+	int whiteout = 0;
+	struct filldir_node *found;
+
+	print_entry_location();
+
+	buf->filldir_called = 1;
+
+	if (name[0] == '.'
+	    && (namelen == 1 || (name[1] == '.' && namelen == 2)))
+		goto out;
+
+	if ((namelen > WHLEN) && !strncmp(name, WHPFX, WHLEN)) {
+		namelen -= WHLEN;
+		name += WHLEN;
+		whiteout = 1;
+	}
+
+	found = find_filldir_node(buf->rdstate, name, namelen);
+	/* If it was found in the table there was a previous whiteout. */
+	if (found)
+		goto out;
+
+	/* If it wasn't found and isn't a whiteout, the directory isn't empty. */
+	err = -ENOTEMPTY;
+	if ((buf->mode == RD_CHECK_EMPTY) && !whiteout)
+		goto out;
+
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->uds_bindex, whiteout);
+
+      out:
+	buf->err = err;
+	print_exit_status(err);
+	return err;
+}
+
+/* Is a directory logically empty? */
+int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct super_block *sb;
+	struct file *hidden_file;
+	struct unionfs_rdutil_callback *buf = NULL;
+	int bindex, bstart, bend, bopaque;
+
+	print_entry_location();
+
+	sb = dentry->d_sb;
+
+	unionfs_read_lock(sb);
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	bopaque = dbopaque(dentry);
+	if (0 <= bopaque && bopaque < bend)
+		bend = bopaque;
+
+	buf = KMALLOC(sizeof(struct unionfs_rdutil_callback), GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+	buf->err = 0;
+	buf->mode = RD_CHECK_EMPTY;
+	buf->rdstate = alloc_rdstate(dentry->d_inode, bstart);
+	if (!buf->rdstate) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Process the hidden directories with rdutil_callback as a filldir. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (!hidden_dentry->d_inode)
+			continue;
+		if (!S_ISDIR(hidden_dentry->d_inode->i_mode))
+			continue;
+
+		DGET(hidden_dentry);
+		mntget(stohiddenmnt_index(sb, bindex));
+		branchget(sb, bindex);
+		hidden_file =
+		    DENTRY_OPEN(hidden_dentry, stohiddenmnt_index(sb, bindex),
+				O_RDONLY);
+		if (IS_ERR(hidden_file)) {
+			err = PTR_ERR(hidden_file);
+			DPUT(hidden_dentry);
+			branchput(sb, bindex);
+			goto out;
+		}
+
+		do {
+			buf->filldir_called = 0;
+			buf->rdstate->uds_bindex = bindex;
+			err = vfs_readdir(hidden_file,
+					  readdir_util_callback, buf);
+			if (buf->err)
+				err = buf->err;
+		} while ((err >= 0) && buf->filldir_called);
+
+		/* fput calls dput for hidden_dentry */
+		fput(hidden_file);
+		branchput(sb, bindex);
+
+		if (err < 0)
+			goto out;
+	}
+
+      out:
+	if (buf) {
+		if (namelist && !err)
+			*namelist = buf->rdstate;
+		else if (buf->rdstate)
+			free_rdstate(buf->rdstate);
+		KFREE(buf);
+	}
+
+	unionfs_read_unlock(sb);
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/file.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/file.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,331 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: file.c,v 1.136 2006/02/13 18:07:33 cwright Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations for sparse */
+extern ssize_t unionfs_read(struct file *, char __user *, size_t, loff_t *);
+extern ssize_t unionfs_write(struct file *, const char __user *, size_t,
+			     loff_t *);
+
+/*******************
+ * File Operations *
+ *******************/
+
+static loff_t unionfs_llseek(struct file *file, loff_t offset, int origin)
+{
+	loff_t err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	fist_dprint(6, "unionfs_llseek: file=%p, offset=0x%llx, origin=%d\n",
+		    file, offset, origin);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	hidden_file = ftohf(file);
+	/* always set hidden position to this one */
+	hidden_file->f_pos = file->f_pos;
+
+	memcpy(&(hidden_file->f_ra), &(file->f_ra),
+	       sizeof(struct file_ra_state));
+
+	if (hidden_file->f_op && hidden_file->f_op->llseek)
+		err = hidden_file->f_op->llseek(hidden_file, offset, origin);
+	else
+		err = generic_file_llseek(hidden_file, offset, origin);
+
+	if (err < 0)
+		goto out;
+	if (err != file->f_pos) {
+		file->f_pos = err;
+		// ION maybe this?
+		//      file->f_pos = hidden_file->f_pos;
+
+		file->f_version++;
+	}
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+
+ssize_t unionfs_read(struct file * file, char __user * buf, size_t count,
+		     loff_t * ppos)
+{
+	int err = -EINVAL;
+	struct file *hidden_file = NULL;
+	loff_t pos = *ppos;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	fist_print_file("entering read()", file);
+
+	hidden_file = ftohf(file);
+
+	if (!hidden_file->f_op || !hidden_file->f_op->read)
+		goto out;
+
+	err = hidden_file->f_op->read(hidden_file, buf, count, &pos);
+	*ppos = pos;
+	if (err >= 0) {
+		/* atime should also be updated for reads of size zero or more */
+		fist_copy_attr_atime(file->f_dentry->d_inode,
+				     hidden_file->f_dentry->d_inode);
+	}
+	memcpy(&(file->f_ra), &(hidden_file->f_ra),
+	       sizeof(struct file_ra_state));
+
+      out:
+	fist_print_file("leaving read()", file);
+	print_exit_status(err);
+	return err;
+}
+
+#ifdef SUPPORT_BROKEN_LOSETUP
+static ssize_t unionfs_sendfile(struct file *file, loff_t * ppos,
+				size_t count, read_actor_t actor, void *target)
+{
+	ssize_t err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	err = -EINVAL;
+	if (!hidden_file->f_op || !hidden_file->f_op->sendfile)
+		goto out;
+
+	err = hidden_file->f_op->sendfile(hidden_file, ppos, count, actor,
+					  target);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+#endif
+
+/* this unionfs_write() does not modify data pages! */
+ssize_t unionfs_write(struct file * file, const char __user * buf, size_t count,
+		      loff_t * ppos)
+{
+	int err = -EINVAL;
+	struct file *hidden_file = NULL;
+	struct inode *inode;
+	struct inode *hidden_inode;
+	loff_t pos = *ppos;
+	int bstart, bend;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	inode = file->f_dentry->d_inode;
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	BUG_ON(bstart == -1);
+
+	hidden_file = ftohf(file);
+	hidden_inode = hidden_file->f_dentry->d_inode;
+
+	if (!hidden_file->f_op || !hidden_file->f_op->write)
+		goto out;
+
+	/* adjust for append -- seek to the end of the file */
+	if (file->f_flags & O_APPEND)
+		pos = inode->i_size;
+
+	err = hidden_file->f_op->write(hidden_file, buf, count, &pos);
+
+	/*
+	 * copy ctime and mtime from lower layer attributes
+	 * atime is unchanged for both layers
+	 */
+	if (err >= 0)
+		fist_copy_attr_times(inode, hidden_inode);
+
+	*ppos = pos;
+
+	/* update this inode's size */
+	if (pos > inode->i_size)
+		inode->i_size = pos;
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_file_readdir(struct file *file, void *dirent,
+				filldir_t filldir)
+{
+	int err = -ENOTDIR;
+	print_entry_location();
+	print_exit_status(err);
+	return err;
+}
+
+static unsigned int unionfs_poll(struct file *file, poll_table * wait)
+{
+	unsigned int mask = DEFAULT_POLLMASK;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if (unionfs_file_revalidate(file, 0)) {
+		/* We should pretend an error happend. */
+		mask = POLLERR | POLLIN | POLLOUT;
+		goto out;
+	}
+
+	hidden_file = ftohf(file);
+
+	if (!hidden_file->f_op || !hidden_file->f_op->poll)
+		goto out;
+
+	mask = hidden_file->f_op->poll(hidden_file, wait);
+
+      out:
+	print_exit_status(mask);
+	return mask;
+}
+
+/* FIST-LITE special version of mmap */
+static int unionfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+	int willwrite;
+
+	print_entry_location();
+
+	/* This might could be deferred to mmap's writepage. */
+	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);
+	if ((err = unionfs_file_revalidate(file, willwrite)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	err = -ENODEV;
+	if (!hidden_file->f_op || !hidden_file->f_op->mmap)
+		goto out;
+
+	vma->vm_file = hidden_file;
+	err = hidden_file->f_op->mmap(hidden_file, vma);
+	get_file(hidden_file);	/* make sure it doesn't get freed on us */
+	fput(file);		/* no need to keep extra ref on ours */
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	int err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	err = -EINVAL;
+	if (!hidden_file->f_op || !hidden_file->f_op->fsync)
+		goto out;
+
+	down(&hidden_file->f_dentry->d_inode->i_sem);
+	err = hidden_file->f_op->fsync(hidden_file, hidden_file->f_dentry,
+				       datasync);
+	up(&hidden_file->f_dentry->d_inode->i_sem);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_fasync(int fd, struct file *file, int flag)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	if (hidden_file->f_op && hidden_file->f_op->fasync)
+		err = hidden_file->f_op->fasync(fd, hidden_file, flag);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+struct file_operations unionfs_main_fops = {
+	.llseek = unionfs_llseek,
+	.read = unionfs_read,
+	.write = unionfs_write,
+	.readdir = unionfs_file_readdir,
+	.poll = unionfs_poll,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+	.unlocked_ioctl = unionfs_ioctl,
+#endif
+	.mmap = unionfs_mmap,
+	.open = unionfs_open,
+	.flush = unionfs_flush,
+	.release = unionfs_file_release,
+	.fsync = unionfs_fsync,
+	.fasync = unionfs_fasync,
+#ifdef SUPPORT_BROKEN_LOSETUP
+	.sendfile = unionfs_sendfile,
+#endif
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/inode.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/inode.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,1042 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: inode.c,v 1.263.2.2 2006/05/30 03:22:06 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations added for "sparse" */
+extern struct dentry *unionfs_lookup(struct inode *, struct dentry *,
+				     struct nameidata *);
+extern int unionfs_readlink(struct dentry *dentry, char __user * buf,
+			    int bufsiz);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+extern void unionfs_put_link(struct dentry *dentry, struct nameidata *nd);
+#else
+extern void unionfs_put_link(struct dentry *dentry, struct nameidata *nd,
+			     void *cookie);
+#endif
+
+static int unionfs_create(struct inode *parent, struct dentry *dentry,
+			  int mode, struct nameidata *nd)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *whiteout_dentry = NULL;
+	struct dentry *new_hidden_dentry;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_create", dentry);
+
+	/* We start out in the leftmost branch. */
+	bstart = dbstart(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	/* check if whiteout exists in this branch, i.e. lookup .wh.foo first */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		whiteout_dentry = NULL;
+		goto out;
+	}
+
+	if (whiteout_dentry->d_inode) {
+		/* .wh.foo has been found. */
+		/* First truncate it and then rename it to foo (hence having
+		 * the same overall effect as a normal create.
+		 *
+		 * XXX: This is not strictly correct.  If we have unlinked the
+		 * file and it still has a reference count, then we should
+		 * actually unlink the whiteout so that user's data isn't
+		 * hosed over.
+		 */
+		struct dentry *hidden_dir_dentry;
+		struct iattr newattrs;
+
+		down(&whiteout_dentry->d_inode->i_sem);
+		newattrs.ia_valid = ATTR_CTIME | ATTR_MODE | ATTR_ATIME
+		    | ATTR_MTIME | ATTR_UID | ATTR_GID | ATTR_FORCE
+		    | ATTR_KILL_SUID | ATTR_KILL_SGID;
+
+		newattrs.ia_mode = mode & ~current->fs->umask;
+		newattrs.ia_uid = current->fsuid;
+		newattrs.ia_gid = current->fsgid;
+
+		if (whiteout_dentry->d_inode->i_size != 0) {
+			newattrs.ia_valid |= ATTR_SIZE;
+			newattrs.ia_size = 0;
+		}
+
+		err = notify_change(whiteout_dentry, &newattrs);
+
+		up(&whiteout_dentry->d_inode->i_sem);
+
+		if (err)
+			printk(KERN_WARNING
+			       "unionfs: %s:%d: notify_change failed: %d, ignoring..\n",
+			       __FILE__, __LINE__, err);
+
+		new_hidden_dentry = dtohd(dentry);
+		DGET(new_hidden_dentry);
+
+		hidden_dir_dentry = GET_PARENT(whiteout_dentry);
+		lock_rename(hidden_dir_dentry, hidden_dir_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			err =
+			    vfs_rename(hidden_dir_dentry->d_inode,
+				       whiteout_dentry,
+				       hidden_dir_dentry->d_inode,
+				       new_hidden_dentry);
+		}
+		if (!err) {
+			fist_copy_attr_timesizes(parent,
+						 new_hidden_dentry->d_parent->
+						 d_inode);
+			parent->i_nlink = get_nlinks(parent);
+		}
+
+		unlock_rename(hidden_dir_dentry, hidden_dir_dentry);
+		DPUT(hidden_dir_dentry);
+
+		DPUT(new_hidden_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			/* We were not able to create the file in this branch,
+			 * so, we try to create it in one branch to left
+			 */
+			bstart--;
+		} else {
+			/* reset the unionfs dentry to point to the .wh.foo entry. */
+
+			/* Discard any old reference. */
+			DPUT(dtohd(dentry));
+
+			/* Trade one reference to another. */
+			set_dtohd_index(dentry, bstart, whiteout_dentry);
+			whiteout_dentry = NULL;
+
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			goto out;
+		}
+	}
+
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			/* if hidden_dentry is NULL, create the entire
+			 * dentry directory structure in branch 'bindex'.
+			 * hidden_dentry will NOT be null when bindex == bstart
+			 * because lookup passed as a negative unionfs dentry
+			 * pointing to a lone negative underlying dentry */
+			hidden_dentry = create_parents(parent, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				if (IS_ERR(hidden_dentry))
+					err = PTR_ERR(hidden_dentry);
+				continue;
+			}
+		}
+
+		fist_checkinode(parent, "unionfs_create");
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		/* We shouldn't create things in a read-only branch. */
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			//DQ: vfs_create has a different prototype in 2.6
+			err = vfs_create(hidden_parent_dentry->d_inode,
+					 hidden_dentry, mode, nd);
+		}
+		if (err || !hidden_dentry->d_inode) {
+			unlock_dir(hidden_parent_dentry);
+
+			/* break out of for loop if the error wasn't  -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(parent,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				parent->i_nlink = get_nlinks(parent);
+			}
+			unlock_dir(hidden_parent_dentry);
+			break;
+		}
+	}
+
+      out:
+	DPUT(whiteout_dentry);
+	KFREE(name);
+
+	fist_print_dentry("OUT unionfs_create :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+struct dentry *unionfs_lookup(struct inode *parent, struct dentry *dentry,
+			      struct nameidata *nd)
+{
+	/* The locking is done by unionfs_lookup_backend. */
+	return unionfs_lookup_backend(dentry, INTERPOSE_LOOKUP);
+}
+
+static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *hidden_old_dentry = NULL;
+	struct dentry *hidden_new_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *whiteout_dentry;
+	char *name = NULL;
+
+	print_entry_location();
+	double_lock_dentry(new_dentry, old_dentry);
+
+	hidden_new_dentry = dtohd(new_dentry);
+
+	/* check if whiteout exists in the branch of new dentry, i.e. lookup
+	 * .wh.foo first. If present, delete it */
+	name = alloc_whname(new_dentry->d_name.name, new_dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_new_dentry->d_parent,
+			   new_dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found a .wh.foo entry, unlink it and then call vfs_link() */
+		hidden_dir_dentry = lock_parent(whiteout_dentry);
+		if (!
+		    (err =
+		     is_robranch_super(new_dentry->d_sb,
+				       dbstart(new_dentry)))) {
+			err =
+			    vfs_unlink(hidden_dir_dentry->d_inode,
+				       whiteout_dentry);
+		}
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		dir->i_nlink = get_nlinks(dir);
+		unlock_dir(hidden_dir_dentry);
+		hidden_dir_dentry = NULL;
+		DPUT(whiteout_dentry);
+		if (err)
+			goto out;
+	}
+
+	if (dbstart(old_dentry) != dbstart(new_dentry)) {
+		hidden_new_dentry =
+		    create_parents(dir, new_dentry, dbstart(old_dentry));
+		err = PTR_ERR(hidden_new_dentry);
+		if (IS_COPYUP_ERR(err))
+			goto docopyup;
+		if (!hidden_new_dentry || IS_ERR(hidden_new_dentry))
+			goto out;
+	}
+	hidden_new_dentry = dtohd(new_dentry);
+	hidden_old_dentry = dtohd(old_dentry);
+
+	BUG_ON(dbstart(old_dentry) != dbstart(new_dentry));
+	hidden_dir_dentry = lock_parent(hidden_new_dentry);
+	if (!(err = is_robranch(old_dentry)))
+		err =
+		    vfs_link(hidden_old_dentry, hidden_dir_dentry->d_inode,
+			     hidden_new_dentry);
+	unlock_dir(hidden_dir_dentry);
+
+      docopyup:
+	if (IS_COPYUP_ERR(err)) {
+		int old_bstart = dbstart(old_dentry);
+		int bindex;
+
+		for (bindex = old_bstart - 1; bindex >= 0; bindex--) {
+			err =
+			    copyup_dentry(old_dentry->d_parent->
+					  d_inode, old_dentry,
+					  old_bstart, bindex, NULL,
+					  old_dentry->d_inode->i_size);
+			if (!err) {
+				hidden_new_dentry =
+				    create_parents(dir, new_dentry, bindex);
+				hidden_old_dentry = dtohd(old_dentry);
+				hidden_dir_dentry =
+				    lock_parent(hidden_new_dentry);
+				/* do vfs_link */
+				err =
+				    vfs_link(hidden_old_dentry,
+					     hidden_dir_dentry->d_inode,
+					     hidden_new_dentry);
+				unlock_dir(hidden_dir_dentry);
+				goto check_link;
+			}
+		}
+		goto out;
+	}
+      check_link:
+	if (err || !hidden_new_dentry->d_inode)
+		goto out;
+
+	/* Its a hard link, so use the same inode */
+	new_dentry->d_inode = IGRAB(old_dentry->d_inode);
+	d_instantiate(new_dentry, new_dentry->d_inode);
+	fist_copy_attr_all(dir, hidden_new_dentry->d_parent->d_inode);
+	/* propagate number of hard-links */
+	old_dentry->d_inode->i_nlink = get_nlinks(old_dentry->d_inode);
+
+      out:
+	if (!new_dentry->d_inode)
+		d_drop(new_dentry);
+
+	KFREE(name);
+
+	unlock_dentry(new_dentry);
+	unlock_dentry(old_dentry);
+
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *whiteout_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	umode_t mode;
+	int bindex = 0, bstart;
+	char *name = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_symlink", dentry);
+
+	/* We start out in the leftmost branch. */
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	/* check if whiteout exists in this branch, i.e. lookup .wh.foo first. If present, delete it */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found a .wh.foo entry, unlink it and then call vfs_symlink() */
+		hidden_dir_dentry = lock_parent(whiteout_dentry);
+
+		fist_print_generic_dentry("HDD", hidden_dir_dentry);
+		fist_print_generic_dentry("WD", whiteout_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			err =
+			    vfs_unlink(hidden_dir_dentry->d_inode,
+				       whiteout_dentry);
+		}
+		DPUT(whiteout_dentry);
+
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		dir->i_nlink = get_nlinks(dir);
+
+		unlock_dir(hidden_dir_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			/* should now try to create symlink in the another branch */
+			bstart--;
+		}
+	}
+
+	/* deleted whiteout if it was present, now do a normal vfs_symlink() with
+	   possible recursive directory creation */
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			/* if hidden_dentry is NULL, create the entire
+			 * dentry directory structure in branch 'bindex'. hidden_dentry will NOT be null when
+			 * bindex == bstart because lookup passed as a negative unionfs dentry pointing to a
+			 * lone negative underlying dentry */
+			hidden_dentry = create_parents(dir, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				if (IS_ERR(hidden_dentry)) {
+					err = PTR_ERR(hidden_dentry);
+				}
+				fist_dprint(8,
+					    "hidden dentry NULL (or error) for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			mode = S_IALLUGO;
+			err =
+			    vfs_symlink(hidden_dir_dentry->d_inode,
+					hidden_dentry, symname, mode);
+		}
+		unlock_dir(hidden_dir_dentry);
+
+		if (err || !hidden_dentry->d_inode) {
+			/* break out of for loop if error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, dir->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(dir,
+							 hidden_dir_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				dir->i_nlink = get_nlinks(dir);
+			}
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	KFREE(name);
+	fist_print_dentry("OUT unionfs_symlink :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int whiteout_unlinked = 0;
+	uid_t saved_uid = current->fsuid;
+	gid_t saved_gid = current->fsgid;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_mkdir", dentry);
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	// check if whiteout exists in this branch, i.e. lookup .wh.foo first
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		hidden_parent_dentry = lock_parent(whiteout_dentry);
+
+		/* Set the uid and gid to trick the fs into allowing us to create
+		 * the file */
+		current->fsuid = hidden_parent_dentry->d_inode->i_uid;
+		current->fsgid = hidden_parent_dentry->d_inode->i_gid;
+		//found a.wh.foo entry, remove it then do vfs_mkdir
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			err =
+			    vfs_unlink(hidden_parent_dentry->d_inode,
+				       whiteout_dentry);
+		}
+		DPUT(whiteout_dentry);
+
+		current->fsuid = saved_uid;
+		current->fsgid = saved_gid;
+
+		unlock_dir(hidden_parent_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			bstart--;
+		} else {
+			whiteout_unlinked = 1;
+		}
+	}
+	
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			hidden_dentry = create_parents(parent, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				fist_dprint(8,
+					    "hidden dentry NULL for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err =
+			    vfs_mkdir(hidden_parent_dentry->d_inode,
+				      hidden_dentry, mode);
+		}
+		unlock_dir(hidden_parent_dentry);
+
+		/* XXX this could potentially return a negative hidden_dentry! */
+		if (err || !hidden_dentry->d_inode) {
+			/* break out of for loop if error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			int i;
+			int bend = dbend(dentry);
+			
+			for (i = bindex + 1; i < bend; i++) {
+				if (dtohd_index(dentry, i)) {
+					DPUT(dtohd_index(dentry, i));
+					set_dtohd_index(dentry, i, NULL);
+				}
+			}
+			bend = bindex;
+			set_dbend(dentry, bend);
+
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(parent,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				parent->i_nlink = get_nlinks(parent);
+			}
+			whiteout_dentry = LOOKUP_ONE_LEN(UNIONFS_DIR_OPAQUE,
+							 hidden_dentry,
+							 sizeof
+							 (UNIONFS_DIR_OPAQUE) -
+							 1);
+			if (IS_ERR(whiteout_dentry)) {
+				err = PTR_ERR(whiteout_dentry);
+				goto out;
+			}
+			down(&hidden_dentry->d_inode->i_sem);
+			err = vfs_create(hidden_dentry->d_inode,
+					 whiteout_dentry, 0600, NULL);
+			up(&hidden_dentry->d_inode->i_sem);
+			DPUT(whiteout_dentry);
+
+			if (err) {
+				fist_dprint(8,
+					    "mkdir: error creating directory override entry: %d\n",
+					    err);
+				goto out;
+			}
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	KFREE(name);
+
+	fist_print_dentry("OUT unionfs_mkdir :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			 dev_t dev)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int whiteout_unlinked = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_mknod", dentry);
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	// check if whiteout exists in this branch, i.e. lookup .wh.foo first
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found .wh.foo, unlink it */
+		hidden_parent_dentry = lock_parent(whiteout_dentry);
+
+		//found a.wh.foo entry, remove it then do vfs_mkdir
+		if (!(err = is_robranch_super(dentry->d_sb, bstart)))
+			err = vfs_unlink(hidden_parent_dentry->d_inode,
+					 whiteout_dentry);
+		DPUT(whiteout_dentry);
+
+		unlock_dir(hidden_parent_dentry);
+
+		if (err) {
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+
+			bstart--;
+		} else {
+			whiteout_unlinked = 1;
+		}
+	}
+
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			hidden_dentry = create_parents(dir, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				fist_dprint(8,
+					    "hidden dentry NULL for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err = vfs_mknod(hidden_parent_dentry->d_inode,
+					hidden_dentry, mode, dev);
+		}
+		/* XXX this could potentially return a negative hidden_dentry! */
+		if (err || !hidden_dentry->d_inode) {
+			unlock_dir(hidden_parent_dentry);
+			/* break out of for, if error was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, dir->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(dir,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				dir->i_nlink = get_nlinks(dir);
+			}
+			unlock_dir(hidden_parent_dentry);
+
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	if (name) {
+		KFREE(name);
+	}
+
+	fist_print_dentry("OUT unionfs_mknod :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_readlink(struct dentry *dentry, char __user * buf, int bufsiz)
+{
+	int err;
+	struct dentry *hidden_dentry;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+	fist_print_dentry("unionfs_readlink IN", dentry);
+
+	if (!hidden_dentry->d_inode->i_op ||
+	    !hidden_dentry->d_inode->i_op->readlink) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = hidden_dentry->d_inode->i_op->readlink(hidden_dentry,
+						     buf, bufsiz);
+	if (err > 0)
+		fist_copy_attr_atime(dentry->d_inode, hidden_dentry->d_inode);
+
+      out:
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* We don't lock the dentry here, because readlink does the heavy lifting. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+static int unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#else
+static void *unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+#endif
+{
+	char *buf;
+	int len = PAGE_SIZE, err;
+	mm_segment_t old_fs;
+
+	print_entry_location();
+
+	/* This is freed by the put_link method assuming a successful call. */
+	buf = (char *)KMALLOC(len, GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* read the symlink, and then we will follow it */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	set_fs(old_fs);
+	if (err < 0) {
+		KFREE(buf);
+		buf = NULL;
+		goto out;
+	}
+	buf[err] = 0;
+	nd_set_link(nd, buf);
+	err = 0;
+
+      out:
+	print_exit_status(err);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+	return err;
+#else
+	return ERR_PTR(err);
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+void unionfs_put_link(struct dentry *dentry, struct nameidata *nd)
+#else
+void unionfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
+#endif
+{
+	char *link;
+	print_entry_location();
+	link = nd_get_link(nd);
+	KFREE(link);
+	print_exit_location();
+}
+
+/* Basically copied from the kernel vfs permission(), but we've changed
+ * the following: (1) the IS_RDONLY check is skipped, and (2) if you set
+ * the mount option `nfsperms=insceure', we assume that -EACCES means that
+ * the export is read-only and we should check standard Unix permissions.
+ * This means that NFS ACL checks (or other advanced permission features)
+ * are bypassed.
+ */
+static int inode_permission(struct inode *inode, int mask, struct nameidata *nd,
+			    int bindex)
+{
+	int retval, submask;
+
+	if (mask & MAY_WRITE) {
+		/* The first branch is allowed to be really readonly. */
+		if (bindex == 0) {
+			umode_t mode = inode->i_mode;
+			if (IS_RDONLY(inode) && (S_ISREG(mode) || S_ISDIR(mode)
+						 || S_ISLNK(mode)))
+				return -EROFS;
+		}
+		/*
+		 * Nobody gets write access to an immutable file.
+		 */
+		if (IS_IMMUTABLE(inode))
+			return -EACCES;
+	}
+
+	/* Ordinary permission routines do not understand MAY_APPEND. */
+	submask = mask & ~MAY_APPEND;
+	if (inode->i_op && inode->i_op->permission) {
+		retval = inode->i_op->permission(inode, submask, nd);
+		if ((retval == -EACCES) && (submask & MAY_WRITE) &&
+		    (!strcmp("nfs", (inode)->i_sb->s_type->name)) &&
+		    (nd) && (nd->mnt) && (nd->mnt->mnt_sb) &&
+		    (branchperms(nd->mnt->mnt_sb, bindex) & MAY_NFSRO)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+			retval = vfs_permission(inode, submask);
+#else
+			retval = generic_permission(inode, submask, NULL);
+#endif
+		}
+	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+		retval = vfs_permission(inode, submask);
+#else
+		retval = generic_permission(inode, submask, NULL);
+#endif
+	}
+	
+	if (retval && retval != -EROFS) /* ignore EROFS */
+		return retval;
+
+	retval = security_inode_permission(inode, mask, nd);
+	return ((retval == -EROFS) ? 0 : retval); /* ignore EROFS */
+}
+
+static int unionfs_permission(struct inode *inode, int mask,
+			      struct nameidata *nd)
+{
+	struct inode *hidden_inode = NULL;
+	int err = 0;
+	int bindex, bstart, bend;
+	const int is_file = !S_ISDIR(inode->i_mode);
+	const int write_mask = (mask & MAY_WRITE) && !(mask & MAY_READ);
+
+	print_entry_location();
+
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+
+	fist_print_inode("IN unionfs_permission", inode);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_inode = itohi_index(inode, bindex);
+		if (!hidden_inode)
+			continue;
+
+		/* check the condition for D-F-D underlying files/directories,
+		 * we dont have to check for files, if we are checking for
+		 * directories.
+		 */
+		if (!is_file && !S_ISDIR(hidden_inode->i_mode))
+			continue;
+		/* We use our own special version of permission, such that 
+		 * only the first branch returns -EROFS. */
+		err = inode_permission(hidden_inode, mask, nd, bindex);
+		/* The permissions are an intersection of the overall directory
+		 * permissions, so we fail if one fails. */
+		if (err)
+			goto out;
+		/* only the leftmost file matters. */
+		if (is_file || write_mask) {
+			if (is_file && write_mask) {
+				err = get_write_access(hidden_inode);
+				if (!err)
+					put_write_access(hidden_inode);
+			}
+			break;
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int err = 0;
+	struct dentry *hidden_dentry;
+	struct inode *inode = NULL;
+	struct inode *hidden_inode = NULL;
+	int bstart, bend, bindex;
+	int i;
+	int copyup = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	inode = dentry->d_inode;
+
+	for (bindex = bstart; (bindex <= bend) || (bindex == bstart); bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		BUG_ON(hidden_dentry->d_inode == NULL);
+
+		/* If the file is on a read only branch */
+		if (is_robranch_super(dentry->d_sb, bindex)
+		    || IS_RDONLY(hidden_dentry->d_inode)) {
+			if (copyup || (bindex != bstart))
+				continue;
+			/* Only if its the leftmost file, copyup the file */
+			for (i = bstart - 1; i >= 0; i--) {
+				size_t size = dentry->d_inode->i_size;
+				if (ia->ia_valid & ATTR_SIZE)
+					size = ia->ia_size;
+				err = copyup_dentry(dentry->d_parent->d_inode,
+						    dentry, bstart, i, NULL,
+						    size);
+
+				if (!err) {
+					copyup = 1;
+					hidden_dentry = dtohd(dentry);
+					break;
+				}
+				/* if error is in the leftmost f/s, pass it up */
+				if (i == 0)
+					goto out;
+			}
+
+		}
+		err = notify_change(hidden_dentry, ia);
+		if (err)
+			goto out;
+		break;
+	}
+
+	/* get the size from the first hidden inode */
+	hidden_inode = itohi(dentry->d_inode);
+	fist_checkinode(inode, "unionfs_setattr");
+	fist_copy_attr_all(inode, hidden_inode);
+
+      out:
+	unlock_dentry(dentry);
+	fist_checkinode(inode, "post unionfs_setattr");
+	print_exit_status(err);
+	return err;
+}
+
+struct inode_operations unionfs_symlink_iops = {
+	.readlink = unionfs_readlink,
+	.permission = unionfs_permission,
+	.follow_link = unionfs_follow_link,
+	.setattr = unionfs_setattr,
+	.put_link = unionfs_put_link,
+};
+
+struct inode_operations unionfs_dir_iops = {
+	.create = unionfs_create,
+	.lookup = unionfs_lookup,
+	.link = unionfs_link,
+	.unlink = unionfs_unlink,
+	.symlink = unionfs_symlink,
+	.mkdir = unionfs_mkdir,
+	.rmdir = unionfs_rmdir,
+	.mknod = unionfs_mknod,
+	.rename = unionfs_rename,
+	.permission = unionfs_permission,
+	.setattr = unionfs_setattr,
+	.setxattr = unionfs_setxattr,
+	.getxattr = unionfs_getxattr,
+	.removexattr = unionfs_removexattr,
+	.listxattr = unionfs_listxattr,
+};
+
+struct inode_operations unionfs_main_iops = {
+	.permission = unionfs_permission,
+	.setattr = unionfs_setattr,
+	.setxattr = unionfs_setxattr,
+	.getxattr = unionfs_getxattr,
+	.removexattr = unionfs_removexattr,
+	.listxattr = unionfs_listxattr,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/lookup.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/lookup.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,505 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: lookup.c,v 1.43 2006/02/13 00:18:40 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+static int is_opaque_dir(struct dentry *dentry, int bindex);
+static int is_validname(const char *name);
+
+struct dentry *unionfs_lookup_backend(struct dentry *dentry, int lookupmode)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *wh_hidden_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *parent_dentry = NULL;
+	int bindex, bstart, bend, bopaque;
+	int dentry_count = 0;	/* Number of positive dentries. */
+	int first_dentry_offset = -1;
+	struct dentry *first_hidden_dentry = NULL;
+	int locked_parent = 0;
+	int locked_child = 0;
+
+	int opaque;
+	char *whname = NULL;
+	const char *name;
+	int namelen;
+
+	print_entry("mode = %d", lookupmode);
+
+	/* We should already have a lock on this dentry in the case of a
+	 * partial lookup, or a revalidation. Otherwise it is returned from
+	 * new_dentry_private_data already locked.  */
+	if (lookupmode == INTERPOSE_PARTIAL || lookupmode == INTERPOSE_REVAL
+	    || lookupmode == INTERPOSE_REVAL_NEG) {
+		verify_locked(dentry);
+	} else {
+		BUG_ON(dtopd_nocheck(dentry) != NULL);
+		locked_child = 1;
+	}
+	if (lookupmode != INTERPOSE_PARTIAL)
+		if ((err = new_dentry_private_data(dentry)))
+			goto out;
+	/* must initialize dentry operations */
+	dentry->d_op = &unionfs_dops;
+
+	parent_dentry = GET_PARENT(dentry);
+	/* We never partial lookup the root directory. */
+	if (parent_dentry != dentry) {
+		lock_dentry(parent_dentry);
+		locked_parent = 1;
+	} else {
+		DPUT(parent_dentry);
+		parent_dentry = NULL;
+		goto out;
+	}
+
+	fist_print_dentry("IN unionfs_lookup (parent)", parent_dentry);
+	fist_print_dentry("IN unionfs_lookup (child)", dentry);
+
+	name = dentry->d_name.name;
+	namelen = dentry->d_name.len;
+
+	/* No dentries should get created for possible whiteout names. */
+	if (!is_validname(name)) {
+		err = -EPERM;
+		goto out_free;
+	}
+
+	/* Now start the actual lookup procedure. */
+	bstart = dbstart(parent_dentry);
+	bend = dbend(parent_dentry);
+	bopaque = dbopaque(parent_dentry);
+	BUG_ON(bstart < 0);
+
+	/* It would be ideal if we could convert partial lookups to only have
+	 * to do this work when they really need to.  It could probably improve
+	 * performance quite a bit, and maybe simplify the rest of the code. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		bstart++;
+		if ((bopaque != -1) && (bopaque < bend))
+			bend = bopaque;
+	}
+
+	fist_dprint(8, "bstart = %d, bend = %d\n", bstart, bend);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (lookupmode == INTERPOSE_PARTIAL && hidden_dentry)
+			continue;
+		BUG_ON(hidden_dentry != NULL);
+
+		hidden_dir_dentry = dtohd_index(parent_dentry, bindex);
+
+		/* if the parent hidden dentry does not exist skip this */
+		if (!(hidden_dir_dentry && hidden_dir_dentry->d_inode))
+			continue;
+
+		/* also skip it if the parent isn't a directory. */
+		if (!S_ISDIR(hidden_dir_dentry->d_inode->i_mode))
+			continue;
+
+		/* Reuse the whiteout name because its value doesn't change. */
+		if (!whname) {
+			whname = alloc_whname(name, namelen);
+			if (IS_ERR(whname)) {
+				err = PTR_ERR(whname);
+				goto out_free;
+			}
+		}
+
+		/* check if whiteout exists in this branch: lookup .wh.foo */
+		wh_hidden_dentry = LOOKUP_ONE_LEN(whname, hidden_dir_dentry,
+						  namelen + WHLEN);
+		if (IS_ERR(wh_hidden_dentry)) {
+			DPUT(first_hidden_dentry);
+			err = PTR_ERR(wh_hidden_dentry);
+			goto out_free;
+		}
+
+		if (wh_hidden_dentry->d_inode) {
+			/* We found a whiteout so lets give up. */
+			fist_dprint(8, "whiteout found in %d\n", bindex);
+			if (S_ISREG(wh_hidden_dentry->d_inode->i_mode)) {
+				set_dbend(dentry, bindex);
+				set_dbopaque(dentry, bindex);
+				DPUT(wh_hidden_dentry);
+				break;
+			}
+			err = -EIO;
+			printk(KERN_NOTICE "EIO: Invalid whiteout entry type"
+			       " %d.\n", wh_hidden_dentry->d_inode->i_mode);
+			DPUT(wh_hidden_dentry);
+			DPUT(first_hidden_dentry);
+			goto out_free;
+		}
+
+		DPUT(wh_hidden_dentry);
+		wh_hidden_dentry = NULL;
+
+		/* Now do regular lookup; lookup foo */
+		hidden_dentry = LOOKUP_ONE_LEN(name, hidden_dir_dentry,
+					       namelen);
+		fist_print_generic_dentry("hidden result", hidden_dentry);
+		if (IS_ERR(hidden_dentry)) {
+			DPUT(first_hidden_dentry);
+			err = PTR_ERR(hidden_dentry);
+			goto out_free;
+		}
+
+		/* Store the first negative dentry specially, because if they
+		 * are all negative we need this for future creates. */
+		if (!hidden_dentry->d_inode) {
+			if (!first_hidden_dentry && (dbstart(dentry) == -1)) {
+				first_hidden_dentry = hidden_dentry;
+				first_dentry_offset = bindex;
+			} else {
+				DPUT(hidden_dentry);
+			}
+			continue;
+		}
+
+		/* number of positive dentries */
+		dentry_count++;
+
+		/* store underlying dentry */
+		if (dbstart(dentry) == -1)
+			set_dbstart(dentry, bindex);
+		set_dtohd_index(dentry, bindex, hidden_dentry);
+		set_dbend(dentry, bindex);
+
+		/* update parent directory's atime with the bindex */
+		fist_copy_attr_atime(parent_dentry->d_inode,
+				     hidden_dir_dentry->d_inode);
+
+		/* We terminate file lookups here. */
+		if (!S_ISDIR(hidden_dentry->d_inode->i_mode)) {
+			if (lookupmode == INTERPOSE_PARTIAL)
+				continue;
+			if (dentry_count == 1)
+				goto out_positive;
+			/* This can only happen with mixed D-*-F-* */
+			BUG_ON(!S_ISDIR(dtohd(dentry)->d_inode->i_mode));
+			continue;
+		}
+
+		opaque = is_opaque_dir(dentry, bindex);
+		if (opaque < 0) {
+			DPUT(first_hidden_dentry);
+			err = opaque;
+			goto out_free;
+		}
+		if (opaque) {
+			set_dbend(dentry, bindex);
+			set_dbopaque(dentry, bindex);
+			break;
+		}
+	}
+
+	if (dentry_count)
+		goto out_positive;
+	else
+		goto out_negative;
+
+      out_negative:
+	if (lookupmode == INTERPOSE_PARTIAL)
+		goto out;
+
+	/* If we've only got negative dentries, then use the leftmost one. */
+	if (lookupmode == INTERPOSE_REVAL) {
+		if (dentry->d_inode) {
+			itopd(dentry->d_inode)->uii_stale = 1;
+		}
+		goto out;
+	}
+	/* This should only happen if we found a whiteout. */
+	if (first_dentry_offset == -1) {
+		first_hidden_dentry = LOOKUP_ONE_LEN(name, hidden_dir_dentry,
+						     namelen);
+		first_dentry_offset = bindex;
+		if (IS_ERR(first_hidden_dentry)) {
+			err = PTR_ERR(first_hidden_dentry);
+			goto out;
+		}
+	}
+	set_dtohd_index(dentry, first_dentry_offset, first_hidden_dentry);
+	set_dbstart(dentry, first_dentry_offset);
+	set_dbend(dentry, first_dentry_offset);
+
+	if (lookupmode == INTERPOSE_REVAL_NEG)
+		BUG_ON(dentry->d_inode != NULL);
+	else
+		d_add(dentry, NULL);
+	goto out;
+
+/* This part of the code is for positive dentries. */
+      out_positive:
+	BUG_ON(dentry_count <= 0);
+
+	/* If we're holding onto the first negative dentry throw it out. */
+	DPUT(first_hidden_dentry);
+
+	/* Partial lookups need to reinterpose, or throw away older negs. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		if (dentry->d_inode) {
+			unionfs_reinterpose(dentry);
+			goto out;
+		}
+
+		/* This somehow turned positive, so it is as if we had a
+		 * negative revalidation.  */
+		lookupmode = INTERPOSE_REVAL_NEG;
+
+		update_bstart(dentry);
+		bstart = dbstart(dentry);
+		bend = dbend(dentry);
+	}
+
+	err = unionfs_interpose(dentry, dentry->d_sb, lookupmode);
+	if (err)
+		goto out_drop;
+
+	fist_checkinode(dentry->d_inode, "unionfs_lookup OUT: child");
+	fist_checkinode(parent_dentry->d_inode, "unionfs_lookup OUT: dir");
+	goto out;
+
+      out_drop:
+	d_drop(dentry);
+
+      out_free:
+	/* should dput all the underlying dentries on error condition */
+	bstart = dbstart(dentry);
+	if (bstart >= 0) {
+		bend = dbend(dentry);
+		for (bindex = bstart; bindex <= bend; bindex++)
+			DPUT(dtohd_index(dentry, bindex));
+	}
+	KFREE(dtohd_ptr(dentry));
+	dtohd_ptr(dentry) = NULL;
+	set_dbstart(dentry, -1);
+	set_dbend(dentry, -1);
+
+      out:
+	if (!err && dtopd(dentry)) {
+		BUG_ON(dbend(dentry) > dtopd(dentry)->udi_bcount);
+		BUG_ON(dbend(dentry) > sbmax(dentry->d_sb));
+		BUG_ON(dbstart(dentry) < 0);
+	}
+	KFREE(whname);
+	fist_print_dentry("OUT unionfs_lookup (parent)", parent_dentry);
+	fist_print_dentry("OUT unionfs_lookup (child)", dentry);
+	if (locked_parent)
+		unlock_dentry(parent_dentry);
+	DPUT(parent_dentry);
+	if (locked_child)
+		unlock_dentry(dentry);
+	print_exit_status(err);
+	return ERR_PTR(err);
+}
+
+/* This is a utility function that fills in a unionfs dentry.*/
+int unionfs_partial_lookup(struct dentry *dentry)
+{
+	struct dentry *tmp;
+
+	tmp = unionfs_lookup_backend(dentry, INTERPOSE_PARTIAL);
+	if (!tmp)
+		return 0;
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+	/* need to change the interface */
+	BUG_ON(tmp != dentry);
+	return -ENOSYS;
+}
+
+/* The rest of these are utility functions for lookup. */
+static int is_opaque_dir(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *hidden_dentry;
+	struct dentry *wh_hidden_dentry;
+	struct inode *hidden_inode;
+	uid_t saved_uid = current->fsuid;
+	gid_t saved_gid = current->fsgid;
+
+	print_entry_location();
+
+	hidden_dentry = dtohd_index(dentry, bindex);
+	hidden_inode = hidden_dentry->d_inode;
+
+	BUG_ON(!S_ISDIR(hidden_inode->i_mode));
+
+	current->fsuid = hidden_inode->i_uid;
+	current->fsgid = hidden_inode->i_gid;
+	wh_hidden_dentry = LOOKUP_ONE_LEN(UNIONFS_DIR_OPAQUE, hidden_dentry,
+					  sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	current->fsuid = saved_uid;
+	current->fsgid = saved_gid;
+	if (IS_ERR(wh_hidden_dentry)) {
+		err = PTR_ERR(wh_hidden_dentry);
+		fist_dprint(1, "LOOKUP_ONE_LEN returned: %d\n", err);
+		goto out;
+	}
+	if (wh_hidden_dentry->d_inode)
+		err = 1;
+	DPUT(wh_hidden_dentry);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int is_validname(const char *name)
+{
+	if (!strncmp(name, WHPFX, WHLEN))
+		return 0;
+	if (!strncmp(name, UNIONFS_DIR_OPAQUE_NAME,
+		     sizeof(UNIONFS_DIR_OPAQUE_NAME) - 1))
+		return 0;
+	return 1;
+}
+
+/* The dentry cache is just so we have properly sized dentries. */
+static kmem_cache_t *unionfs_dentry_cachep;
+int init_dentry_cache(void)
+{
+	unionfs_dentry_cachep =
+	    kmem_cache_create("unionfs_dentry",
+			      sizeof(struct unionfs_dentry_info), 0,
+			      SLAB_RECLAIM_ACCOUNT, NULL, NULL);
+
+	if (!unionfs_dentry_cachep)
+		return -ENOMEM;
+	return 0;
+}
+
+void destroy_dentry_cache(void)
+{
+	if (!unionfs_dentry_cachep)
+		return;
+	if (kmem_cache_destroy(unionfs_dentry_cachep))
+		printk(KERN_ERR
+		       "unionfs_dentry_cache: not all structures were freed\n");
+	return;
+}
+
+void free_dentry_private_data(struct unionfs_dentry_info *udi)
+{
+	if (!udi)
+		return;
+	kmem_cache_free(unionfs_dentry_cachep, udi);
+}
+
+int new_dentry_private_data(struct dentry *dentry)
+{
+	int newsize;
+	int oldsize = 0;
+
+	spin_lock(&dentry->d_lock);
+	if (!dtopd_nocheck(dentry)) {
+		dtopd_lhs(dentry) = (struct unionfs_dentry_info *)
+		    kmem_cache_alloc(unionfs_dentry_cachep, SLAB_ATOMIC);
+		if (!dtopd_nocheck(dentry))
+			goto out;
+		init_MUTEX_LOCKED(&dtopd_nocheck(dentry)->udi_sem);
+#ifdef TRACKLOCK
+		printk("INITLOCK:%p\n", dentry);
+#endif
+		dtohd_ptr(dentry) = NULL;
+	} else {
+		oldsize = sizeof(struct dentry *) * dtopd(dentry)->udi_bcount;
+	}
+
+	dtopd_nocheck(dentry)->udi_bstart = -1;
+	dtopd_nocheck(dentry)->udi_bend = -1;
+	dtopd_nocheck(dentry)->udi_bopaque = -1;
+	dtopd_nocheck(dentry)->udi_bcount = sbmax(dentry->d_sb);
+	atomic_set(&dtopd_nocheck(dentry)->udi_generation,
+		   atomic_read(&stopd(dentry->d_sb)->usi_generation));
+	newsize = sizeof(struct dentry *) * sbmax(dentry->d_sb);
+
+	/* Don't reallocate when we already have enough space. */
+	/* It would be ideal if we could actually use the slab macros to
+	 * determine what our object sizes is, but those are not exported.
+	 */
+	if (oldsize) {
+		int minsize = malloc_sizes[0].cs_size;
+
+		if (!newsize || ((oldsize < newsize) && (newsize > minsize))) {
+			KFREE(dtohd_ptr(dentry));
+			dtohd_ptr(dentry) = NULL;
+		}
+	}
+
+	if (!dtohd_ptr(dentry) && newsize) {
+		dtohd_ptr(dentry) = KMALLOC(newsize, GFP_ATOMIC);
+		if (!dtohd_ptr(dentry))
+			goto out;
+	}
+
+	if (oldsize > newsize)
+		memset(dtohd_ptr(dentry), 0, oldsize);
+	else
+		memset(dtohd_ptr(dentry), 0, newsize);
+
+	spin_unlock(&dentry->d_lock);
+	return 0;
+
+      out:
+	free_dentry_private_data(dtopd_nocheck(dentry));
+	dtopd_lhs(dentry) = NULL;
+	spin_unlock(&dentry->d_lock);
+	return -ENOMEM;
+}
+
+void update_bstart(struct dentry *dentry)
+{
+	int bindex;
+	int bstart = dbstart(dentry);
+	int bend = dbend(dentry);
+	struct dentry *hidden_dentry;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (hidden_dentry->d_inode) {
+			set_dbstart(dentry, bindex);
+			break;
+		}
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	}
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/main.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/main.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,820 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: main.c,v 1.161.2.2 2006/04/23 19:55:52 jsipek Exp $
+ */
+
+#include "unionfs.h"
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+/* declarations added for "sparse" */
+extern void unionfs_kill_block_super(struct super_block *sb);
+
+/* declarations added for malloc_debugging */
+
+#ifdef FIST_MALLOC_DEBUG
+extern atomic_t unionfs_malloc_counter;
+extern atomic_t unionfs_mallocs_outstanding;
+#endif
+/* sb we pass is unionfs's super_block */
+int unionfs_interpose(struct dentry *dentry, struct super_block *sb, int flag)
+{
+	struct inode *hidden_inode;
+	struct dentry *hidden_dentry;
+	int err = 0;
+	struct inode *inode;
+	int is_negative_dentry = 1;
+	int bindex, bstart, bend;
+
+	print_entry("flag = %d", flag);
+
+	verify_locked(dentry);
+
+	fist_print_dentry("In unionfs_interpose", dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* Make sure that we didn't get a negative dentry. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		if (dtohd_index(dentry, bindex) &&
+		    dtohd_index(dentry, bindex)->d_inode) {
+			is_negative_dentry = 0;
+			break;
+		}
+	}
+	BUG_ON(is_negative_dentry);
+
+	/* We allocate our new inode below, by calling iget.
+	 * iget will call our read_inode which will initialize some
+	 * of the new inode's fields
+	 */
+
+	/* On revalidate we've already got our own inode and just need
+	 * to fix it up. */
+	if (flag == INTERPOSE_REVAL) {
+		inode = dentry->d_inode;
+		itopd(inode)->b_start = -1;
+		itopd(inode)->b_end = -1;
+		atomic_set(&itopd(inode)->uii_generation,
+			   atomic_read(&stopd(sb)->usi_generation));
+
+		itohi_ptr(inode) =
+		    KZALLOC(sbmax(sb) * sizeof(struct inode *), GFP_KERNEL);
+		if (!itohi_ptr(inode)) {
+			err = -ENOMEM;
+			goto out;
+		}
+	} else {
+		ino_t ino;
+		/* get unique inode number for unionfs */
+#ifdef UNIONFS_IMAP
+		if (stopd(sb)->usi_persistent) {
+			err = read_uin(sb, bindex,
+				       dtohd_index(dentry,
+						   bindex)->d_inode->i_ino,
+				       O_CREAT, &ino);
+			if (err)
+				goto out;
+		} else
+#endif
+			ino = iunique(sb, UNIONFS_ROOT_INO);
+
+		inode = IGET(sb, ino);
+		if (!inode) {
+			err = -EACCES;	/* should be impossible??? */
+			goto out;
+		}
+	}
+
+	down(&inode->i_sem);
+	if (atomic_read(&inode->i_count) > 1)
+		goto skip;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			set_itohi_index(inode, bindex, NULL);
+			continue;
+		}
+		/* Initialize the hidden inode to the new hidden inode. */
+		if (!hidden_dentry->d_inode)
+			continue;
+		set_itohi_index(inode, bindex, IGRAB(hidden_dentry->d_inode));
+	}
+
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	/* Use attributes from the first branch. */
+	hidden_inode = itohi(inode);
+
+	/* Use different set of inode ops for symlinks & directories */
+	if (S_ISLNK(hidden_inode->i_mode))
+		inode->i_op = &unionfs_symlink_iops;
+	else if (S_ISDIR(hidden_inode->i_mode))
+		inode->i_op = &unionfs_dir_iops;
+
+	/* Use different set of file ops for directories */
+	if (S_ISDIR(hidden_inode->i_mode))
+		inode->i_fop = &unionfs_dir_fops;
+
+	/* properly initialize special inodes */
+	if (S_ISBLK(hidden_inode->i_mode) || S_ISCHR(hidden_inode->i_mode) ||
+	    S_ISFIFO(hidden_inode->i_mode) || S_ISSOCK(hidden_inode->i_mode))
+		init_special_inode(inode, hidden_inode->i_mode,
+				   hidden_inode->i_rdev);
+
+	/* Fix our inode's address operations to that of the lower inode (Unionfs is FiST-Lite) */
+	if (inode->i_mapping->a_ops != hidden_inode->i_mapping->a_ops) {
+		fist_dprint(7, "fixing inode 0x%p a_ops (0x%p -> 0x%p)\n",
+			    inode, inode->i_mapping->a_ops,
+			    hidden_inode->i_mapping->a_ops);
+		inode->i_mapping->a_ops = hidden_inode->i_mapping->a_ops;
+	}
+
+	/* all well, copy inode attributes */
+	fist_copy_attr_all(inode, hidden_inode);
+
+      skip:
+	/* only (our) lookup wants to do a d_add */
+	switch (flag) {
+	case INTERPOSE_DEFAULT:
+	case INTERPOSE_REVAL_NEG:
+		d_instantiate(dentry, inode);
+		break;
+	case INTERPOSE_LOOKUP:
+		err = PTR_ERR(d_splice_alias(inode, dentry));
+		break;
+	case INTERPOSE_REVAL:
+		/* Do nothing. */
+		break;
+	default:
+		printk(KERN_ERR "Invalid interpose flag passed!");
+		BUG();
+	}
+
+	fist_print_dentry("Leaving unionfs_interpose", dentry);
+	fist_print_inode("Leaving unionfs_interpose", inode);
+	up(&inode->i_sem);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+void unionfs_reinterpose(struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct inode *inode;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+	verify_locked(dentry);
+	fist_print_dentry("IN: unionfs_reinterpose: ", dentry);
+
+	/* This is pre-allocated inode */
+	inode = dentry->d_inode;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		if (!hidden_dentry->d_inode)
+			continue;
+		if (itohi_index(inode, bindex))
+			continue;
+		set_itohi_index(inode, bindex, IGRAB(hidden_dentry->d_inode));
+	}
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	fist_print_dentry("OUT: unionfs_reinterpose: ", dentry);
+	fist_print_inode("OUT: unionfs_reinterpose: ", inode);
+
+	print_exit_location();
+}
+
+int check_branch(struct nameidata *nd)
+{
+	if (!strcmp(nd->dentry->d_sb->s_type->name, "unionfs"))
+		return -EINVAL;
+	if (!nd->dentry->d_inode)
+		return -ENOENT;
+	if (!S_ISDIR(nd->dentry->d_inode->i_mode))
+		return -ENOTDIR;
+	return 0;
+}
+
+/* checks if two hidden_dentries have overlapping branches */
+int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)
+{
+	struct dentry *dent = NULL;
+
+	dent = dent1;
+	while ((dent != dent2) && (dent->d_parent != dent)) {
+		dent = dent->d_parent;
+	}
+	if (dent == dent2) {
+		return 1;
+	}
+
+	dent = dent2;
+	while ((dent != dent1) && (dent->d_parent != dent)) {
+		dent = dent->d_parent;
+	}
+	if (dent == dent1) {
+		return 1;
+	}
+
+	return 0;
+}
+static int parse_branch_mode(char *name)
+{
+	int perms;
+	int l = strlen(name);
+	if (!strcmp(name + l - 3, "=ro")) {
+		perms = MAY_READ;
+		name[l - 3] = '\0';
+	} else if (!strcmp(name + l - 6, "=nfsro")) {
+		perms = MAY_READ | MAY_NFSRO;
+		name[l - 6] = '\0';
+	} else if (!strcmp(name + l - 3, "=rw")) {
+		perms = MAY_READ | MAY_WRITE;
+		name[l - 3] = '\0';
+	} else {
+		perms = MAY_READ | MAY_WRITE;
+	}
+
+	return perms;
+}
+
+static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
+			     *hidden_root_info, char *options)
+{
+	struct nameidata nd;
+	char *name;
+	int err = 0;
+	int branches = 1;
+	int bindex = 0;
+	int i = 0;
+	int j = 0;
+
+	struct dentry *dent1 = NULL;
+	struct dentry *dent2 = NULL;
+
+	if (options[0] == '\0') {
+		printk(KERN_WARNING "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Each colon means we have a separator, this is really just a rough
+	 * guess, since strsep will handle empty fields for us. */
+	for (i = 0; options[i]; i++) {
+		if (options[i] == ':')
+			branches++;
+	}
+
+	/* allocate space for underlying pointers to hidden dentry */
+	if (!(stopd(sb)->usi_data = alloc_new_data(branches))) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (!(hidden_root_info->udi_dentry = alloc_new_dentries(branches))) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* now parsing the string b1:b2=rw:b3=ro:b4 */
+	branches = 0;
+	while ((name = strsep(&options, ":")) != NULL) {
+		int perms;
+
+		if (!*name)
+			continue;
+
+		branches++;
+
+		/* strip off =rw or =ro if it is specified. */
+		perms = parse_branch_mode(name);
+		if (!bindex && !(perms & MAY_WRITE)) {
+			err = -EINVAL;
+			goto out;
+		}
+
+		fist_dprint(4, "unionfs: using directory: %s (%c%c%c)\n",
+			    name, perms & MAY_READ ? 'r' : '-',
+			    perms & MAY_WRITE ? 'w' : '-',
+			    perms & MAY_NFSRO ? 'n' : '-');
+
+		err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+		RECORD_PATH_LOOKUP(&nd);
+		if (err) {
+			printk(KERN_WARNING "unionfs: error accessing "
+			       "hidden directory '%s' (error %d)\n", name, err);
+			goto out;
+		}
+
+		if ((err = check_branch(&nd))) {
+			printk(KERN_WARNING "unionfs: hidden directory "
+			       "'%s' is not a valid branch\n", name);
+			path_release(&nd);
+			RECORD_PATH_RELEASE(&nd);
+			goto out;
+		}
+
+		hidden_root_info->udi_dentry[bindex] = nd.dentry;
+
+		set_stohiddenmnt_index(sb, bindex, nd.mnt);
+		set_branchperms(sb, bindex, perms);
+		set_branch_count(sb, bindex, 0);
+
+		if (hidden_root_info->udi_bstart < 0)
+			hidden_root_info->udi_bstart = bindex;
+		hidden_root_info->udi_bend = bindex;
+		bindex++;
+	}
+
+	if (branches == 0) {
+		printk(KERN_WARNING "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	BUG_ON(branches != (hidden_root_info->udi_bend + 1));
+
+	/* ensure that no overlaps exist in the branches */
+	for (i = 0; i < branches; i++) {
+		for (j = i + 1; j < branches; j++) {
+			dent1 = hidden_root_info->udi_dentry[i];
+			dent2 = hidden_root_info->udi_dentry[j];
+
+			if (is_branch_overlap(dent1, dent2)) {
+				goto out_overlap;
+			}
+		}
+	}
+
+      out_overlap:
+
+	if (i != branches) {
+		printk(KERN_WARNING "unionfs: branches %d and %d overlap\n", i,
+		       j);
+		err = -EINVAL;
+		goto out;
+	}
+
+      out:
+	if (err) {
+		for (i = 0; i < branches; i++) {
+			if (hidden_root_info->udi_dentry[i])
+				DPUT(hidden_root_info->udi_dentry[i]);
+		}
+
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(stopd(sb)->usi_data);
+
+		/* MUST clear the pointers to prevent potential double free if
+		 * the caller dies later on
+		 */
+		hidden_root_info->udi_dentry = NULL;
+		stopd(sb)->usi_data = NULL;
+	}
+	return err;
+}
+
+/*
+ * Parse mount options.  See the manual page for usage instructions.
+ *
+ * Returns the dentry object of the lower-level (hidden) directory;
+ * We want to mount our stackable file system on top of that hidden directory.
+ *
+ * Sets default debugging level to N, if any.
+ */
+static struct unionfs_dentry_info *unionfs_parse_options(struct super_block *sb,
+							 char *options)
+{
+	struct unionfs_dentry_info *hidden_root_info;
+	char *optname;
+	int err = 0;
+	int bindex;
+	int dirsfound = 0;
+#ifdef UNIONFS_IMAP
+	int imapfound = 0;
+#endif
+	print_entry_location();
+
+	/* allocate private data area */
+	err = -ENOMEM;
+	hidden_root_info =
+	    KZALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
+	if (!hidden_root_info)
+		goto out_error;
+	hidden_root_info->udi_bstart = -1;
+	hidden_root_info->udi_bend = -1;
+	hidden_root_info->udi_bopaque = -1;
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+		char *endptr;
+		int intval;
+
+		if (!*optname) {
+			continue;
+		}
+
+		optarg = strchr(optname, '=');
+		if (optarg) {
+			*optarg++ = '\0';
+		}
+
+		/* All of our options take an argument now. Insert ones that
+		 * don't, above this check.  */
+		if (!optarg) {
+			printk("unionfs: %s requires an argument.\n", optname);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("dirs", optname)) {
+			if (++dirsfound > 1) {
+				printk(KERN_WARNING
+				       "unionfs: multiple dirs specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err = parse_dirs_option(sb, hidden_root_info, optarg);
+			if (err)
+				goto out_error;
+			continue;
+		}
+#ifdef UNIONFS_IMAP
+		if (!strcmp("imap", optname)) {
+			if (++imapfound > 1) {
+				printk(KERN_WARNING
+				       "unionfs: multiple imap specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err = parse_imap_option(sb, hidden_root_info, optarg);
+			if (err)
+				goto out_error;
+			continue;
+		}
+#endif
+		if (!strcmp("delete", optname)) {
+			if (!strcmp("whiteout", optarg)) {
+				/* default */
+#ifdef UNIONFS_DELETE_ALL
+			} else if (!strcmp("all", optarg)) {
+				MOUNT_FLAG(sb) |= DELETE_ALL;
+#endif
+			} else {
+				printk(KERN_WARNING
+				       "unionfs: invalid delete option '%s'\n",
+				       optarg);
+				err = -EINVAL;
+				goto out_error;
+			}
+			continue;
+		}
+		if (!strcmp("copyup", optname)) {
+			if (!strcmp("preserve", optarg)) {
+				/* default */
+			} else if (!strcmp("currentuser", optarg)) {
+				MOUNT_FLAG(sb) |= COPYUP_CURRENT_USER;
+			} else {
+				printk(KERN_WARNING
+				       "unionfs: could not parse copyup option value '%s'\n",
+				       optarg);
+				err = -EINVAL;
+				goto out_error;
+			}
+			continue;
+		}
+
+		/* All of these options require an integer argument. */
+		intval = simple_strtoul(optarg, &endptr, 0);
+		if (*endptr) {
+			printk(KERN_WARNING
+			       "unionfs: invalid %s option '%s'\n",
+			       optname, optarg);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("debug", optname)) {
+			fist_set_debug_value(intval);
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_WARNING
+		       "unionfs: unrecognized option '%s'\n", optname);
+		goto out_error;
+	}
+	if (dirsfound != 1) {
+		printk(KERN_WARNING "unionfs: dirs option required\n");
+		err = -EINVAL;
+		goto out_error;
+	}
+	goto out;
+
+      out_error:
+	if (hidden_root_info && hidden_root_info->udi_dentry) {
+		for (bindex = hidden_root_info->udi_bstart;
+		     bindex >= 0 && bindex <= hidden_root_info->udi_bend;
+		     bindex++) {
+			struct dentry *d;
+			d = hidden_root_info->udi_dentry[bindex];
+			DPUT(d);
+			if (stohiddenmnt_index(sb, bindex))
+				mntput(stohiddenmnt_index(sb, bindex));
+		}
+	}
+
+	KFREE(hidden_root_info->udi_dentry);
+	KFREE(hidden_root_info);
+
+	KFREE(stopd(sb)->usi_data);
+	stopd(sb)->usi_data = NULL;
+
+	hidden_root_info = ERR_PTR(err);
+      out:
+	print_exit_location();
+	return hidden_root_info;
+}
+
+static struct dentry *unionfs_d_alloc_root(struct super_block *sb)
+{
+	struct dentry *ret = NULL;
+
+	if (sb) {
+		static const struct qstr name = {.name = "/",.len = 1 };
+
+		ret = d_alloc(NULL, &name);
+		if (ret) {
+			ret->d_op = &unionfs_dops;
+			ret->d_sb = sb;
+			ret->d_parent = ret;
+		}
+	}
+	return ret;
+}
+
+static int unionfs_read_super(struct super_block *sb, void *raw_data,
+			      int silent)
+{
+	int err = 0;
+
+	struct unionfs_dentry_info *hidden_root_info = NULL;
+	int bindex, bstart, bend;
+	unsigned long long maxbytes;
+
+	print_entry_location();
+
+	if (!raw_data) {
+		printk(KERN_WARNING
+		       "unionfs_read_super: missing data argument\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Allocate superblock private data
+	 */
+	stopd_lhs(sb) = KZALLOC(sizeof(struct unionfs_sb_info), GFP_KERNEL);
+	if (!stopd(sb)) {
+		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
+		err = -ENOMEM;
+		goto out;
+	}
+	stopd(sb)->b_end = -1;
+	atomic_set(&stopd(sb)->usi_generation, 1);
+	init_rwsem(&stopd(sb)->usi_rwsem);
+
+	hidden_root_info = unionfs_parse_options(sb, raw_data);
+	if (IS_ERR(hidden_root_info)) {
+		printk(KERN_WARNING
+		       "unionfs_read_super: error while parsing options (err = %ld)\n",
+		       PTR_ERR(hidden_root_info));
+		err = PTR_ERR(hidden_root_info);
+		hidden_root_info = NULL;
+		goto out_free;
+	}
+	if (hidden_root_info->udi_bstart == -1) {
+		err = -ENOENT;
+		goto out_free;
+	}
+
+	/* set the hidden superblock field of upper superblock */
+	bstart = hidden_root_info->udi_bstart;
+	BUG_ON(bstart != 0);
+	sbend(sb) = bend = hidden_root_info->udi_bend;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+
+		d = hidden_root_info->udi_dentry[bindex];
+
+		set_stohs_index(sb, bindex, d->d_sb);
+	}
+
+	/* Unionfs: Max Bytes is the maximum bytes from among all the branches */
+	maxbytes = -1;
+	for (bindex = bstart; bindex <= bend; bindex++)
+		if (maxbytes < stohs_index(sb, bindex)->s_maxbytes)
+			maxbytes = stohs_index(sb, bindex)->s_maxbytes;
+	sb->s_maxbytes = maxbytes;
+
+	sb->s_op = &unionfs_sops;
+	sb->s_export_op = &unionfs_export_ops;
+
+	/*
+	 * we can't use d_alloc_root if we want to use
+	 * our own interpose function unchanged,
+	 * so we simply call our own "fake" d_alloc_root
+	 */
+	sb->s_root = unionfs_d_alloc_root(sb);
+	if (!sb->s_root) {
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	/* link the upper and lower dentries */
+	dtopd_lhs(sb->s_root) = NULL;
+	if ((err = new_dentry_private_data(sb->s_root)))
+		goto out_freedpd;
+
+	/* Set the hidden dentries for s_root */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+
+		d = hidden_root_info->udi_dentry[bindex];
+
+		set_dtohd_index(sb->s_root, bindex, d);
+	}
+	set_dbstart(sb->s_root, bstart);
+	set_dbend(sb->s_root, bend);
+
+	/* Set the generation number to one, since this is for the mount. */
+	atomic_set(&dtopd(sb->s_root)->udi_generation, 1);
+
+	/* call interpose to create the upper level inode */
+	if ((err = unionfs_interpose(sb->s_root, sb, 0)))
+		goto out_freedpd;
+	unlock_dentry(sb->s_root);
+	goto out;
+
+      out_freedpd:
+	if (dtopd(sb->s_root)) {
+		KFREE(dtohd_ptr(sb->s_root));
+		free_dentry_private_data(dtopd(sb->s_root));
+	}
+	DPUT(sb->s_root);
+      out_dput:
+	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
+		for (bindex = hidden_root_info->udi_bstart;
+		     bindex <= hidden_root_info->udi_bend; bindex++) {
+			struct dentry *d;
+
+			d = hidden_root_info->udi_dentry[bindex];
+
+			if (d)
+				DPUT(d);
+
+			if (stopd(sb) && stohiddenmnt_index(sb, bindex))
+				mntput(stohiddenmnt_index(sb, bindex));
+		}
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(hidden_root_info);
+		hidden_root_info = NULL;
+	}
+      out_free:
+	KFREE(stopd(sb)->usi_data);
+	KFREE(stopd(sb));
+	stopd_lhs(sb) = NULL;
+      out:
+	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(hidden_root_info);
+	}
+	print_exit_status(err);
+	return err;
+}
+
+static struct super_block *unionfs_get_sb(struct file_system_type *fs_type,
+					  int flags, const char *dev_name,
+					  void *raw_data)
+{
+	return get_sb_nodev(fs_type, flags, raw_data, unionfs_read_super);
+}
+
+void unionfs_kill_block_super(struct super_block *sb)
+{
+	generic_shutdown_super(sb);
+}
+
+/* Compat..it is simpler to have it here, than to duplicate the code in
+   unionfs_kzalloc and KZALLOC non-debug macro */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+void *kzalloc(size_t size, gfp_t flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) */
+
+static struct file_system_type unionfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "unionfs",
+	.get_sb = unionfs_get_sb,
+	.kill_sb = unionfs_kill_block_super,
+	.fs_flags = FS_REVAL_DOT,
+};
+
+static int init_debug = 0;
+module_param_named(debug, init_debug, int, 0444);
+MODULE_PARM_DESC(debug, "Initial Unionfs debug value.");
+
+static int __init init_unionfs_fs(void)
+{
+	int err;
+	printk("Registering unionfs " UNIONFS_VERSION "\n");
+
+	fist_set_debug_value(init_debug);
+
+#ifdef FIST_MALLOC_DEBUG
+	atomic_set(&unionfs_malloc_counter, 0);
+	atomic_set(&unionfs_mallocs_outstanding, 0);
+#endif				/* FIST_MALLOC_DEBUG */
+
+	if ((err = init_filldir_cache()))
+		goto out;
+	if ((err = init_inode_cache()))
+		goto out;
+	if ((err = init_dentry_cache()))
+		goto out;
+	err = register_filesystem(&unionfs_fs_type);
+      out:
+	if (err) {
+		destroy_filldir_cache();
+		destroy_inode_cache();
+		destroy_dentry_cache();
+	}
+	return err;
+}
+static void __exit exit_unionfs_fs(void)
+{
+	destroy_filldir_cache();
+	destroy_inode_cache();
+	destroy_dentry_cache();
+	unregister_filesystem(&unionfs_fs_type);
+	printk("Completed unionfs module unload.\n");
+}
+
+MODULE_AUTHOR
+    ("Filesystems and Storage Lab, Stony Brook University (http://www.fsl.cs.sunysb.edu/)");
+MODULE_DESCRIPTION("Unionfs " UNIONFS_VERSION
+		   " (http://unionfs.filesystems.org/)");
+MODULE_LICENSE("GPL");
+
+module_init(init_unionfs_fs);
+module_exit(exit_unionfs_fs);
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/Makefile	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,11 @@
+UNIONFS_VERSION  = 1.1.5
+EXTRA_CFLAGS+=-DUNIONFS_VERSION=\"${UNIONFS_VERSION}\"
+# This will disable debugging support
+# EXTRA_CFLAGS+=-DUNIONFS_NDEBUG
+
+obj-$(CONFIG_UNION_FS) += unionfs.o
+
+unionfs-objs := subr.o dentry.o file.o inode.o main.o super.o \
+	stale_inode.o branchman.o xattr.o rdstate.o copyup.o  \
+	dirhelper.o rename.o unlink.o lookup.o persistent_inode.o \
+	commonfops.o dirfops.o print.o
--- linux-2.6.13.1/fs/unionfs/malloc_debug.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/malloc_debug.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,199 @@
+#ifdef FIST_MALLOC_DEBUG
+
+#include "unionfs.h"
+
+/* for malloc debugging */
+atomic_t unionfs_malloc_counter = ATOMIC_INIT(0);
+atomic_t unionfs_mallocs_outstanding = ATOMIC_INIT(0);
+atomic_t unionfs_dget_counter = ATOMIC_INIT(0);
+atomic_t unionfs_dgets_outstanding = ATOMIC_INIT(0);
+atomic_t unionfs_iget_counter = ATOMIC_INIT(0);
+atomic_t unionfs_igets_outstanding = ATOMIC_INIT(0);
+
+void *unionfs_kzalloc(size_t size, gfp_t flags, int line, const char *file)
+{
+	void *ptr = kzalloc(size, flags);
+	if (ptr) {
+		atomic_inc(&unionfs_malloc_counter);
+		atomic_inc(&unionfs_mallocs_outstanding);
+		printk("KZA:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_malloc_counter),
+		       atomic_read(&unionfs_mallocs_outstanding), ptr, line,
+		       file);
+	}
+	return ptr;
+}
+void *unionfs_kmalloc(size_t size, gfp_t flags, int line, const char *file)
+{
+	void *ptr = kmalloc(size, flags);
+	if (ptr) {
+		atomic_inc(&unionfs_malloc_counter);
+		atomic_inc(&unionfs_mallocs_outstanding);
+		printk("KM:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_malloc_counter),
+		       atomic_read(&unionfs_mallocs_outstanding), ptr, line,
+		       file);
+	}
+	return ptr;
+}
+
+void unionfs_kfree(void *ptr, int line, const char *file)
+{
+	atomic_inc(&unionfs_malloc_counter);
+	if (ptr) {
+		BUG_ON(IS_ERR(ptr));
+		atomic_dec(&unionfs_mallocs_outstanding);
+	}
+	printk("KF:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_malloc_counter),
+	       atomic_read(&unionfs_mallocs_outstanding), ptr, line, file);
+	kfree(ptr);
+}
+
+void record_set(struct dentry *upper, int index, struct dentry *ptr,
+		struct dentry *old, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	printk("DD:%d:%d:%d:%p:%d:%s %p, %d\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       old ? atomic_read(&old->d_count) : 0, old, line, file, upper,
+	       index);
+	atomic_inc(&unionfs_dget_counter);
+	printk("DS:%d:%d:%d:%p:%d:%s %p, %d\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file, upper,
+	       index);
+}
+
+void record_path_lookup(struct nameidata *nd, int line, const char *file)
+{
+	struct dentry *ptr = nd->dentry;
+	if (ptr) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DL:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+}
+
+void record_path_release(struct nameidata *nd, int line, const char *file)
+{
+	struct dentry *ptr = nd->dentry;
+
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr)
+		atomic_dec(&unionfs_dgets_outstanding);
+	printk("DP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+}
+
+struct file *unionfs_dentry_open(struct dentry *ptr, struct vfsmount *mnt,
+				 int flags, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr)
+		atomic_dec(&unionfs_dgets_outstanding);
+	printk("DO:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+	return dentry_open(ptr, mnt, flags);
+}
+
+struct dentry *unionfs_dget(struct dentry *ptr, int line, const char *file)
+{
+	ptr = dget(ptr);
+	if (ptr) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DG:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+	return ptr;
+}
+
+struct dentry *unionfs_dget_parent(struct dentry *child, int line,
+				   const char *file)
+{
+	struct dentry *ptr;
+
+	ptr = dget_parent(child);
+	atomic_inc(&unionfs_dget_counter);
+	atomic_inc(&unionfs_dgets_outstanding);
+	printk("DG:%d:%d:%d:%p:%d:%s\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       atomic_read(&ptr->d_count), ptr, line, file);
+
+	return ptr;
+}
+
+struct dentry *unionfs_lookup_one_len(const char *name, struct dentry *parent,
+				      int len, int line, const char *file)
+{
+	struct dentry *ptr = lookup_one_len(name, parent, len);
+	if (ptr && !IS_ERR(ptr)) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DL:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+	return ptr;
+}
+
+void unionfs_dput(struct dentry *ptr, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr) {
+		BUG_ON(IS_ERR(ptr));
+		atomic_dec(&unionfs_dgets_outstanding);
+	}
+	printk("DP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+	dput(ptr);
+}
+
+struct inode *unionfs_igrab(struct inode *inode, int line, char *file)
+{
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_inc(&unionfs_igets_outstanding);
+	printk("IR:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	return igrab(inode);
+}
+
+void unionfs_iput(struct inode *inode, int line, char *file)
+{
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_dec(&unionfs_igets_outstanding);
+	printk("IP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	iput(inode);
+}
+
+struct inode *unionfs_iget(struct super_block *sb, unsigned long ino, int line,
+			   char *file)
+{
+	struct inode *inode = iget(sb, ino);
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_inc(&unionfs_igets_outstanding);
+	printk("IG:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	return inode;
+}
+
+#endif				/* FIST_MALLOC_DEBUG */
--- linux-2.6.13.1/fs/unionfs/persistent_inode.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/persistent_inode.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,662 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: persistent_inode.c,v 1.33 2006/02/13 00:18:40 jsipek Exp $
+ */
+#ifdef UNIONFS_IMAP
+
+#include "unionfs.h"
+
+static ssize_t __fread(struct file *filp, void *buf, size_t size, loff_t * pos)
+{
+	int err;
+	mm_segment_t oldfs;
+	ssize_t(*func) (struct file *, char __user *, size_t, loff_t *);
+
+	func = do_sync_read;
+	if (filp->f_op && filp->f_op->read)
+		func = filp->f_op->read;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		err = func(filp, (char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+	return err;
+}
+
+static ssize_t __fwrite(struct file *filp, void *buf, size_t size, loff_t * pos)
+{
+	int err;
+	mm_segment_t oldfs;
+	unsigned long flim;
+	struct rlimit *rl;
+	ssize_t(*func) (struct file *, const char __user *, size_t, loff_t *);
+
+	func = do_sync_write;
+	if (filp->f_op && filp->f_op->write)
+		func = filp->f_op->write;
+
+	/*
+	 * it breaks RLIMIT_FSIZE,
+	 * but users should be careful to quota.
+	 */
+	rl = current->signal->rlim + RLIMIT_FSIZE;
+	flim = rl->rlim_cur;
+	rl->rlim_cur = RLIM_INFINITY;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		err = func(filp, (const char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+	rl->rlim_cur = flim;
+	return err;
+}
+
+/*
+ * verify_forwardmap(super_block *sb)
+ * sb: pointer to a superblock containing the forwardmap.
+ * returns: 0 on success EINVAL or ENOMEM on failure;
+ */
+static int verify_forwardmap(struct super_block *sb)
+{
+	int err = 0, bytesread = 0, bindex = 0, mallocsize = 0;
+	loff_t readpos = 0;
+	struct file *forwardmap = NULL;
+	struct fmaphdr header;
+	struct unionfs_sb_info *spd = NULL;
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	forwardmap = spd->usi_forwardmap;
+	if (!forwardmap) {
+		err = -EINVAL;
+		goto out;
+	}
+	bytesread = __fread(forwardmap, &header, sizeof(struct fmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct fmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (header.magic != FORWARDMAP_MAGIC
+	    || header.version != FORWARDMAP_VERSION) {
+		err = -EINVAL;
+		goto out;
+	}
+	spd->usi_bmap =
+	    KMALLOC(sizeof(struct bmapent) * header.usedbranches, GFP_KERNEL);
+
+	if (!spd->usi_bmap) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	while (bindex < header.usedbranches) {
+		bytesread = __fread(forwardmap, &stopd(sb)->usi_bmap[bindex],
+				    sizeof(struct bmapent), &readpos);
+		if (bytesread < sizeof(struct bmapent)) {
+			err = -EINVAL;
+			goto out_err;
+		}
+		bindex++;
+	}
+
+	mallocsize = sizeof(int) * header.usedbranches;
+	goto out;
+      out_err:
+	if (spd->usi_bmap)
+		KFREE(spd->usi_bmap);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * verify_reversemap(struct super_block sb, int rmapindex)
+ *
+ * sb: The unionfs superblock containing all of the current imap info
+ * rmapindex: the index in the usi_reversemaps array that we wish to
+ * verify
+ *
+ * Assumes the reverse maps less than rmapindex are valid.
+ *
+ * returns: 0 if the opperation succeds
+ * 	-EINVAL if the map file does not belong to the forward map
+ *
+ */
+static int verify_reversemap(struct super_block *sb, int rmapindex,
+			     struct unionfs_dentry_info *hidden_root_info)
+{
+	int err = 0, i = 0, bindex = 0, found = 0, bytesread;
+	loff_t readpos = 0;
+	struct file *forwardmap, *reversemap;
+	struct fmaphdr fheader;
+	struct rmaphdr rheader;
+	struct kstatfs st;
+	struct unionfs_sb_info *spd = NULL;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	forwardmap = spd->usi_forwardmap;
+	if (!forwardmap) {
+		err = -EINVAL;
+		goto out;
+	}
+	reversemap = spd->usi_reversemaps[rmapindex];
+	if (!reversemap) {
+		err = -EINVAL;
+		goto out;
+	}
+	bytesread = __fread(forwardmap, &fheader, sizeof(struct fmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct fmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	readpos = 0;
+	bytesread = __fread(reversemap, &rheader, sizeof(struct rmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct rmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (rheader.magic != REVERSEMAP_MAGIC
+	    || rheader.version != REVERSEMAP_VERSION) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (memcmp(fheader.uuid, rheader.fwduuid, sizeof(fheader.uuid))) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* XXX: Ok so here we take the new map and read the fsid from it. Then
+	 * we go through all the branches in the union and see which ones it
+	 * matches with*/
+	for (i = 0; i < spd->usi_num_bmapents && !found; i++) {
+		if (memcmp
+		    (rheader.revuuid, spd->usi_bmap[i].uuid,
+		     sizeof(rheader.revuuid)))
+			continue;
+
+		found = 1;
+		for (bindex = 0; bindex <= hidden_root_info->udi_bend; bindex++) {
+			struct dentry *d;
+			fsid_t fsid;
+			dev_t dev;
+			memset(&st, 0, sizeof(struct kstatfs));
+
+			d = hidden_root_info->udi_dentry[bindex];
+
+			err = d->d_sb->s_op->statfs(d->d_sb, &st);
+			if (err)
+				goto out;
+
+			if (st.f_fsid.val[0] || st.f_fsid.val[1]) {
+				fsid = st.f_fsid;
+			} else {
+
+				dev = d->d_sb->s_dev;
+				fsid.val[0] = MAJOR(dev);
+				fsid.val[1] = MINOR(dev);
+			}
+
+			if (memcmp(&fsid, &rheader.fsid, sizeof(fsid)))
+				continue;
+
+			if (spd->usi_bnum_table[bindex] == -1)
+				spd->usi_bnum_table[bindex] = i;
+			if (spd->usi_map_table[bindex]) {
+				printk(KERN_WARNING
+				       "Two reverse maps share fsid %u%u!\n",
+				       rheader.fsid.val[0],
+				       rheader.fsid.val[1]);
+				err = -EINVAL;
+				goto out;
+			} else {
+				spd->usi_map_table[bindex] = reversemap;
+			}
+		}
+	}
+	if (!found) {
+		printk(KERN_WARNING
+		       "Could not match the reversemap uuid with an entry in the forwardmap table\n");
+		err = -EINVAL;
+	}
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int init_imap_data(struct super_block *sb,
+		   struct unionfs_dentry_info *hidden_root_info)
+{
+	int i, err = 0, mallocsize = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	spd->usi_forwardmap = NULL;
+	spd->usi_reversemaps = NULL;
+	spd->usi_bnum_table = NULL;
+
+	mallocsize = sizeof(struct file *) * (hidden_root_info->udi_bend + 1);
+	spd->usi_reversemaps = KZALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_reversemaps) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	spd->usi_map_table = KZALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_map_table) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	mallocsize = sizeof(int) * (hidden_root_info->udi_bend + 1);
+	spd->usi_bnum_table = KMALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_bnum_table) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	for (i = 0; i <= hidden_root_info->udi_bend; i++) {
+		spd->usi_bnum_table[i] = -1;
+	}
+
+	if (!err)
+		goto out;
+      out_error:
+
+	if (spd->usi_reversemaps) {
+		KFREE(spd->usi_reversemaps);
+		spd->usi_reversemaps = NULL;
+	}
+
+	if (spd->usi_map_table) {
+		KFREE(spd->usi_map_table);
+		spd->usi_map_table = NULL;
+	}
+
+	if (spd->usi_bnum_table) {
+		KFREE(spd->usi_bnum_table);
+		spd->usi_bnum_table = NULL;
+
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+
+}
+
+void cleanup_imap_data(struct super_block *sb)
+{
+	int count = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	spd->usi_persistent = 0;
+	count = spd->usi_num_bmapents;
+	while (count - 1 >= 0) {
+		if (spd->usi_reversemaps[count - 1]) {
+			filp_close(spd->usi_reversemaps[count - 1], NULL);
+			spd->usi_reversemaps[count - 1] = NULL;
+		}
+		count--;
+	}
+	if (spd->usi_reversemaps) {
+		KFREE(spd->usi_reversemaps);
+		spd->usi_reversemaps = NULL;
+	}
+
+	if (spd->usi_map_table) {
+		KFREE(spd->usi_map_table);
+		spd->usi_map_table = NULL;
+	}
+
+	if (spd->usi_bnum_table) {
+		KFREE(spd->usi_bnum_table);
+		spd->usi_bnum_table = NULL;
+	}
+	if (spd->usi_forwardmap) {
+		filp_close(spd->usi_forwardmap, NULL);
+		spd->usi_forwardmap = NULL;
+	}
+	print_exit_location();
+}
+
+int parse_imap_option(struct super_block *sb,
+		      struct unionfs_dentry_info *hidden_root_info,
+		      char *options)
+{
+	int count = 0, err = 0;
+	char *name;
+	struct unionfs_sb_info *spd = NULL;
+
+	print_entry_location();
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	err = init_imap_data(sb, hidden_root_info);
+	if (err)
+		goto out_error;
+	while ((name = strsep(&options, ":")) != NULL) {
+		if (!*name)
+			continue;
+		if (!spd->usi_forwardmap) {
+			spd->usi_forwardmap = filp_open(name, O_RDWR, 0);
+			if (IS_ERR(spd->usi_forwardmap)) {
+				err = PTR_ERR(spd->usi_forwardmap);
+				spd->usi_forwardmap = NULL;
+				goto out_error;
+			}
+		} else {
+			spd->usi_reversemaps[count] =
+			    filp_open(name, O_RDWR, 0);
+			if (IS_ERR(spd->usi_reversemaps[count])) {
+				err = PTR_ERR(spd->usi_reversemaps[count]);
+				spd->usi_reversemaps[count] = NULL;
+				goto out_error;
+
+			}
+			count++;
+		}
+	}
+	if (count <= 0) {
+		printk(KERN_WARNING "unionfs: no reverse maps specified.\n");
+		err = -EINVAL;
+	}
+	if (err)
+		goto out_error;
+
+	/* Initialize the super block's next_avail field */
+	/* Dave, you can't use 64-bit division here because the i386 doesn't
+	 * support it natively.  Instead you need to punt if the size is
+	 * greater than unsigned long, and then cast it down.  Then you should
+	 * be able to assign to this value, without having these problems. */
+
+	if (spd->usi_forwardmap->f_dentry->d_inode->i_size > ULONG_MAX) {
+		err = -EFBIG;
+		goto out_error;
+	}
+	spd->usi_next_avail =
+	    ((unsigned long)(spd->usi_forwardmap->f_dentry->d_inode->
+			     i_size - (sizeof(struct fmaphdr) +
+				       sizeof(struct bmapent[256])))
+	     / sizeof(struct fmapent));
+
+	if (spd->usi_next_avail < FIRST_VALID_INODE)
+		spd->usi_next_avail = FIRST_VALID_INODE;
+
+	spd->usi_num_bmapents = count;
+	err = verify_forwardmap(sb);
+	if (err)
+		goto out_error;
+	while (count > 0) {
+		err = verify_reversemap(sb, --count, hidden_root_info);
+		if (err)
+			goto out_error;
+	}
+	spd->usi_persistent = 1;
+
+	goto out;
+
+      out_error:
+	spd->usi_num_bmapents = count;
+	cleanup_imap_data(sb);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+ /*
+  * get @ino from @hidden_ino.
+  */
+static int __read_uin(struct unionfs_sb_info *sbi, ino_t hidden_ino, int bindex,
+		      ino_t * ino)
+{
+	int err;
+	struct file *rev;
+	loff_t pos;
+	ssize_t sz;
+	uint64_t ino64;
+	const int elmnt = sizeof(ino64);
+
+	rev = sbi->usi_map_table[bindex];
+	pos = sizeof(struct rmaphdr) + elmnt * hidden_ino;
+	*ino = 0;
+	err = 0;
+	if (pos + elmnt > rev->f_dentry->d_inode->i_size)
+		goto out;
+
+	sz = __fread(rev, &ino64, elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = 0;
+	*ino = -1;
+	if (sz != elmnt || ino64 > *ino)
+		err = -EIO;
+	*ino = ino64;
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * put unionfs @ino for @hidden_ino on @bindex.
+ */
+static int __write_uin(struct unionfs_sb_info *sbi, ino_t ino, int bindex,
+		       ino_t hidden_ino)
+{
+	struct file *fwd, *rev;
+	struct fmapent ent;
+	loff_t pos;
+	ssize_t sz;
+	int err;
+	uint64_t ino64;
+	const int fwdhdr = sizeof(struct fmaphdr) + sizeof(struct bmapent[256]);
+	const int fwd_elmnt = sizeof(ent);
+	const int rev_elmnt = sizeof(ino64);
+
+	err = -ENOSPC;
+	if (ino < FIRST_VALID_INODE)
+		goto out;
+
+	fwd = sbi->usi_forwardmap;
+	ent.fsnum = sbi->usi_bnum_table[bindex];
+	ent.inode = ino;
+	pos = fwdhdr + fwd_elmnt * hidden_ino;
+	sz = __fwrite(fwd, &ent, fwd_elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = -EIO;
+	if (sz != fwd_elmnt)
+		goto out;
+
+	rev = sbi->usi_map_table[bindex];
+	pos = sizeof(struct rmaphdr) + rev_elmnt * hidden_ino;
+	ino64 = ino;
+	sz = __fwrite(rev, &ino64, rev_elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = 0;
+	if (sz != rev_elmnt)
+		err = -EIO;
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * read_uin(struct super_block *sb, uint8_t branchnum, ino_t inode_number, int flag, ino_t *uino)
+ * fsnum: branch to reference when getting the inode number
+ * inode_number: lower level inode number use to reference the proper inode.
+ * flag: if set to O_CREAT it will creat the entry if it doesent exist
+ * 		 otherwise it will return the existing one.
+ * returns: the unionfs inode number either created or retrieved based on
+ * 			the information.
+ */
+int read_uin(struct super_block *sb, uint8_t branchnum, ino_t inode_number,
+	     int flag, ino_t * uino)
+{
+	int err = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	/* Find appropriate reverse map and then read from the required position */
+	/* get it from the array. */
+	err = __read_uin(spd, inode_number, branchnum, uino);
+	if (err || *uino)
+		goto out;
+
+	err = -EIO;
+	if (!(flag & O_CREAT))
+		goto out;
+
+	/* If we haven't found an entry and we have the O_CREAT flag set we want to
+	 * create a new entry write it out to the file and return its index
+	 */
+	*uino = spd->usi_next_avail++;
+	down(&sb->s_lock);
+	err = __write_uin(spd, *uino, branchnum, inode_number);
+	if (err)
+		spd->usi_next_avail--;
+	up(&sb->s_lock);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int write_uin(struct super_block *sb, ino_t ino, int bindex, ino_t hidden_ino)
+{
+	int err;
+
+	print_entry_location();
+	err = __write_uin(stopd(sb), ino, bindex, hidden_ino);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * get_lin(ino_t inode_number)
+ * inode_number : inode number for the unionfs inode
+ * returns: the lower level inode# and branch#
+ */
+/* entry should use a poiner on the stack. should be staticly allocated one
+ * level up*/
+int get_lin(struct super_block *sb, ino_t inode_number, struct fmapent *entry)
+{
+	struct file *forwardmap;
+	loff_t seek_size;
+	mm_segment_t oldfs;
+	int err = 0, bytesread = 0;
+
+	print_entry_location();
+
+	if (!entry) {
+		entry = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	forwardmap = stopd(sb)->usi_forwardmap;
+	seek_size =
+	    sizeof(struct fmaphdr) + sizeof(struct bmapent[256]) +
+	    (sizeof(struct fmapent) * inode_number);
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	bytesread =
+	    forwardmap->f_op->read(forwardmap, (char __user *)entry,
+				   sizeof(struct fmapent), &seek_size);
+	set_fs(oldfs);
+	if (bytesread != sizeof(struct fmapent)) {
+		entry = ERR_PTR(-EINVAL);
+		goto out;
+	}
+
+      out:
+	print_exit_location();
+	return err;
+}
+
+/*
+ * remove_map(struct super_block *sb,int bindex)
+ *
+ * sb: The super block containing all the current imap info
+ * bindex: the index of the branch that is being removed.
+ *
+ * This assumes that end hasen't been decremented yet.
+ * 
+ * Returns: This function really can't fail. The only thing
+ * that could possibly happen is that it will oops but that 
+ * requires unionfs to be in an inconsistant state which 
+ * shoulden't happen.
+ */
+int remove_map(struct super_block *sb, int bindex)
+{
+	int i;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	for (i = bindex; i < sbend(sb); i++) {
+		spd->usi_map_table[i] = spd->usi_map_table[i + 1];
+		spd->usi_bnum_table[i] = spd->usi_bnum_table[i + 1];
+	}
+	return 0;
+}
+
+#endif
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/print.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/print.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,491 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: print.c,v 1.74 2006/01/13 03:00:24 jsipek Exp $
+ */
+
+/* Print debugging functions */
+
+#ifndef UNIONFS_NDEBUG
+
+#include "unionfs.h"
+
+static int fist_debug_var = 0;
+
+/* get value of debugging variable */
+int fist_get_debug_value(void)
+{
+	return fist_debug_var;
+}
+
+/* set debug level variable and return the previous value */
+int fist_set_debug_value(int val)
+{
+	int prev = fist_debug_var;
+
+	fist_debug_var = val;
+	fist_dprint(1, "unionfs: setting debug level to %d\n", val);
+	return prev;
+}
+
+/*
+ * Utilities used by both client and server
+ * Standard levels:
+ * 0) no debugging
+ * 1) hard failures
+ * 2) soft failures
+ * 3) current test software
+ * 4) main procedure entry points
+ * 5) main procedure exit points
+ * 6) utility procedure entry points
+ * 7) utility procedure exit points
+ * 8) obscure procedure entry points
+ * 9) obscure procedure exit points
+ * 10) random stuff
+ * 11) all <= 1
+ * 12) all <= 2
+ * 13) all <= 3
+ * ...
+ */
+
+void fist_dprint_internal(const char *file, const char *function, int line,
+			  int level, char *str, ...)
+{
+	va_list ap;
+	int var = fist_get_debug_value();
+
+	if (level >= 10 || level < 0) {
+		printk(KERN_ERR "fist_dprint_internal: Invalid level passed"
+		       "from %s:%s:%d\n", file, function, line);
+	}
+
+	if (var == level || (var > 10 && (var - 10) >= level)) {
+		va_start(ap, str);
+		vprintk(str, ap);
+		va_end(ap);
+	}
+	return;
+}
+
+static int num_indents = 0;
+static char indent_buf[80] =
+    "                                                                               ";
+char *add_indent(void)
+{
+	indent_buf[num_indents] = ' ';
+	num_indents++;
+	if (num_indents > 79)
+		num_indents = 79;
+	indent_buf[num_indents] = '\0';
+	return indent_buf;
+}
+
+char *del_indent(void)
+{
+	if (num_indents <= 0)
+		return "<IBUG>";
+	indent_buf[num_indents] = ' ';
+	num_indents--;
+	indent_buf[num_indents] = '\0';
+	return indent_buf;
+}
+
+static void fist_print_generic_inode3(const char *str, const char *str2,
+				      const struct inode *inode)
+{
+	if (!inode) {
+		printk("PI:%s%s: NULL INODE PASSED!\n", str, str2);
+		return;
+	}
+	if (IS_ERR(inode)) {
+		printk("PI:%s%s: ERROR INODE PASSED: %ld\n", str, str2,
+		       PTR_ERR(inode));
+		return;
+	}
+	fist_dprint(8, "PI:%s%s: %s=%lu\n", str, str2, "i_ino", inode->i_ino);
+	fist_dprint(8, "PI:%s%s: %s=%u\n", str, str2, "i_count",
+		    atomic_read(&inode->i_count));
+	fist_dprint(8, "PI:%s%s: %s=%u\n", str, str2, "i_nlink",
+		    inode->i_nlink);
+	fist_dprint(8, "PI:%s%s: %s=%o\n", str, str2, "i_mode", inode->i_mode);
+	fist_dprint(8, "PI:%s%s: %s=%llu\n", str, str2, "i_size",
+		    inode->i_size);
+	fist_dprint(8, "PI:%s%s: %s=%p\n", str, str2, "i_op", inode->i_op);
+	fist_dprint(8, "PI:%s%s: %s=%p (%s)\n", str, str2, "i_sb",
+		    inode->i_sb, (inode->i_sb ? sbt(inode->i_sb) : "NullTypeSB")
+	    );
+}
+
+void fist_print_generic_inode(const char *str, const struct inode *inode)
+{
+	fist_print_generic_inode3(str, "", inode);
+}
+
+void fist_print_inode(const char *str, const struct inode *inode)
+{
+	int bindex;
+
+	if (!inode) {
+		printk("PI:%s: NULL INODE PASSED!\n", str);
+		return;
+	}
+	if (IS_ERR(inode)) {
+		printk("PI:%s: ERROR INODE PASSED: %ld\n", str, PTR_ERR(inode));
+		return;
+	}
+
+	if (strcmp("unionfs", sbt(inode->i_sb))) {
+		char msg[100];
+		snprintf(msg, sizeof(msg), "Invalid inode passed to"
+			 "fist_print_inode: %s\n", sbt(inode->i_sb));
+		printk(KERN_ERR "%s\n", msg);
+		BUG();
+	}
+
+	fist_print_generic_inode(str, inode);
+
+	if (!itopd(inode))
+		return;
+	fist_dprint(8, "PI:%s: ibstart=%d, ibend=%d\n", str,
+		    ibstart(inode), ibend(inode));
+
+	if (ibstart(inode) == -1)
+		return;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		struct inode *hidden_inode = itohi_index(inode, bindex);
+		char newstr[10];
+		if (!hidden_inode) {
+			fist_dprint(8, "PI:%s: HI#%d: NULL\n", str, bindex);
+			continue;
+		}
+		sprintf(newstr, ": HI%d", bindex);
+		fist_print_generic_inode3(str, newstr, hidden_inode);
+	}
+}
+
+static void fist_print_generic_file3(const char *str, const char *str2,
+				     const struct file *file)
+{
+	fist_dprint(8, "PF:%s%s: %s=0x%p\n", str, str2, "f_dentry",
+		    file->f_dentry);
+	fist_dprint(8, "PF:%s%s: name=%s\n", str, str2,
+		    file->f_dentry->d_name.name);
+	if (file->f_dentry->d_inode) {
+		fist_dprint(8, "PF:%s%s: %s=%lu\n", str, str2,
+			    "f_dentry->d_inode->i_ino",
+			    file->f_dentry->d_inode->i_ino);
+		fist_dprint(8, "PF:%s%s: %s=%o\n", str, str2,
+			    "f_dentry->d_inode->i_mode",
+			    file->f_dentry->d_inode->i_mode);
+	}
+	fist_dprint(8, "PF:%s%s: %s=0x%p\n", str, str2, "f_op", file->f_op);
+	fist_dprint(8, "PF:%s%s: %s=0x%x\n", str, str2, "f_mode", file->f_mode);
+	fist_dprint(8, "PF:%s%s: %s=0x%llu\n", str, str2, "f_pos", file->f_pos);
+	fist_dprint(8, "PF:%s%s: %s=%u\n", str, str2, "f_count",
+		    atomic_read(&file->f_count));
+	fist_dprint(8, "PF:%s%s: %s=0x%x\n", str, str2, "f_flags",
+		    file->f_flags);
+	fist_dprint(8, "PF:%s%s: %s=%lu\n", str, str2, "f_version",
+		    file->f_version);
+}
+
+static void fist_print_generic_file(const char *str, const struct file *file)
+{
+	fist_print_generic_file3(str, "", file);
+}
+
+void fist_print_file(const char *str, const struct file *file)
+{
+	struct file *hidden_file;
+
+	if (!file) {
+		fist_dprint(8, "PF:%s: NULL FILE PASSED!\n", str);
+		return;
+	}
+
+	if (strcmp("unionfs", sbt(file->f_dentry->d_sb))) {
+		char msg[100];
+		snprintf(msg, sizeof(msg), "Invalid file passed to"
+			 "fist_print_file: %s\n", sbt(file->f_dentry->d_sb));
+		printk(KERN_ERR "%s\n", msg);
+		BUG();
+
+	}
+
+	fist_print_generic_file(str, file);
+
+	if (ftopd(file)) {
+		int bindex;
+
+		fist_dprint(8, "PF:%s: fbstart=%d, fbend=%d\n", str,
+			    fbstart(file), fbend(file));
+
+		for (bindex = fbstart(file); bindex <= fbend(file); bindex++) {
+			char newstr[10];
+			hidden_file = ftohf_index(file, bindex);
+			if (!hidden_file) {
+				fist_dprint(8, "PF:%s: HF#%d is NULL\n", str,
+					    bindex);
+				continue;
+			}
+			sprintf(newstr, ": HF%d", bindex);
+			fist_print_generic_file3(str, newstr, hidden_file);
+		}
+	}
+}
+
+static char mode_to_type(mode_t mode)
+{
+	if (S_ISDIR(mode))
+		return 'd';
+	if (S_ISLNK(mode))
+		return 'l';
+	if (S_ISCHR(mode))
+		return 'c';
+	if (S_ISBLK(mode))
+		return 'b';
+	if (S_ISREG(mode))
+		return 'f';
+	return '?';
+}
+
+void __fist_print_dentry(const char *str, const struct dentry *dentry,
+			 int check)
+{
+	if (!dentry) {
+		fist_dprint(8, "PD:%s: NULL DENTRY PASSED!\n", str);
+		return;
+	}
+	if (IS_ERR(dentry)) {
+		fist_dprint(8, "PD:%s: ERROR DENTRY (%ld)!\n", str,
+			    PTR_ERR(dentry));
+		return;
+	}
+
+	if (strcmp("unionfs", sbt(dentry->d_sb))) {
+		char msg[100];
+		snprintf(msg, sizeof(msg), "Invalid dentry passed to"
+			 "fist_print_dentry: %s\n", sbt(dentry->d_sb));
+		printk(KERN_ERR "%s\n", msg);
+		BUG();
+
+	}
+
+	__fist_print_generic_dentry(str, "", dentry, check);
+
+	if (!dtopd(dentry))
+		return;
+	fist_dprint(8, "PD:%s: dbstart=%d, dbend=%d, dbopaque=%d\n",
+		    str, dbstart(dentry), dbend(dentry), dbopaque(dentry));
+	if (dbstart(dentry) != -1) {
+		int bindex;
+		char newstr[10];
+		struct dentry *hidden_dentry;
+
+		for (bindex = dbstart(dentry); bindex <= dbend(dentry);
+		     bindex++) {
+			hidden_dentry = dtohd_index(dentry, bindex);
+			if (!hidden_dentry) {
+				fist_dprint(8, "PD:%s: HD#%d: NULL\n", str,
+					    bindex);
+				continue;
+			}
+			sprintf(newstr, ": HD%d", bindex);
+			fist_print_generic_dentry3(str, newstr, hidden_dentry);
+		}
+	}
+}
+void fist_print_dentry(const char *str, const struct dentry *dentry)
+{
+	__fist_print_dentry(str, dentry, 1);
+}
+
+void __fist_print_generic_dentry(const char *str, const char *str2, const
+				 struct dentry *dentry, int check)
+{
+	if (!dentry) {
+		fist_dprint(8, "PD:%s%s: NULL DENTRY PASSED!\n", str, str2);
+		return;
+	}
+	if (IS_ERR(dentry)) {
+		fist_dprint(8, "PD:%s%s: ERROR DENTRY (%ld)!\n", str, str2,
+			    PTR_ERR(dentry));
+		return;
+	}
+
+	fist_dprint(8, "PD:%s%s: dentry = %p\n", str, str2, dentry);
+	fist_dprint(8, "PD:%s%s: %s=%d\n", str, str2, "d_count",
+		    atomic_read(&dentry->d_count));
+	fist_dprint(8, "PD:%s%s: %s=%x\n", str, str2, "d_flags",
+		    (int)dentry->d_flags);
+	fist_dprint(8, "PD:%s%s: %s=\"%s\" (len = %d)\n", str, str2,
+		    "d_name.name", dentry->d_name.name, dentry->d_name.len);
+	fist_dprint(8, "PD:%s%s: %s=%p (%s)\n", str, str2, "d_sb", dentry->d_sb,
+		    sbt(dentry->d_sb));
+	fist_dprint(8, "PD:%s%s: %s=%p\n", str, str2, "d_inode",
+		    dentry->d_inode);
+	if (dentry->d_inode) {
+		fist_dprint(8, "PD:%s%s: %s=%ld (%s)\n", str, str2,
+			    "d_inode->i_ino", dentry->d_inode->i_ino,
+			    sbt(dentry->d_inode->i_sb));
+		fist_dprint(8, "PD:%s%s: dentry->d_inode->i_mode: %c%o\n", str,
+			    str2, mode_to_type(dentry->d_inode->i_mode),
+			    dentry->d_inode->i_mode);
+	}
+	fist_dprint(8, "PD:%s%s: %s=%p (%s)\n", str, str2, "d_parent",
+		    dentry->d_parent,
+		    (dentry->d_parent ? sbt(dentry->d_parent->d_sb) : "nil"));
+	fist_dprint(8, "PD:%s%s: %s=\"%s\"\n", str, str2,
+		    "d_parent->d_name.name", dentry->d_parent->d_name.name);
+	fist_dprint(8, "PD:%s%s: %s=%d\n", str, str2, "d_parent->d_count",
+		    atomic_read(&dentry->d_parent->d_count));
+	fist_dprint(8, "PD:%s%s: %s=%p\n", str, str2, "d_op", dentry->d_op);
+	fist_dprint(8, "PD:%s%s: %s=%p\n", str, str2, "d_fsdata",
+		    dentry->d_fsdata);
+	fist_dprint(8, "PD:%s%s: %s=%d\n", str, str2, "hlist_unhashed(d_hash)",
+		    hlist_unhashed(&((struct dentry *)dentry)->d_hash));
+	/* After we have printed it, we can assert something about it. */
+	if (check)
+		BUG_ON(atomic_read(&dentry->d_count) <= 0);
+}
+
+void fist_print_generic_dentry(const char *str, const struct dentry *dentry)
+{
+	__fist_print_generic_dentry(str, "", dentry, 1);
+}
+void fist_print_generic_dentry3(const char *str, const char *str2,
+				const struct dentry *dentry)
+{
+	__fist_print_generic_dentry(str, str2, dentry, 1);
+}
+
+void fist_checkinode(const struct inode *inode, const char *msg)
+{
+	if (!inode) {
+		printk(KERN_WARNING "fist_checkinode - inode is NULL! (%s)\n",
+		       msg);
+		return;
+	}
+	if (!itopd(inode)) {
+		fist_dprint(8, "fist_checkinode(%ld) - no private data (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+	if ((itopd(inode)->b_start < 0) || !itohi(inode)) {
+		fist_dprint(8,
+			    "fist_checkinode(%ld) - underlying is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+	if (!inode->i_sb) {
+		fist_dprint(8,
+			    "fist_checkinode(%ld) - inode->i_sb is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+	fist_dprint(8, "inode->i_sb->s_type %p\n", inode->i_sb->s_type);
+	if (!inode->i_sb->s_type) {
+		fist_dprint(8,
+			    "fist_checkinode(%ld) - inode->i_sb->s_type is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+	fist_dprint(6,
+		    "CI: %s: inode->i_count = %d, hidden_inode->i_count = %d, inode = %lu, sb = %s, hidden_sb = %s\n",
+		    msg, atomic_read(&inode->i_count),
+		    itopd(inode)->b_start >=
+		    0 ? atomic_read(&itohi(inode)->i_count) : -1, inode->i_ino,
+		    inode->i_sb->s_type->name,
+		    itopd(inode)->b_start >=
+		    0 ? itohi(inode)->i_sb->s_type->name : "(none)");
+}
+
+void fist_print_sb(const char *str, const struct super_block *sb)
+{
+	struct super_block *hidden_superblock;
+
+	if (!sb) {
+		fist_dprint(8, "PSB:%s: NULL SB PASSED!\n", str);
+		return;
+	}
+
+	fist_dprint(8, "PSB:%s: %s=%u\n", str, "s_blocksize",
+		    (int)sb->s_blocksize);
+	fist_dprint(8, "PSB:%s: %s=%u\n", str, "s_blocksize_bits",
+		    (int)sb->s_blocksize_bits);
+	fist_dprint(8, "PSB:%s: %s=0x%x\n", str, "s_flags", (int)sb->s_flags);
+	fist_dprint(8, "PSB:%s: %s=0x%x\n", str, "s_magic", (int)sb->s_magic);
+	fist_dprint(8, "PSB:%s: %s=%llu\n", str, "s_maxbytes", sb->s_maxbytes);
+	fist_dprint(8, "PSB:%s: %s=%d\n", str, "s_count", (int)sb->s_count);
+	fist_dprint(8, "PSB:%s: %s=%d\n", str, "s_active",
+		    (int)atomic_read(&sb->s_active));
+	if (stopd(sb))
+		fist_dprint(8, "sbstart=%d, sbend=%d\n", sbstart(sb),
+			    sbend(sb));
+	fist_dprint(8, "\n");
+
+	if (stopd(sb)) {
+		int bindex;
+		for (bindex = sbstart(sb); bindex <= sbend(sb); bindex++) {
+			hidden_superblock = stohs_index(sb, bindex);
+			if (!hidden_superblock) {
+				fist_dprint(8, "PSB:%s: HS#%d is NULL", str,
+					    bindex);
+				continue;
+			}
+
+			fist_dprint(8, "PSB:%s: HS#%d: %s=%u\n", str, bindex,
+				    "s_blocksize",
+				    (int)hidden_superblock->s_blocksize);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=%u\n", str, bindex,
+				    "s_blocksize_bits",
+				    (int)hidden_superblock->s_blocksize_bits);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=0x%x\n", str, bindex,
+				    "s_flags", (int)hidden_superblock->s_flags);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=0x%x\n", str, bindex,
+				    "s_magic", (int)hidden_superblock->s_magic);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=%llu\n", str, bindex,
+				    "s_maxbytes",
+				    hidden_superblock->s_maxbytes);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=%d\n", str, bindex,
+				    "s_count", (int)hidden_superblock->s_count);
+			fist_dprint(8, "PSB:%s: HS#%d: %s=%d\n", str, bindex,
+				    "s_active",
+				    (int)atomic_read(&hidden_superblock->
+						     s_active));
+		}
+	}
+}
+
+#endif
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/rdstate.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/rdstate.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: rdstate.c,v 1.31 2006/01/14 19:56:01 dquigley Exp $
+ */
+
+#include "unionfs.h"
+
+/* This file contains the routines for maintaining readdir state. */
+/* There are two structures here, rdstate which is a hash table
+ * of the second structure which is a filldir_node. */
+
+/* This is a kmem_cache_t for filldir nodes, because we allocate a lot of them
+ * and they shouldn't waste memory.  If the node has a small name (as defined
+ * by the dentry structure), then we use an inline name to preserve kmalloc
+ * space. */
+static kmem_cache_t *unionfs_filldir_cachep;
+int init_filldir_cache(void)
+{
+	unionfs_filldir_cachep =
+	    kmem_cache_create("unionfs_filldir", sizeof(struct filldir_node), 0,
+			      SLAB_RECLAIM_ACCOUNT, NULL, NULL);
+
+	if (!unionfs_filldir_cachep) {
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void destroy_filldir_cache(void)
+{
+	if (!unionfs_filldir_cachep)
+		return;
+	if (kmem_cache_destroy(unionfs_filldir_cachep)) {
+		printk(KERN_ERR
+		       "unionfs_filldir_cache: not all structures were freed\n");
+	}
+	return;
+}
+
+/* This is a tuning parameter that tells us roughly how big to make the
+ * hash table in directory entries per page.  This isn't perfect, but
+ * at least we get a hash table size that shouldn't be too overloaded.
+ * The following averages are based on my home directory.
+ * 14.44693	Overall
+ * 12.29	Single Page Directories
+ * 117.93	Multi-page directories
+ */
+#define DENTPAGE 4096
+#define DENTPERONEPAGE 12
+#define DENTPERPAGE 118
+#define MINHASHSIZE 1
+static int guesstimate_hash_size(struct inode *inode)
+{
+	struct inode *hidden_inode;
+	int bindex;
+	int hashsize = MINHASHSIZE;
+
+	if (itopd(inode)->uii_hashsize > 0)
+		return itopd(inode)->uii_hashsize;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		if (!(hidden_inode = itohi_index(inode, bindex)))
+			continue;
+
+		if (hidden_inode->i_size == DENTPAGE) {
+			hashsize += DENTPERONEPAGE;
+		} else {
+			hashsize +=
+			    (hidden_inode->i_size / DENTPAGE) * DENTPERPAGE;
+		}
+	}
+
+	return hashsize;
+}
+
+int init_rdstate(struct file *file)
+{
+	BUG_ON(sizeof(loff_t) != (sizeof(unsigned int) + sizeof(unsigned int)));
+	BUG_ON(ftopd(file)->rdstate != NULL);
+
+	ftopd(file)->rdstate =
+	    alloc_rdstate(file->f_dentry->d_inode, fbstart(file));
+	if (!ftopd(file)->rdstate)
+		return -ENOMEM;
+	return 0;
+}
+
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos)
+{
+	struct unionfs_dir_state *rdstate = NULL;
+	struct list_head *pos;
+
+	print_entry("f_pos: %lld", fpos);
+	spin_lock(&itopd(inode)->uii_rdlock);
+	list_for_each(pos, &itopd(inode)->uii_readdircache) {
+		struct unionfs_dir_state *r =
+		    list_entry(pos, struct unionfs_dir_state, uds_cache);
+		if (fpos == rdstate2offset(r)) {
+			itopd(inode)->uii_rdcount--;
+			list_del(&r->uds_cache);
+			rdstate = r;
+			break;
+		}
+	}
+	spin_unlock(&itopd(inode)->uii_rdlock);
+	print_exit_pointer(rdstate);
+	return rdstate;
+}
+
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex)
+{
+	int i = 0;
+	int hashsize;
+	int mallocsize = sizeof(struct unionfs_dir_state);
+	struct unionfs_dir_state *rdstate;
+
+	hashsize = guesstimate_hash_size(inode);
+	mallocsize += hashsize * sizeof(struct list_head);
+	/* Round it up to the next highest power of two. */
+	mallocsize--;
+	mallocsize |= mallocsize >> 1;
+	mallocsize |= mallocsize >> 2;
+	mallocsize |= mallocsize >> 4;
+	mallocsize |= mallocsize >> 8;
+	mallocsize |= mallocsize >> 16;
+	mallocsize++;
+
+	/* This should give us about 500 entries anyway. */
+	if (mallocsize > PAGE_SIZE)
+		mallocsize = PAGE_SIZE;
+
+	hashsize =
+	    (mallocsize -
+	     sizeof(struct unionfs_dir_state)) / sizeof(struct list_head);
+
+	rdstate = KMALLOC(mallocsize, GFP_KERNEL);
+	if (!rdstate)
+		return NULL;
+
+	spin_lock(&itopd(inode)->uii_rdlock);
+	if (itopd(inode)->uii_cookie >= (MAXRDCOOKIE - 1))
+		itopd(inode)->uii_cookie = 1;
+	else
+		itopd(inode)->uii_cookie++;
+
+	rdstate->uds_cookie = itopd(inode)->uii_cookie;
+	spin_unlock(&itopd(inode)->uii_rdlock);
+	rdstate->uds_offset = 1;
+	rdstate->uds_access = jiffies;
+	rdstate->uds_bindex = bindex;
+	rdstate->uds_dirpos = 0;
+	rdstate->uds_hashentries = 0;
+	rdstate->uds_size = hashsize;
+	for (i = 0; i < rdstate->uds_size; i++)
+		INIT_LIST_HEAD(&rdstate->uds_list[i]);
+
+	return rdstate;
+}
+
+static void free_filldir_node(struct filldir_node *node)
+{
+	if (node->namelen >= DNAME_INLINE_LEN_MIN)
+		KFREE(node->name);
+	kmem_cache_free(unionfs_filldir_cachep, node);
+}
+
+void free_rdstate(struct unionfs_dir_state *state)
+{
+	struct filldir_node *tmp;
+	int i;
+
+	for (i = 0; i < state->uds_size; i++) {
+		struct list_head *head = &(state->uds_list[i]);
+		struct list_head *pos, *n;
+
+		/* traverse the list and deallocate space */
+		list_for_each_safe(pos, n, head) {
+			tmp = list_entry(pos, struct filldir_node, file_list);
+			list_del(&tmp->file_list);
+			free_filldir_node(tmp);
+		}
+	}
+
+	KFREE(state);
+}
+
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen)
+{
+	int index;
+	unsigned int hash;
+	struct list_head *head;
+	struct list_head *pos;
+	struct filldir_node *cursor = NULL;
+	int found = 0;
+
+	/* If we print entry, we end up with spurious data. */
+	/* print_entry("name = %*s", namelen, name); */
+	print_entry_location();
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->uds_size;
+
+	head = &(rdstate->uds_list[index]);
+	list_for_each(pos, head) {
+		cursor = list_entry(pos, struct filldir_node, file_list);
+
+		if (cursor->namelen == namelen && cursor->hash == hash
+		    && !strncmp(cursor->name, name, namelen)) {
+			/* a duplicate exists, and hence no need to create entry to the list */
+			found = 1;
+			/* if the duplicate is in this branch, then the file system is corrupted. */
+			if (cursor->bindex == rdstate->uds_bindex) {
+				//buf->error = err = -EIO;
+				fist_dprint(8,
+					    "Possible I/O error unionfs_filldir: a file is duplicated in the same branch %d: %s\n",
+					    rdstate->uds_bindex, cursor->name);
+			}
+			break;
+		}
+	}
+
+	if (!found) {
+		cursor = NULL;
+	}
+	print_exit_pointer(cursor);
+	return cursor;
+}
+
+inline struct filldir_node *alloc_filldir_node(const char *name, int namelen,
+					       unsigned int hash, int bindex)
+{
+	struct filldir_node *newnode;
+
+	newnode =
+	    (struct filldir_node *)kmem_cache_alloc(unionfs_filldir_cachep,
+						    SLAB_KERNEL);
+	if (!newnode)
+		goto out;
+
+      out:
+	return newnode;
+}
+
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout)
+{
+	struct filldir_node *new;
+	unsigned int hash;
+	int index;
+	int err = 0;
+	struct list_head *head;
+
+	/* We can't print this because we end up Oopsing. */
+	/* print_entry("name = %*s", namelen, name); */
+	print_entry_location();
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->uds_size;
+	head = &(rdstate->uds_list[index]);
+
+	new = alloc_filldir_node(name, namelen, hash, bindex);
+	if (!new) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&new->file_list);
+	new->namelen = namelen;
+	new->hash = hash;
+	new->bindex = bindex;
+	new->whiteout = whiteout;
+
+	if (namelen < DNAME_INLINE_LEN_MIN) {
+		new->name = new->iname;
+	} else {
+		new->name = (char *)KMALLOC(namelen + 1, GFP_KERNEL);
+		if (!new->name) {
+			kmem_cache_free(unionfs_filldir_cachep, new);
+			new = NULL;
+			goto out;
+		}
+	}
+
+	memcpy(new->name, name, namelen);
+	new->name[namelen] = '\0';
+
+	rdstate->uds_hashentries++;
+
+	list_add(&(new->file_list), head);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/rename.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/rename.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,919 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: rename.c,v 1.40.4.3 2006/06/12 01:51:35 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+static int do_rename(struct inode *old_dir, struct dentry *old_dentry,
+		     struct inode *new_dir, struct dentry *new_dentry,
+		     int bindex, struct dentry **wh_old)
+{
+	int err = 0;
+	struct dentry *hidden_old_dentry;
+	struct dentry *hidden_new_dentry;
+	struct dentry *hidden_old_dir_dentry;
+	struct dentry *hidden_new_dir_dentry;
+	struct dentry *hidden_wh_dentry;
+	struct dentry *hidden_wh_dir_dentry;
+	char *wh_name = NULL;
+
+	print_entry(" bindex=%d", bindex);
+
+	fist_print_dentry("IN: do_rename, old_dentry", old_dentry);
+	fist_print_dentry("IN: do_rename, new_dentry", new_dentry);
+	fist_dprint(7, "do_rename for bindex = %d\n", bindex);
+
+	hidden_new_dentry = dtohd_index(new_dentry, bindex);
+	hidden_old_dentry = dtohd_index(old_dentry, bindex);
+
+	if (!hidden_new_dentry) {
+		hidden_new_dentry =
+		    create_parents(new_dentry->d_parent->d_inode, new_dentry,
+				   bindex);
+		if (IS_ERR(hidden_new_dentry)) {
+			fist_dprint(7,
+				    "error creating directory tree for rename, bindex = %d\n",
+				    bindex);
+			err = PTR_ERR(hidden_new_dentry);
+			goto out;
+		}
+	}
+
+	wh_name = alloc_whname(new_dentry->d_name.name, new_dentry->d_name.len);
+	if (IS_ERR(wh_name)) {
+		err = PTR_ERR(wh_name);
+		goto out;
+	}
+
+	hidden_wh_dentry =
+	    LOOKUP_ONE_LEN(wh_name, hidden_new_dentry->d_parent,
+			   new_dentry->d_name.len + WHLEN);
+	if (IS_ERR(hidden_wh_dentry)) {
+		err = PTR_ERR(hidden_wh_dentry);
+		goto out;
+	}
+
+	if (hidden_wh_dentry->d_inode) {
+		/* get rid of the whiteout that is existing */
+		if (hidden_new_dentry->d_inode) {
+			printk(KERN_WARNING
+			       "Both a whiteout and a dentry exist when doing a rename!\n");
+			err = -EIO;
+
+			DPUT(hidden_wh_dentry);
+			goto out;
+		}
+
+		hidden_wh_dir_dentry = lock_parent(hidden_wh_dentry);
+		if (!(err = is_robranch_super(old_dentry->d_sb, bindex))) {
+			err =
+			    vfs_unlink(hidden_wh_dir_dentry->d_inode,
+				       hidden_wh_dentry);
+		}
+		DPUT(hidden_wh_dentry);
+		unlock_dir(hidden_wh_dir_dentry);
+		if (err)
+			goto out;
+	} else
+		DPUT(hidden_wh_dentry);
+
+	DGET(hidden_old_dentry);
+	hidden_old_dir_dentry = GET_PARENT(hidden_old_dentry);
+	hidden_new_dir_dentry = GET_PARENT(hidden_new_dentry);
+
+	lock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+	err = is_robranch_super(old_dentry->d_sb, bindex);
+	if (err)
+		goto out_unlock;
+
+	/* ready to whiteout for old_dentry.
+	   caller will create the actual whiteout,
+	   and must dput(*wh_old) */
+	if (wh_old) {
+		char *whname;
+		whname = alloc_whname(old_dentry->d_name.name,
+				      old_dentry->d_name.len);
+		err = PTR_ERR(whname);
+		if (IS_ERR(whname))
+			goto out_unlock;
+		*wh_old = LOOKUP_ONE_LEN(whname, hidden_old_dir_dentry,
+					 old_dentry->d_name.len + WHLEN);
+		KFREE(whname);
+		err = PTR_ERR(*wh_old);
+		if (IS_ERR(*wh_old)) {
+			*wh_old = NULL;
+			goto out_unlock;
+		}
+	}
+
+		fist_print_dentry("NEWBEF", new_dentry);
+		fist_print_dentry("OLDBEF", old_dentry);
+	err = vfs_rename(hidden_old_dir_dentry->d_inode, hidden_old_dentry,
+			 hidden_new_dir_dentry->d_inode, hidden_new_dentry);
+		fist_print_dentry("NEWAFT", new_dentry);
+		fist_print_dentry("OLDAFT", old_dentry);
+
+      out_unlock:
+	unlock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+	DPUT(hidden_old_dir_dentry);
+	DPUT(hidden_new_dir_dentry);
+	DPUT(hidden_old_dentry);
+
+      out:
+	if (!err) {
+		/* Fixup the newdentry. */
+		if (bindex < dbstart(new_dentry))
+			set_dbstart(new_dentry, bindex);
+		else if (bindex > dbend(new_dentry))
+			set_dbend(new_dentry, bindex);
+	}
+
+	KFREE(wh_name);
+
+	fist_print_dentry("OUT: do_rename, old_dentry", old_dentry);
+	fist_print_dentry("OUT: do_rename, new_dentry", new_dentry);
+
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_rename_whiteout(struct inode *old_dir,
+				   struct dentry *old_dentry,
+				   struct inode *new_dir,
+				   struct dentry *new_dentry)
+{
+	int err = 0;
+	int bindex, bwh_old;
+	int old_bstart, old_bend;
+	int new_bstart, new_bend;
+	int do_copyup = -1;
+	struct dentry *parent_dentry;
+	int local_err = 0;
+	int eio = 0;
+	int revert = 0;
+	struct dentry *wh_old = NULL;
+
+	print_entry_location();
+
+	old_bstart = dbstart(old_dentry);
+	bwh_old = old_bstart;
+	old_bend = dbend(old_dentry);
+	parent_dentry = old_dentry->d_parent;
+
+	new_bstart = dbstart(new_dentry);
+	new_bend = dbend(new_dentry);
+
+	/* Rename source to destination. */
+	err = do_rename(old_dir, old_dentry, new_dir, new_dentry, old_bstart,
+			&wh_old);
+	if (err) {
+		if (!IS_COPYUP_ERR(err)) {
+			goto out;
+		}
+		do_copyup = old_bstart - 1;
+	} else {
+		revert = 1;
+	}
+
+	/* Unlink all instances of destination that exist to the left of
+	 * bstart of source. On error, revert back, goto out.
+	 */
+	for (bindex = old_bstart - 1; bindex >= new_bstart; bindex--) {
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		unlink_dentry = dtohd_index(new_dentry, bindex);
+		if (!unlink_dentry) {
+			continue;
+		}
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, bindex))) {
+			err =
+			    vfs_unlink(unlink_dir_dentry->d_inode,
+				       unlink_dentry);
+		}
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+		if (!err) {
+			if (bindex != new_bstart) {
+				DPUT(unlink_dentry);
+				set_dtohd_index(new_dentry, bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			do_copyup = bindex - 1;
+		} else if (revert) {
+			DPUT(wh_old);
+			goto revert;
+		}
+	}
+
+	if (do_copyup != -1) {
+		for (bindex = do_copyup; bindex >= 0; bindex--) {
+			/* copyup the file into some left directory, so that you can rename it */
+			err =
+			    copyup_dentry(old_dentry->d_parent->d_inode,
+					  old_dentry, old_bstart, bindex, NULL,
+					  old_dentry->d_inode->i_size);
+			if (!err) {
+				DPUT(wh_old);
+				bwh_old = bindex;
+				err =
+				    do_rename(old_dir, old_dentry, new_dir,
+					      new_dentry, bindex, &wh_old);
+				break;
+			}
+		}
+	}
+
+	/* Create whiteout for source, only if:
+	 * (1) There is more than one underlying instance of source.
+	 * (2) We did a copy_up
+	 */
+	if ((old_bstart != old_bend) || (do_copyup != -1)) {
+		struct dentry *hidden_parent;
+		BUG_ON(!wh_old || IS_ERR(wh_old) || wh_old->d_inode
+		       || bwh_old < 0);
+		hidden_parent = lock_parent(wh_old);
+		local_err = vfs_create(hidden_parent->d_inode, wh_old, S_IRUGO,
+				       NULL);
+		unlock_dir(hidden_parent);
+		if (!local_err)
+			set_dbopaque(old_dentry, bwh_old);
+		else {
+			/* We can't fix anything now, so we cop-out and use -EIO. */
+			printk
+			    ("<0>We can't create a whiteout for the source in rename!\n");
+			err = -EIO;
+		}
+	}
+
+      out:
+	DPUT(wh_old);
+	print_exit_status(err);
+	return err;
+
+      revert:
+	/* Do revert here. */
+	local_err = unionfs_refresh_hidden_dentry(new_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the new refresh failed.\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_hidden_dentry(old_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the old refresh failed.\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (!dtohd_index(new_dentry, bindex)
+	    || !dtohd_index(new_dentry, bindex)->d_inode) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the object disappeared from under us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (dtohd_index(old_dentry, bindex)
+	    && dtohd_index(old_dentry, bindex)->d_inode) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the object was created underneath us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	local_err =
+	    do_rename(new_dir, new_dentry, old_dir, old_dentry, old_bstart,
+		      NULL);
+
+	/* If we can't fix it, then we cop-out with -EIO. */
+	if (local_err) {
+		printk(KERN_WARNING "Revert failed in rename!\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+	local_err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+
+      revert_out:
+	if (eio)
+		err = eio;
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Unfortunately, we cannot simply call things like dbstart() in different
+ * places of the rename code because we move things around. So, we use this
+ * structure to pass the necessary information around to all the places that
+ * need it.
+ */
+struct rename_info {
+	int do_copyup;
+	int do_whiteout;
+	int rename_ok;
+
+	int old_bstart;
+	int old_bend;
+	int new_bstart;
+	int new_bend;
+
+	int isdir;		/* Is the source a directory? */
+	int clobber;		/* Are we clobbering the destination? */
+
+	int bwh_old;		/* where we create the whiteout */
+	struct dentry *wh_old;	/* lookup and set by do_rename() */
+};
+#ifdef UNIONFS_DELETE_ALL
+/*
+ * Rename all occurences of source except for the leftmost destination
+ */
+static int __rename_all(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry,
+			fd_set * success_mask, struct rename_info *info)
+{
+	int bindex;
+
+	int err = 0;
+
+	print_entry_location();
+
+	/* Loop through all the branches from right to left and rename all
+	 * instances of source to destination, except the leftmost destination
+	 */
+	for (bindex = info->old_bend; bindex >= info->old_bstart; bindex--) {
+		/* We don't rename if there is no source. */
+		if (dtohd_index(old_dentry, bindex) == NULL)
+			continue;
+
+		/* we rename the bstart of destination only at the last of
+		 * all operations, so that we don't lose it on error
+		 */
+		if (info->clobber && (bindex == info->new_bstart))
+			continue;
+
+		DPUT(info->wh_old);
+		info->bwh_old = bindex;
+		/* We shouldn't have a handle on this if there is no inode. */
+		err =
+		    do_rename(old_dir, old_dentry, new_dir, new_dentry, bindex,
+			      &info->wh_old);
+		if (!err) {
+			/* For reverting. */
+			FD_SET(bindex, success_mask);
+			/* So we know not to copyup on failures the right */
+			info->rename_ok = bindex;
+		} else if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				break;
+			}
+
+			/* we need a whiteout... */
+			info->do_whiteout = bindex - 1;
+
+			if (bindex == info->old_bstart)
+				/* ...and a copyup */
+				info->do_copyup = bindex - 1;
+
+			err = 0;	/* reset error */
+		} else
+			break;	/* error is set by do_rename */
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Unlink all destinations (if they exist) to the left of the left-most
+ * source
+ */
+static int __rename_all_unlink(struct inode *old_dir, struct dentry *old_dentry,
+			       struct inode *new_dir, struct dentry *new_dentry,
+			       struct rename_info *info)
+{
+	int bindex;
+
+	struct dentry *unlink_dentry;
+	struct dentry *unlink_dir_dentry;
+
+	int err = 0;
+
+	print_entry_location();
+
+	for (bindex = info->old_bstart - 1; bindex > info->new_bstart; bindex--) {
+		unlink_dentry = dtohd_index(new_dentry, bindex);
+		if (!unlink_dentry)
+			continue;
+
+		/* lock, unlink if possible, copyup times, unlock */
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, bindex)))
+			err =
+			    vfs_unlink(unlink_dir_dentry->d_inode,
+				       unlink_dentry);
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+
+		if (!err) {
+			if (bindex != info->new_bstart) {
+				DPUT(unlink_dentry);
+				set_dtohd_index(new_dentry, bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				break;
+			}
+			info->do_copyup = bindex - 1;
+
+			err = 0;	/* reset error */
+		} else
+			break;	/* err is set by is_ro_branch_super or vfs_unlink */
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Try to revert everything we have done in __rename_all and __rename_all_unlink
+ */
+static int __rename_all_revert(struct inode *old_dir, struct dentry *old_dentry,
+			       struct inode *new_dir, struct dentry *new_dentry,
+			       fd_set * success_mask, struct rename_info *info)
+{
+	int bindex;
+
+	int err;
+	int eio = 0;
+
+	print_entry_location();
+
+	for (bindex = info->old_bstart; bindex <= info->old_bend; bindex++) {
+		if (!FD_ISSET(bindex, success_mask))
+			continue;
+
+		err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the new refresh failed.\n");
+			eio = -EIO;
+		}
+
+		err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the old refresh failed.\n");
+			eio = -EIO;
+			continue;
+		}
+
+		if (!dtohd_index(new_dentry, bindex)
+		    || !dtohd_index(new_dentry, bindex)->d_inode) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the object disappeared from under us!\n");
+			eio = -EIO;
+			continue;
+		}
+
+		if (dtohd_index(old_dentry, bindex)
+		    && dtohd_index(old_dentry, bindex)->d_inode) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the object was created underneath us!\n");
+			eio = -EIO;
+			continue;
+		}
+
+		err =
+		    do_rename(new_dir, new_dentry, old_dir, old_dentry, bindex,
+			      NULL);
+		/* If we can't fix it, then we cop-out with -EIO. */
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename!\n");
+			eio = -EIO;
+		}
+
+		err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+		if (err)
+			eio = -EIO;
+		err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+		if (err)
+			eio = -EIO;
+	}
+
+	print_exit_status(eio);
+	return eio;
+}
+
+/*
+ * Finish off the rename, by either over writing the last destination or
+ * unlinking the last destination to the left of us
+ */
+static int __rename_all_clobber(struct inode *old_dir,
+				struct dentry *old_dentry,
+				struct inode *new_dir,
+				struct dentry *new_dentry,
+				struct rename_info *info)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	if (dtohd_index(old_dentry, info->new_bstart)) {
+		/* rename the last source, knowing we're overwriting something */
+		DPUT(info->wh_old);
+		info->bwh_old = info->new_bstart;
+		err =
+		    do_rename(old_dir, old_dentry, new_dir, new_dentry,
+			      info->new_bstart, &info->wh_old);
+		if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				goto out;
+			}
+			if (info->rename_ok > info->new_bstart) {
+				if ((info->do_copyup == -1)
+				    || (info->new_bstart - 1 < info->do_copyup))
+					info->do_copyup = info->new_bstart - 1;
+			}
+			if ((info->do_whiteout == -1)
+			    || (info->new_bstart - 1 < info->do_whiteout)) {
+				info->do_whiteout = info->new_bstart - 1;
+			}
+			err = 0;	// reset error
+		}
+	} else if (info->new_bstart < info->old_bstart) {
+		/* the newly renamed file would get hidden, let's unlink the
+		 * file to the left of it */
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		unlink_dentry = dtohd_index(new_dentry, info->new_bstart);
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, info->new_bstart)))
+			err = vfs_unlink(unlink_dir_dentry->d_inode,
+					 unlink_dentry);
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+
+		if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				goto out;
+			}
+			if ((info->do_copyup == -1)
+			    || (info->new_bstart - 1 < info->do_copyup))
+				info->do_copyup = info->new_bstart - 1;
+
+			err = 0;	// reset error
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * The function is nasty, nasty, nasty, but so is rename. :(
+ */
+static int unionfs_rename_all(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct dentry *parent_dentry = NULL;
+	int err = 0;
+	int eio;
+
+	/* These variables control error handling. */
+	fd_set success_mask;
+	char *name = NULL;
+
+	/* unfortunately, we have to resort to this, because dbstart/dbend would
+	   return different things in different place of the rename code */
+	struct rename_info info;
+
+	info.rename_ok = FD_SETSIZE;	/* The last rename that is ok. */
+	info.do_copyup = -1;	/* Where we should start copyup. */
+	info.do_whiteout = -1;	/* Where we should start whiteouts of the source. */
+	info.wh_old = NULL;
+	info.bwh_old = -1;
+
+	print_entry_location();
+
+	parent_dentry = old_dentry->d_parent;
+	name = KMALLOC(old_dentry->d_name.len + 1, GFP_KERNEL);
+	if (!name) {
+		err = -ENOMEM;
+		goto out;
+	}
+	strncpy(name, old_dentry->d_name.name, old_dentry->d_name.len + 1);
+
+	info.new_bstart = dbstart(new_dentry);
+	info.new_bend = dbend(new_dentry);
+
+	info.old_bstart = dbstart(old_dentry);
+	info.old_bend = dbend(old_dentry);
+
+	BUG_ON(info.new_bstart < 0);
+	BUG_ON(info.old_bstart < 0);
+
+	/* The failure mask only can deal with FD_SETSIZE entries. */
+	BUG_ON(info.old_bend > FD_SETSIZE);
+	BUG_ON(info.new_bend > FD_SETSIZE);
+	FD_ZERO(&success_mask);
+
+	/* Life is simpler if the dentry doesn't exist. */
+	info.clobber =
+	    (dtohd_index(new_dentry, info.new_bstart)->d_inode) ? 1 : 0;
+	info.isdir = S_ISDIR(old_dentry->d_inode->i_mode);
+
+	/* rename everything we can */
+	err =
+	    __rename_all(old_dir, old_dentry, new_dir, new_dentry,
+			 &success_mask, &info);
+	if (err)
+		goto revert;
+
+	/* unlink destinations even further left */
+	err =
+	    __rename_all_unlink(old_dir, old_dentry, new_dir, new_dentry,
+				&info);
+	if (err)
+		goto revert;
+
+	if (info.clobber) {
+		/* Now we need to handle the leftmost of the destination. */
+		err =
+		    __rename_all_clobber(old_dir, old_dentry, new_dir,
+					 new_dentry, &info);
+		if (err)
+			goto revert;
+	}
+
+	/* Copy up if necessary */
+	if (info.do_copyup != -1) {
+		int bindex;
+
+		for (bindex = info.do_copyup; bindex >= 0; bindex--) {
+			err =
+			    copyup_dentry(old_dentry->d_parent->d_inode,
+					  old_dentry, info.old_bstart, bindex,
+					  NULL, old_dentry->d_inode->i_size);
+			if (!err) {
+				DPUT(info.wh_old);
+				info.bwh_old = bindex;
+				err =
+				    do_rename(old_dir, old_dentry, new_dir,
+					      new_dentry, bindex, &info.wh_old);
+				break;
+			}
+		}
+	}
+
+	/* Create a whiteout for the source. */
+	if (info.do_whiteout != -1) {
+		struct dentry *hidden_parent;
+		BUG_ON(info.do_whiteout < 0
+		       || !info.wh_old || IS_ERR(info.wh_old)
+		       || info.wh_old->d_inode || info.bwh_old < 0);
+		hidden_parent = lock_parent(info.wh_old);
+		err = vfs_create(hidden_parent->d_inode, info.wh_old, S_IRUGO,
+				 NULL);
+		unlock_dir(hidden_parent);
+		if (!err)
+			set_dbopaque(old_dentry, info.bwh_old);
+		else {
+			/* We can't fix anything now, so we -EIO. */
+			printk(KERN_WARNING "We can't create a whiteout for the"
+			       "source in rename!\n");
+			err = -EIO;
+			goto out;
+		}
+	}
+
+	/* We are at the point where reverting doesn't happen. */
+	goto out;
+
+      revert:
+	/* something bad happened, try to revert */
+	eio =
+	    __rename_all_revert(old_dir, old_dentry, new_dir, new_dentry,
+				&success_mask, &info);
+	if (eio)
+		err = eio;
+
+      out:
+	DPUT(info.wh_old);
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+#endif
+
+static struct dentry *lookup_whiteout(struct dentry *dentry)
+{
+	char *whname;
+	int bindex = -1, bstart = -1, bend = -1;
+	struct dentry *parent, *hidden_parent, *wh_dentry;
+
+	whname = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(whname))
+		return (void *)whname;
+
+	parent = GET_PARENT(dentry);
+	lock_dentry(parent);
+	bstart = dbstart(parent);
+	bend = dbend(parent);
+	wh_dentry = ERR_PTR(-ENOENT);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_parent = dtohd_index(parent, bindex);
+		if (!hidden_parent)
+			continue;
+		wh_dentry =
+		    LOOKUP_ONE_LEN(whname, hidden_parent,
+				   dentry->d_name.len + WHLEN);
+		if (IS_ERR(wh_dentry))
+			continue;
+		if (wh_dentry->d_inode)
+			break;
+		DPUT(wh_dentry);
+		wh_dentry = ERR_PTR(-ENOENT);
+	}
+	unlock_dentry(parent);
+	DPUT(parent);
+	KFREE(whname);
+	return wh_dentry;
+}
+
+/* We can't copyup a directory, because it may involve huge
+ * numbers of children, etc.  Doing that in the kernel would
+ * be bad, so instead we let the userspace recurse and ask us
+ * to copy up each file separately
+ */
+static int may_rename_dir(struct dentry *dentry)
+{
+	int err, bstart;
+
+	err = check_empty(dentry, NULL);
+	if (err == -ENOTEMPTY) {
+		if (is_robranch(dentry))
+			return -EXDEV;
+	} else if (err)
+		return err;
+
+	bstart = dbstart(dentry);
+	if (dbend(dentry) == bstart || dbopaque(dentry) == bstart)
+		return 0;
+
+	set_dbstart(dentry, bstart + 1);
+	err = check_empty(dentry, NULL);
+	set_dbstart(dentry, bstart);
+	if (err == -ENOTEMPTY)
+		err = -EXDEV;
+	return err;
+}
+
+int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *wh_dentry;
+
+	print_entry_location();
+
+	double_lock_dentry(old_dentry, new_dentry);
+
+	fist_checkinode(old_dir, "unionfs_rename-old_dir");
+	fist_checkinode(new_dir, "unionfs_rename-new_dir");
+	fist_print_dentry("IN: unionfs_rename, old_dentry", old_dentry);
+	fist_print_dentry("IN: unionfs_rename, new_dentry", new_dentry);
+
+	if (!S_ISDIR(old_dentry->d_inode->i_mode))
+	err = unionfs_partial_lookup(old_dentry);
+	else
+		err = may_rename_dir(old_dentry);
+	if (err)
+		goto out;
+	err = unionfs_partial_lookup(new_dentry);
+	if (err)
+		goto out;
+
+	/*
+	 * if new_dentry is already hidden because of whiteout,
+	 * simply override it even if the whiteouted dir is not empty.
+	 */
+	wh_dentry = lookup_whiteout(new_dentry);
+	if (!IS_ERR(wh_dentry))
+		DPUT(wh_dentry);
+	else if (new_dentry->d_inode) {
+		if (S_ISDIR(old_dentry->d_inode->i_mode) !=
+		    S_ISDIR(new_dentry->d_inode->i_mode)) {
+			err =
+			    S_ISDIR(old_dentry->d_inode->
+				    i_mode) ? -ENOTDIR : -EISDIR;
+			goto out;
+		}
+
+		if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+			/* check if this unionfs directory is empty or not */
+			err = check_empty(new_dentry, NULL);
+			if (err)
+				goto out;
+			/* Handle the case where we are overwriting directories
+			 * that are not really empty because of whiteout or
+			 * non-whiteout entries.
+			 */
+		}
+	}
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(old_dir->i_sb, DELETE_ALL))
+		err = unionfs_rename_all(old_dir, old_dentry, new_dir,
+					 new_dentry);
+	else
+#endif
+		err = unionfs_rename_whiteout(old_dir, old_dentry, new_dir,
+					      new_dentry);
+
+      out:
+	fist_checkinode(new_dir, "post unionfs_rename-new_dir");
+	fist_print_dentry("OUT: unionfs_rename, old_dentry", old_dentry);
+
+	if (err) {
+		/* clear the new_dentry stuff created */
+		d_drop(new_dentry);
+	} else {
+		/* force re-lookup since the dir on ro branch is not renamed,
+		   and hidden dentries still indicate the un-renamed ones. */
+		if (S_ISDIR(old_dentry->d_inode->i_mode))
+			atomic_dec(&dtopd(old_dentry)->udi_generation);
+		fist_print_dentry("OUT: unionfs_rename, new_dentry",
+				  new_dentry);
+	}
+
+	unlock_dentry(new_dentry);
+	unlock_dentry(old_dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/stale_inode.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/stale_inode.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,142 @@
+/*
+ *  Adpated from linux/fs/bad_inode.c
+ *
+ *  Copyright (C) 1997, Stephen Tweedie
+ *
+ *  Provide stub functions for "stale" inodes, a bit friendlier than the
+ *  -EIO that bad_inode.c does.
+ */
+/*
+ *  $Id: stale_inode.c,v 1.12 2005/11/20 23:03:34 arunmk Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sched.h>
+
+static struct address_space_operations unionfs_stale_aops;
+
+/* declarations for "sparse */
+extern struct inode_operations stale_inode_ops;
+
+/*
+ * The follow_link operation is special: it must behave as a no-op
+ * so that a stale root inode can at least be unmounted. To do this
+ * we must dput() the base and return the dentry with a dget().
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+static int stale_follow_link(struct dentry *dent, struct nameidata *nd)
+#else
+static void *stale_follow_link(struct dentry *dent, struct nameidata *nd)
+#endif
+{
+	int err = vfs_follow_link(nd, ERR_PTR(-ESTALE));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+	return err;
+#else
+	return ERR_PTR(err);
+#endif
+}
+
+static int return_ESTALE(void)
+{
+	return -ESTALE;
+}
+
+#define ESTALE_ERROR ((void *) (return_ESTALE))
+
+static struct file_operations stale_file_ops = {
+	.llseek = ESTALE_ERROR,
+	.read = ESTALE_ERROR,
+	.write = ESTALE_ERROR,
+	.readdir = ESTALE_ERROR,
+	.poll = ESTALE_ERROR,
+	.ioctl = ESTALE_ERROR,
+	.mmap = ESTALE_ERROR,
+	.open = ESTALE_ERROR,
+	.flush = ESTALE_ERROR,
+	.release = ESTALE_ERROR,
+	.fsync = ESTALE_ERROR,
+	.fasync = ESTALE_ERROR,
+	.lock = ESTALE_ERROR,
+};
+
+struct inode_operations stale_inode_ops = {
+	.create = ESTALE_ERROR,
+	.lookup = ESTALE_ERROR,
+	.link = ESTALE_ERROR,
+	.unlink = ESTALE_ERROR,
+	.symlink = ESTALE_ERROR,
+	.mkdir = ESTALE_ERROR,
+	.rmdir = ESTALE_ERROR,
+	.mknod = ESTALE_ERROR,
+	.rename = ESTALE_ERROR,
+	.readlink = ESTALE_ERROR,
+	.follow_link = stale_follow_link,
+	.truncate = ESTALE_ERROR,
+	.permission = ESTALE_ERROR,
+};
+
+/*
+ * When a filesystem is unable to read an inode due to an I/O error in
+ * its read_inode() function, it can call make_stale_inode() to return a
+ * set of stubs which will return ESTALE errors as required.
+ *
+ * We only need to do limited initialisation: all other fields are
+ * preinitialised to zero automatically.
+ */
+
+/**
+ *	make_stale_inode - mark an inode stale due to an I/O error
+ *	@inode: Inode to mark stale
+ *
+ *	When an inode cannot be read due to a media or remote network
+ *	failure this function makes the inode "stale" and causes I/O operations
+ *	on it to fail from this point on.
+ */
+
+void make_stale_inode(struct inode *inode)
+{
+	inode->i_mode = S_IFREG;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	inode->i_op = &stale_inode_ops;
+	inode->i_fop = &stale_file_ops;
+	inode->i_mapping->a_ops = &unionfs_stale_aops;
+}
+
+/*
+ * This tests whether an inode has been flagged as stale. The test uses
+ * &stale_inode_ops to cover the case of invalidated inodes as well as
+ * those created by make_stale_inode() above.
+ */
+
+/**
+ *	is_stale_inode - is an inode errored
+ *	@inode: inode to test
+ *
+ *	Returns true if the inode in question has been marked as stale.
+ */
+
+int is_stale_inode(struct inode *inode)
+{
+	return (inode->i_op == &stale_inode_ops);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/subr.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/subr.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: subr.c,v 1.133.2.2 2006/06/12 01:48:03 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* Pass an unionfs dentry and an index.  It will try to create a whiteout
+ * for the filename in dentry, and will try in branch 'index'.  On error,
+ * it will proceed to a branch to the left.
+ */
+int create_whiteout(struct dentry *dentry, int start)
+{
+	int bstart, bend, bindex;
+	struct dentry *hidden_dir_dentry;
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_wh_dentry;
+	char *name = NULL;
+	int err = -EINVAL;
+
+	print_entry("start = %d", start);
+
+	verify_locked(dentry);
+
+	fist_print_dentry("IN create_whiteout", dentry);
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* create dentry's whiteout equivalent */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	for (bindex = start; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+
+		if (!hidden_dentry) {
+			/* if hidden dentry is not present, create the entire
+			 * hidden dentry directory structure and go ahead.
+			 * Since we want to just create whiteout, we only want
+			 * the parent dentry, and hence get rid of this dentry.
+			 */
+			hidden_dentry = create_parents(dentry->d_inode,
+						       dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				fist_dprint(8,
+					    "hidden dentry NULL for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+		hidden_wh_dentry =
+		    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+				   dentry->d_name.len + WHLEN);
+		if (IS_ERR(hidden_wh_dentry))
+			continue;
+
+		/* The whiteout already exists. This used to be impossible, but
+		 * now is possible because of opaqueness. */
+		if (hidden_wh_dentry->d_inode) {
+			DPUT(hidden_wh_dentry);
+			err = 0;
+			goto out;
+		}
+
+		hidden_dir_dentry = lock_parent(hidden_wh_dentry);
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err =
+			    vfs_create(hidden_dir_dentry->d_inode,
+				       hidden_wh_dentry,
+				       ~current->fs->umask & S_IRWXUGO, NULL);
+
+		}
+		unlock_dir(hidden_dir_dentry);
+		DPUT(hidden_wh_dentry);
+
+		if (!err)
+			break;
+
+		if (!IS_COPYUP_ERR(err))
+			break;
+	}
+
+	/* set dbopaque  so that lookup will not proceed after this branch */
+	if (!err)
+		set_dbopaque(dentry, bindex);
+
+	fist_print_dentry("OUT create_whiteout", dentry);
+      out:
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+
+/* This is a helper function for rename, which ends up with hosed over dentries
+ * when it needs to revert. */
+int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_parent;
+	int err = 0;
+
+	print_entry(" bindex = %d", bindex);
+
+	verify_locked(dentry);
+	lock_dentry(dentry->d_parent);
+	hidden_parent = dtohd_index(dentry->d_parent, bindex);
+	unlock_dentry(dentry->d_parent);
+
+	BUG_ON(!S_ISDIR(hidden_parent->d_inode->i_mode));
+
+	hidden_dentry =
+	    LOOKUP_ONE_LEN(dentry->d_name.name, hidden_parent,
+			   dentry->d_name.len);
+	if (IS_ERR(hidden_dentry)) {
+		err = PTR_ERR(hidden_dentry);
+		goto out;
+	}
+
+	if (dtohd_index(dentry, bindex))
+		DPUT(dtohd_index(dentry, bindex));
+	if (itohi_index(dentry->d_inode, bindex)) {
+		IPUT(itohi_index(dentry->d_inode, bindex));
+		set_itohi_index(dentry->d_inode, bindex, NULL);
+	}
+	if (!hidden_dentry->d_inode) {
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	} else {
+		set_dtohd_index(dentry, bindex, hidden_dentry);
+		set_itohi_index(dentry->d_inode, bindex,
+				IGRAB(hidden_dentry->d_inode));
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/super.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/super.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,526 @@
+/*
+ * Copyright (c) 2003-2005 Erez Zadok
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: super.c,v 1.89 2006/02/20 22:23:01 dquigley Exp $
+ */
+
+#include "unionfs.h"
+
+/* The inode cache is used with alloc_inode for both our inode info and the
+ * vfs inode.  */
+static kmem_cache_t *unionfs_inode_cachep;
+
+static void unionfs_read_inode(struct inode *inode)
+{
+	static struct address_space_operations unionfs_empty_aops;
+	int size;
+
+	print_entry_location();
+
+	if (!itopd(inode)) {
+		printk(KERN_ERR
+		       "No kernel memory when allocating inode private data!\n");
+		BUG();
+	}
+
+	memset(itopd(inode), 0, sizeof(struct unionfs_inode_info));
+	itopd(inode)->b_start = -1;
+	itopd(inode)->b_end = -1;
+	atomic_set(&itopd(inode)->uii_generation,
+		   atomic_read(&stopd(inode->i_sb)->usi_generation));
+	itopd(inode)->uii_rdlock = SPIN_LOCK_UNLOCKED;
+	itopd(inode)->uii_rdcount = 1;
+	itopd(inode)->uii_hashsize = -1;
+	INIT_LIST_HEAD(&itopd(inode)->uii_readdircache);
+
+	size = sbmax(inode->i_sb) * sizeof(struct inode *);
+	itohi_ptr(inode) = KZALLOC(size, GFP_KERNEL);
+	if (!itohi_ptr(inode)) {
+		printk(KERN_ERR
+		       "No kernel memory when allocating lower-pointer array!\n");
+		BUG();
+	}
+
+	inode->i_version++;
+	inode->i_op = &unionfs_main_iops;
+	inode->i_fop = &unionfs_main_fops;
+	/* I don't think ->a_ops is ever allowed to be NULL */
+	inode->i_mapping->a_ops = &unionfs_empty_aops;
+	fist_dprint(7, "setting inode 0x%p a_ops to empty (0x%p)\n",
+		    inode, inode->i_mapping->a_ops);
+
+	print_exit_location();
+}
+
+static void unionfs_put_inode(struct inode *inode)
+{
+	print_entry_location();
+	fist_dprint(8, "%s i_count = %d, i_nlink = %d\n", __FUNCTION__,
+		    atomic_read(&inode->i_count), inode->i_nlink);
+	/*
+	 * This is really funky stuff:
+	 * Basically, if i_count == 1, iput will then decrement it and this inode will be destroyed.
+	 * It is currently holding a reference to the hidden inode.
+	 * Therefore, it needs to release that reference by calling iput on the hidden inode.
+	 * iput() _will_ do it for us (by calling our clear_inode), but _only_ if i_nlink == 0.
+	 * The problem is, NFS keeps i_nlink == 1 for silly_rename'd files.
+	 * So we must for our i_nlink to 0 here to trick iput() into calling our clear_inode.
+	 */
+	if (atomic_read(&inode->i_count) == 1)
+		inode->i_nlink = 0;
+	print_exit_location();
+}
+
+/*
+ * we now define delete_inode, because there are two VFS paths that may
+ * destroy an inode: one of them calls clear inode before doing everything
+ * else that's needed, and the other is fine.  This way we truncate the inode
+ * size (and its pages) and then clear our own inode, which will do an iput
+ * on our and the lower inode.
+ */
+static void unionfs_delete_inode(struct inode *inode)
+{
+	print_entry_location();
+
+	fist_checkinode(inode, "unionfs_delete_inode IN");
+	inode->i_size = 0;	/* every f/s seems to do that */
+	clear_inode(inode);
+
+	print_exit_location();
+}
+
+/* final actions when unmounting a file system */
+static void unionfs_put_super(struct super_block *sb)
+{
+	int bindex, bstart, bend;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	if ((spd = stopd(sb))) {
+		/* XXX: Free persistent inode stuff. */
+#ifdef UNIONFS_IMAP
+		cleanup_imap_data(sb);
+#endif
+		bstart = sbstart(sb);
+		bend = sbend(sb);
+		for (bindex = bstart; bindex <= bend; bindex++)
+			mntput(stohiddenmnt_index(sb, bindex));
+
+		/* Make sure we have no leaks of branchget/branchput. */
+		for (bindex = bstart; bindex <= bend; bindex++)
+			BUG_ON(branch_count(sb, bindex) != 0);
+
+		KFREE(spd->usi_data);
+		KFREE(spd);
+		stopd_lhs(sb) = NULL;
+	}
+	fist_dprint(6, "unionfs: released super\n");
+
+	print_exit_location();
+}
+
+static int unionfs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	int err = 0;
+	struct super_block *hidden_sb;
+	struct kstatfs rsb;
+	int bindex, bindex1, bstart, bend;
+
+	print_entry_location();
+	memset(buf, 0, sizeof(struct kstatfs));
+	buf->f_type = UNIONFS_SUPER_MAGIC;
+
+	buf->f_frsize = 0;
+	buf->f_namelen = 0;
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		int dup = 0;
+
+		hidden_sb = stohs_index(sb, bindex);
+		/* Ignore duplicate super blocks. */
+		for (bindex1 = bstart; bindex1 < bindex; bindex1++) {
+			if (hidden_sb == stohs_index(sb, bindex1)) {
+				dup = 1;
+				break;
+			}
+		}
+		if (dup) {
+			continue;
+		}
+
+		err = vfs_statfs(hidden_sb, &rsb);
+		fist_dprint(8,
+			    "adding values for bindex:%d bsize:%d blocks:%d bfree:%d bavail:%d\n",
+			    bindex, (int)rsb.f_bsize, (int)rsb.f_blocks,
+			    (int)rsb.f_bfree, (int)rsb.f_bavail);
+
+		if (!buf->f_frsize)
+			buf->f_frsize = rsb.f_frsize;
+		if (!buf->f_namelen) {
+			buf->f_namelen = rsb.f_namelen;
+		} else {
+			if (buf->f_namelen > rsb.f_namelen)
+				buf->f_namelen = rsb.f_namelen;
+		}
+		if (!buf->f_bsize) {
+			buf->f_bsize = rsb.f_bsize;
+		} else {
+			if (buf->f_bsize < rsb.f_bsize) {
+				int shifter = 0;
+				while (buf->f_bsize < rsb.f_bsize) {
+					shifter++;
+					rsb.f_bsize >>= 1;
+				}
+				rsb.f_blocks <<= shifter;
+				rsb.f_bfree <<= shifter;
+				rsb.f_bavail <<= shifter;
+			} else {
+				int shifter = 0;
+				while (buf->f_bsize > rsb.f_bsize) {
+					shifter++;
+					rsb.f_bsize <<= 1;
+				}
+				rsb.f_blocks >>= shifter;
+				rsb.f_bfree >>= shifter;
+				rsb.f_bavail >>= shifter;
+			}
+		}
+		buf->f_blocks += rsb.f_blocks;
+		buf->f_bfree += rsb.f_bfree;
+		buf->f_bavail += rsb.f_bavail;
+		buf->f_files += rsb.f_files;
+		buf->f_ffree += rsb.f_ffree;
+	}
+	buf->f_namelen -= WHLEN;
+
+	memset(&buf->f_fsid, 0, sizeof(__kernel_fsid_t));
+	memset(&buf->f_spare, 0, sizeof(buf->f_spare));
+	print_exit_status(err);
+	return err;
+}
+
+static int do_binary_remount(struct super_block *sb, int *flags, char *data)
+{
+	unsigned long *uldata = (unsigned long *)data;
+	int err;
+
+	uldata++;
+
+	switch (*uldata) {
+	case UNIONFS_IOCTL_DELBRANCH:
+		err = unionfs_ioctl_delbranch(sb, *(uldata + 1));
+		break;
+	default:
+		err = -ENOTTY;
+	}
+
+	return err;
+}
+
+/* We don't support a standard text remount, but we do have a magic remount
+ * for unionctl.  The idea is that you can remove a branch without opening
+ * the union.  Eventually it would be nice to support a full-on remount, so
+ * that you can have all of the directories change at once, but that would
+ * require some pretty complicated matching code. */
+static int unionfs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	if (data && *((unsigned long *)data) == UNIONFS_REMOUNT_MAGIC)
+		return do_binary_remount(sb, flags, data);
+	return -ENOSYS;
+}
+
+/*
+ * Called by iput() when the inode reference count reached zero
+ * and the inode is not hashed anywhere.  Used to clear anything
+ * that needs to be, before the inode is completely destroyed and put
+ * on the inode free list.
+ */
+static void unionfs_clear_inode(struct inode *inode)
+{
+	int bindex, bstart, bend;
+	struct inode *hidden_inode;
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	print_entry_location();
+
+	fist_checkinode(inode, "unionfs_clear_inode IN");
+
+	list_for_each_safe(pos, n, &itopd(inode)->uii_readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, uds_cache);
+		list_del(&rdstate->uds_cache);
+		free_rdstate(rdstate);
+	}
+
+	/* Decrement a reference to a hidden_inode, which was incremented
+	 * by our read_inode when it was created initially.  */
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (bstart >= 0) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_inode = itohi_index(inode, bindex);
+			if (!hidden_inode)
+				continue;
+			IPUT(hidden_inode);
+		}
+	}
+	// XXX: why this assertion fails?
+	// because it doesn't like us
+	// BUG_ON((inode->i_state & I_DIRTY) != 0);
+	KFREE(itohi_ptr(inode));
+	itohi_ptr(inode) = NULL;
+
+	print_exit_location();
+}
+
+static struct inode *unionfs_alloc_inode(struct super_block *sb)
+{
+	struct unionfs_inode_container *c;
+
+	print_entry_location();
+
+	c = (struct unionfs_inode_container *)
+	    kmem_cache_alloc(unionfs_inode_cachep, SLAB_KERNEL);
+	if (!c) {
+		print_exit_pointer(NULL);
+		return NULL;
+	}
+
+	memset(&c->info, 0, sizeof(c->info));
+
+	c->vfs_inode.i_version = 1;
+	print_exit_pointer(&c->vfs_inode);
+	return &c->vfs_inode;
+}
+
+static void unionfs_destroy_inode(struct inode *inode)
+{
+	print_entry("inode = %p", inode);
+	kmem_cache_free(unionfs_inode_cachep, itopd(inode));
+	print_exit_location();
+}
+
+static void init_once(void *v, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct unionfs_inode_container *c = (struct unionfs_inode_container *)v;
+
+	print_entry_location();
+
+	if ((flags & (SLAB_CTOR_VERIFY | SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&c->vfs_inode);
+
+	print_exit_location();
+}
+
+int init_inode_cache(void)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	unionfs_inode_cachep =
+	    kmem_cache_create("unionfs_inode_cache",
+			      sizeof(struct unionfs_inode_container), 0,
+			      SLAB_RECLAIM_ACCOUNT, init_once, NULL);
+	if (!unionfs_inode_cachep)
+		err = -ENOMEM;
+	print_exit_status(err);
+	return err;
+}
+
+void destroy_inode_cache(void)
+{
+	print_entry_location();
+	if (!unionfs_inode_cachep)
+		goto out;
+	if (kmem_cache_destroy(unionfs_inode_cachep))
+		printk(KERN_ERR
+		       "unionfs_inode_cache: not all structures were freed\n");
+      out:
+	print_exit_location();
+	return;
+}
+
+/* Called when we have a dirty inode, right here we only throw out
+ * parts of our readdir list that are too old.
+ */
+static int unionfs_write_inode(struct inode *inode, int sync)
+{
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	print_entry_location();
+
+	spin_lock(&itopd(inode)->uii_rdlock);
+	list_for_each_safe(pos, n, &itopd(inode)->uii_readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, uds_cache);
+		/* We keep this list in LRU order. */
+		if ((rdstate->uds_access + RDCACHE_JIFFIES) > jiffies)
+			break;
+		itopd(inode)->uii_rdcount--;
+		list_del(&rdstate->uds_cache);
+		free_rdstate(rdstate);
+	}
+	spin_unlock(&itopd(inode)->uii_rdlock);
+
+	print_exit_location();
+	return 0;
+}
+
+/*
+ * Called in do_umount() if the MNT_FORCE flag was used and this
+ * function is defined.  See comment in linux/fs/super.c:do_umount().
+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent
+ * code can actually succeed and won't leave tasks that need handling.
+ *
+ * PS. I wonder if this is somehow useful to undo damage that was
+ * left in the kernel after a user level file server (such as amd)
+ * dies.
+ */
+static void unionfs_umount_begin(struct super_block *sb)
+{
+	struct super_block *hidden_sb;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_sb = stohs_index(sb, bindex);
+		if (hidden_sb && hidden_sb->s_op &&
+		    hidden_sb->s_op->umount_begin)
+			hidden_sb->s_op->umount_begin(hidden_sb);
+	}
+	print_exit_location();
+}
+
+static int unionfs_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct super_block *sb = mnt->mnt_sb;
+	int ret = 0;
+	unsigned long tmp = 0;
+	char *hidden_path;
+	int bindex, bstart, bend;
+	int perms;
+
+	lock_dentry(sb->s_root);
+
+	tmp = __get_free_page(GFP_KERNEL);
+	if (!tmp) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bindex = bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	seq_printf(m, ",dirs=");
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_path =
+		    d_path(dtohd_index(sb->s_root, bindex),
+			   stohiddenmnt_index(sb, bindex), (char *)tmp,
+			   PAGE_SIZE);
+		perms = branchperms(sb, bindex);
+		seq_printf(m, "%s=%s", hidden_path,
+			   perms & MAY_WRITE ? "rw" :
+			   perms & MAY_NFSRO ? "nfsro" : "ro");
+		if (bindex != bend) {
+			seq_printf(m, ":");
+		}
+	}
+
+	seq_printf(m, ",debug=%d", fist_get_debug_value());
+
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(sb, DELETE_ALL))
+		seq_printf(m, ",delete=all");
+	else
+#endif
+		seq_printf(m, ",delete=whiteout");
+	if (IS_SET(sb, COPYUP_CURRENT_USER))
+		seq_printf(m, ",copyup=currentuser");
+	else
+		seq_printf(m, ",copyup=preserve");
+
+      out:
+	if (tmp)
+		free_page(tmp);
+	unlock_dentry(sb->s_root);
+	return ret;
+}
+
+/**
+ * The entry given by dentry here is always a directory.
+ * We can't just do dentry->d_parent, because it may
+ * not be there, since this dentry could have been
+ * created by calling d_alloc_anon.
+ */
+static struct dentry *unionfs_get_parent(struct dentry *dentry)
+{
+
+	struct dentry *ret;
+	struct inode *childinode;
+	childinode = dentry->d_inode;
+	ret = d_find_alias(childinode);
+	return ret;
+}
+
+struct export_operations unionfs_export_ops = {
+	.get_parent = unionfs_get_parent
+};
+
+struct super_operations unionfs_sops = {
+	.read_inode = unionfs_read_inode,
+	.put_inode = unionfs_put_inode,
+	.delete_inode = unionfs_delete_inode,
+	.put_super = unionfs_put_super,
+	.statfs = unionfs_statfs,
+	.remount_fs = unionfs_remount_fs,
+	.clear_inode = unionfs_clear_inode,
+	.umount_begin = unionfs_umount_begin,
+	.show_options = unionfs_show_options,
+	.write_inode = unionfs_write_inode,
+	.alloc_inode = unionfs_alloc_inode,
+	.destroy_inode = unionfs_destroy_inode,
+#ifdef SPLIT_VIEW_CACHES
+	.select_super = unionfs_select_super,
+#endif
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionctl.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionctl.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,522 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionctl.c,v 1.40 2006/01/21 02:58:11 jsipek Exp $
+ */
+
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <limits.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/types.h>
+
+#include "unionfs.h"
+
+#define MAY_READ 4
+#define MAY_WRITE 2
+
+extern int find_union(const char *path, char **options, char **actual_path,
+		      int uniononly);
+static char **branches;
+static int *branchperms;
+static const char *progname;
+
+void __attribute__ ((__noreturn__)) __usage(int line);
+
+#define usage() __usage(__LINE__)
+
+void __attribute__ ((__noreturn__)) __usage(int line)
+{
+#ifdef DEBUG
+	fprintf(stderr, "Line: %d\n", line);
+#endif
+	fprintf(stderr,
+		"unionctl version: $Id: unionctl.c,v 1.40 2006/01/21 02:58:11 jsipek Exp $\n");
+	fprintf(stderr, "Distributed with Unionfs " UNIONFS_VERSION "\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "unionctl UNION ACTION [arguments]\n");
+	fprintf(stderr,
+		"ACTION can be --add, --remove, --mode, --list, or --query.\nFurther arguments depend on ACTION.\n");
+	fprintf(stderr,
+		"\tunionctl UNION --add [ --before BRANCH | --after BRANCH ] [ --mode (rw|ro|nfsro) ] DIRECTORY\n");
+	fprintf(stderr, "\tunionctl UNION --remove BRANCH\n");
+	fprintf(stderr, "\tunionctl UNION --mode BRANCH (rw|ro|nfsro)\n");
+	fprintf(stderr, "\tunionctl UNION --list\n");
+	fprintf(stderr, "\tunionctl FILENAME --query\n");
+	fprintf(stderr,
+		"The unionctl man page has a more detailed description of its usage.\n");
+	exit(EXIT_FAILURE);
+}
+
+static inline int parse_rw(char *p)
+{
+	if (strcmp(p, "ro") == 0)
+		return MAY_READ;
+	else if (strcmp(p, "nfsro") == 0)
+		return MAY_READ | MAY_NFSRO;
+	else if (strcmp(p, "rw") == 0)
+		return MAY_READ | MAY_WRITE;
+	else
+		return 0;
+}
+
+static char **parse_options(char *options)
+{
+	char **ret = NULL;
+	int i = 0;
+
+	char *p;
+	char *q;
+	char *r;
+	char *s, *t, *u;
+
+	p = options;
+	do {
+		q = strchr(p, ',');
+		if (q) {
+			*q++ = '\0';
+		}
+		if (!strncmp(p, "dirs=", strlen("dirs="))) {
+			r = p + strlen("dirs=");
+			do {
+				s = strchr(r, ':');
+				if (s) {
+					*s++ = '\0';
+				}
+
+				i++;
+				ret = realloc(ret, sizeof(char *) * (i + 1));
+				if (!ret) {
+					perror("realloc()");
+					exit(EXIT_FAILURE);
+				}
+				branchperms =
+				    realloc(branchperms, sizeof(int) * i);
+				if (!branchperms) {
+					perror("realloc()");
+					exit(EXIT_FAILURE);
+				}
+
+				t = strchr(r, '=');
+				u = t + 1;
+				if (!t || !u || !*u)
+					goto err;
+				*t = 0;
+				branchperms[i - 1] = parse_rw(u);
+				if (!branchperms[i - 1]) {
+				      err:
+					fprintf(stderr, "cannot parse '%s'\n",
+						r);
+					exit(EXIT_FAILURE);
+				}
+				ret[i - 1] = strdup(r);
+				ret[i] = NULL;
+
+				r = s;
+			}
+			while (r);
+		}
+		p = q;
+	}
+	while (p);
+
+	branches = ret;
+	return ret;
+}
+
+static int get_branch(char *path)
+{
+	char *end;
+	int ret;
+
+	ret = strtol(path, &end, 0);
+	if (!*end) {
+		return ret;
+	}
+
+	ret = strlen(path);
+	if ((ret > 1) && (path[ret - 1] == '/')) {
+		path[ret - 1] = '\0';
+	}
+
+	ret = 0;
+	while (branches[ret]) {
+		if (!strcmp(branches[ret], path)) {
+			return ret;
+		}
+		ret++;
+	}
+
+	return -1;
+}
+
+static void dump_branches(const char *prefix)
+{
+	int i = 0;
+
+	while (branches[i]) {
+		char r, w, n;
+		r = (branchperms[i] & MAY_READ) ? 'r' : '-';
+		w = (branchperms[i] & MAY_WRITE) ? 'w' : '-';
+		n = (branchperms[i] & MAY_NFSRO) ? 'n' : '-';
+		printf("%s%s (%c%c%c)\n", prefix, branches[i], r, w, n);
+		i++;
+	}
+}
+
+#define ADD 1
+#define REMOVE 2
+#define MODE 3
+#define LIST 4
+#define	QUERY 5
+
+int main(int argc, char *argv[])
+{
+	struct unionfs_addbranch_args addargs;
+	struct unionfs_rdwrbranch_args rdwrargs;
+	unsigned long remountdata[3];
+	fd_set branchlist;
+	struct stat st;
+
+	int fd = -1;
+	int ret, i;
+
+	char *path, resolv_path[PATH_MAX], resolv_bp[PATH_MAX];
+	char *options = NULL, *actual_path = NULL;
+	int action;
+
+	char *branchpath;
+	int branchnum;
+	int unionpos = 1;
+	int modepos = 2;
+
+	progname = argv[0];
+
+	/* check that minimum number of args were specified */
+	if (argc < 3)
+		usage();
+
+	if (argv[1][0] == '-' && argv[1][1] == '-') {
+		modepos = 1;
+		unionpos = 2;
+	} else {
+		modepos = 2;
+		unionpos = 1;
+	}
+
+	if (realpath(argv[unionpos], resolv_path) == NULL) {
+		perror("realpath()");
+		exit(EXIT_FAILURE);
+	}
+	path = resolv_path;
+	if (strcmp(path, "/") && (path[strlen(path) - 1] == '/')) {
+		path[strlen(path) - 1] = '\0';
+	}
+
+	if (!strcmp(argv[modepos], "--add")) {
+		action = ADD;
+	} else if (!strcmp(argv[modepos], "--remove")) {
+		action = REMOVE;
+	} else if (!strcmp(argv[modepos], "--mode")) {
+		action = MODE;
+	} else if (!strcmp(argv[modepos], "--list")) {
+		action = LIST;
+	} else if (!strcmp(argv[modepos], "--query")) {
+		action = QUERY;
+	} else {
+		usage();
+	}
+
+	if (stat(path, &st) == -1) {
+		fprintf(stderr, "stat(%s): %s\n", path, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	if (find_union(path, &options, &actual_path, 1) < 0) {
+		fprintf(stderr, "%s is not a valid union.\n", path);
+		exit(EXIT_FAILURE);
+	}
+	branches = parse_options(options);
+	if (!branches) {
+		fprintf(stderr, "Could not parse options from /proc/mounts!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	/* open file on which ioctl will operate (that is actually any file in the union) */
+	if (action != REMOVE) {
+		fd = open(path, O_RDONLY);
+		if (fd < 0) {
+			fprintf(stderr, "open(%s): %s\n", path,
+				strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* Parse the action's options into something usable, and do it. */
+	switch (action) {
+	case ADD:
+		if (argc < 4)
+			usage();
+
+		/* Default values if the user leaves them unspecified. */
+		branchnum = -1;
+		addargs.ab_perms = MAY_READ | MAY_WRITE;
+		branchpath = NULL;
+		for (i = 3; i < argc; i++) {
+			if (argv[i][0] == '-' && argv[i][1] == '-') {
+				if (!strcmp(argv[i], "--before")) {
+					i++;
+					if (i == argc) {
+						fprintf(stderr,
+							"%s requires an argument!\n",
+							argv[i - 1]);
+						usage();
+					}
+
+					branchnum = get_branch(argv[i]);
+					if (branchnum == -1) {
+						fprintf(stderr,
+							"%s is not a valid branch.\nThe current branch configuration is:\n",
+							argv[i]);
+						dump_branches("\t");
+					}
+				} else if (!strcmp(argv[i], "--after")) {
+					i++;
+					if (i == argc) {
+						fprintf(stderr,
+							"%s requires an argument!\n",
+							argv[i - 1]);
+						usage();
+					}
+
+					branchnum = get_branch(argv[i]);
+					if (branchnum == -1) {
+						fprintf(stderr,
+							"%s is not a valid branch.\nThe current branch configuration is:\n",
+							argv[i]);
+						dump_branches("\t");
+					}
+					branchnum++;
+				} else if (!strcmp(argv[i], "--mode")) {
+					i++;
+					if (i == argc) {
+						fprintf(stderr,
+							"%s requires an argument!\n",
+							argv[i - 1]);
+						usage();
+					}
+
+					addargs.ab_perms = parse_rw(argv[i]);
+					if (!addargs.ab_perms) {
+						fprintf(stderr,
+							"Valid modes are ro, nfsro and rw you specified: \"%s\"\n",
+							argv[i]);
+						usage();
+					}
+				} else {
+					fprintf(stderr, "Unknown option: %s\n",
+						argv[i]);
+					usage();
+				}
+			} else {
+				int branchchk = -1;
+				/* The options must go before the path */
+				if ((i + 1) != argc) {
+					fprintf(stderr,
+						"The path of the branch to add must go after all options.\n");
+					usage();
+				}
+				branchchk = get_branch(argv[i]);
+				if (branchchk != -1) {
+					fprintf(stderr,
+						"%s already exists in the Union.\n",
+						argv[i]);
+					usage();
+				}
+				if (branchnum == -1)
+					branchnum = 0;
+				branchpath = argv[i];
+			}
+		}
+		if (!branchpath) {
+			fprintf(stderr,
+				"You must specify the path to add into the union!\n");
+			usage();
+		}
+
+		if (realpath(branchpath, resolv_bp) == NULL) {
+			perror("realpath()");
+			exit(EXIT_FAILURE);
+		}
+
+		addargs.ab_branch = branchnum;
+		addargs.ab_path = resolv_bp;
+
+		errno = 0;
+		ret = ioctl(fd, UNIONFS_IOCTL_ADDBRANCH, &addargs);
+		if (ret < 0) {
+			switch (errno) {
+			case E2BIG:
+				fprintf(stderr,
+					"Unionfs supports only %d branches.\n",
+					FD_SETSIZE);
+				break;
+			}
+			fprintf(stderr, "Failed to add %s into %s: %s",
+				branchpath, path, strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+		break;
+	case MODE:
+		if (argc != 5) {
+			usage();
+		}
+
+		branchnum = 3;
+		rdwrargs.rwb_perms = parse_rw(argv[4]);
+		if (!rdwrargs.rwb_perms) {
+			branchnum = 4;
+			rdwrargs.rwb_perms = parse_rw(argv[3]);
+			if (!rdwrargs.rwb_perms) {
+				usage();
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		if (realpath(argv[branchnum], resolv_bp) == NULL) {
+			perror("realpath()");
+			exit(EXIT_FAILURE);
+		}
+		branchpath = resolv_bp;
+
+		/* Set a branches writeable status. */
+		rdwrargs.rwb_branch = get_branch(branchpath);
+		if (rdwrargs.rwb_branch == -1) {
+			fprintf(stderr,
+				"%s is not a valid branch.\nThe current branch configuration is:\n",
+				branchpath);
+			dump_branches("\t");
+			exit(EXIT_FAILURE);
+		}
+
+		ret = ioctl(fd, UNIONFS_IOCTL_RDWRBRANCH, &rdwrargs);
+		if (ret < 0) {
+			fprintf(stderr,
+				"Failed to set permissions for %s in %s: %s",
+				branchpath, path, strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+
+		goto out;
+		break;
+	case REMOVE:
+		if (argc != 4)
+			usage();
+
+		if (realpath(argv[3], resolv_bp) == NULL) {
+			perror("realpath()");
+			exit(EXIT_FAILURE);
+		}
+		branchpath = resolv_bp;
+
+		branchnum = get_branch(branchpath);
+		if (branchnum == -1) {
+			fprintf(stderr,
+				"%s is not a valid branch.\nThe current branch configuration is:\n",
+				branchpath);
+			dump_branches("\t");
+			exit(EXIT_FAILURE);
+		}
+
+		errno = 0;
+		remountdata[0] = UNIONFS_REMOUNT_MAGIC;
+		remountdata[1] = UNIONFS_IOCTL_DELBRANCH;
+		remountdata[2] = branchnum;
+		ret =
+		    mount("unionfs", actual_path, "unionfs",
+			  MS_REMOUNT | MS_MGC_VAL, remountdata);
+		if (ret < 0) {
+			fprintf(stderr, "Failed to remove %s from %s: %s",
+				branchpath, path, strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+		break;
+	case LIST:
+		dump_branches("\t");
+		break;
+
+	case QUERY:
+		if (argc != 3) {
+			usage();
+		}
+
+		if ((fd = open(argv[unionpos], O_RDONLY)) < 0) {
+			fprintf(stderr,
+				"Unable to open file %s : %s",
+				argv[unionpos], strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+
+		ret = ioctl(fd, UNIONFS_IOCTL_QUERYFILE, &branchlist);
+		if (ret < 0) {
+			fprintf(stderr,
+				"Unable to retrieve list of branches for file %s : %s\n",
+				argv[unionpos], strerror(errno));
+			exit(EXIT_FAILURE);
+		}
+
+		for (i = 0; i <= ret; i++) {
+			char r, w, n;
+			r = (branchperms[i] & MAY_READ) ? 'r' : '-';
+			w = (branchperms[i] & MAY_WRITE) ? 'w' : '-';
+			n = (branchperms[i] & MAY_NFSRO) ? 'n' : '-';
+
+			if (FD_ISSET(i, &branchlist))
+				printf("%s\t%s (%c%c%c)\n", argv[unionpos],
+				       branches[i], r, w, n);
+		}
+		break;
+	}
+
+      out:
+	if (fd != -1)
+		close(fd);
+	exit(EXIT_SUCCESS);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/uniondbg.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/uniondbg.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: uniondbg.c,v 1.16 2006/01/13 03:00:24 jsipek Exp $
+ */
+
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/types.h>
+
+#include "unionfs.h"
+
+#define MAY_READ 4
+#define MAY_WRITE 2
+
+static int opt_d = 0;
+static int opt_c = 0;
+static int opt_g = 0;
+static int optcount;
+static const char *progname;
+
+void usage(void)
+{
+	fprintf(stderr, "Usage:\n"
+		"%s -d file [val]\n\tto set/get debugging values\n"
+		"%s -c file\n\tto print out branch reference counts (in kernel debug output)\n"
+		"%s -g file\n\tto increment the super block generation count\n"
+		"%s -s file\n\tto duplicate the super block\n", progname,
+		progname, progname, progname);
+	exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+	int fd, ret, val = 0;
+	int i;
+
+	progname = argv[0];
+
+	/* check that minimum number of args were specified */
+	if (argc < 3)
+		usage();
+
+	if (strcmp(argv[1], "-d") == 0) {
+		if (argc > 4)
+			usage();
+		opt_d++;
+		optcount++;
+	}
+	if (strcmp(argv[1], "-c") == 0) {
+		if (argc > 3)
+			usage();
+		opt_c++;
+		optcount++;
+	}
+	if (strcmp(argv[1], "-g") == 0) {
+		if (argc > 3)
+			usage();
+		opt_g++;
+		optcount++;
+	}
+
+	/* check that at least one option was used */
+	if (!optcount)
+		usage();
+
+	/* open file on which ioctl will operate */
+	fd = open(argv[2], O_RDONLY);
+	if (fd < 0) {
+		perror(argv[2]);
+		exit(1);
+	}
+
+	/* if specified 3rd arg, want to set debug level */
+	if (opt_d) {
+		if (argc == 4) {
+			val = atoi(argv[3]);
+			ret = ioctl(fd, FIST_IOCTL_SET_DEBUG_VALUE, &val);
+			if (ret < 0) {
+				perror("ioctl set");
+				exit(1);
+			}
+		} else {
+			ret = ioctl(fd, FIST_IOCTL_GET_DEBUG_VALUE, &val);
+			if (ret < 0) {
+				perror("ioctl get");
+				exit(1);
+			}
+			printf("debug ioctl returned value %d\n", val);
+		}
+		goto out;
+	}
+
+	/* branch refcounts */
+	if (opt_c) {
+		int *counts;
+		ret = ioctl(fd, UNIONFS_IOCTL_BRANCH_COUNT, NULL);
+		if (ret < 0) {
+			perror("ioctl branchcount (a)");
+			exit(1);
+		}
+		counts = malloc(ret * sizeof(int));
+		if (!counts) {
+			perror("malloc");
+			exit(1);
+		}
+		ret = ioctl(fd, UNIONFS_IOCTL_BRANCH_COUNT, counts);
+		if (ret < 0) {
+			perror("ioctl branchcount (b)");
+			exit(1);
+		}
+		printf("%d total branches.\n", ret);
+		for (i = 0; i < ret; i++) {
+			printf("%d: %d\n", i, counts[i]);
+		}
+		free(counts);
+		goto out;
+	}
+
+	/* Update generation number. */
+	if (opt_g) {
+		ret = ioctl(fd, UNIONFS_IOCTL_INCGEN, NULL);
+		if (ret < 0) {
+			perror("ioctl incgen");
+			exit(1);
+		}
+		printf("New generation %d\n", ret);
+		goto out;
+	}
+
+      out:
+	close(fd);
+	exit(0);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionfs_debugmacros.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionfs_debugmacros.h	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,409 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionfs_debugmacros.h,v 1.18 2006/02/15 09:07:28 jsipek Exp $
+ */
+
+#ifndef __UNIONFS_H_
+#error This file should only be included from unionfs.h!
+#endif
+
+/* File to hidden file */
+
+static inline struct file *ftohf_index(const struct file *f, int index)
+{
+	struct file *hidden_file;
+	hidden_file = ftopd(f)->ufi_file[index];
+
+	BUG_ON(hidden_file && (atomic_read(&hidden_file->f_count) <= 0));
+
+	return hidden_file;
+}
+
+static inline struct file *ftohf(const struct file *f)
+{
+	BUG_ON(ftopd(f)->b_start < 0);
+	return ftohf_index(f, fbstart(f));
+}
+
+static inline struct file *set_ftohf_index(struct file *f, int index,
+					   struct file *val)
+{
+	BUG_ON(index < 0);
+	BUG_ON(val && (atomic_read(&val->f_count) <= 0));
+
+	ftopd(f)->ufi_file[index] = val;
+	return val;
+}
+
+static inline struct file *set_ftohf(struct file *f, struct file *val)
+{
+	BUG_ON(ftopd(f)->b_start < 0);
+	return set_ftohf_index(f, fbstart(f), val);
+}
+
+/* Inode to hidden inode. */
+
+static inline struct inode *itohi_index(const struct inode *ino, int index)
+{
+	struct inode *hidden_inode;
+	BUG_ON(index < 0);
+	hidden_inode = itopd(ino)->uii_inode[index];
+	if (hidden_inode)
+		BUG_ON((atomic_read(&hidden_inode->i_count)) <= 0);
+	return hidden_inode;
+}
+
+static inline struct inode *itohi(const struct inode *ino)
+{
+	BUG_ON(itopd(ino)->b_start < 0);
+	return itohi_index(ino, itopd(ino)->b_start);
+}
+
+static inline struct inode *set_itohi_index(struct inode *ino, int index,
+					    struct inode *val)
+{
+	BUG_ON(index < 0);
+	BUG_ON(val && (atomic_read(&val->i_count) <= 0));
+
+	itopd(ino)->uii_inode[index] = val;
+	return val;
+}
+
+/* Superblock to hidden superblock */
+static inline struct super_block *stohs_index(const struct super_block *f,
+					      int index)
+{
+	return stopd(f)->usi_data[index].sb;
+}
+
+static inline struct super_block *stohs(const struct super_block *sb)
+{
+	BUG_ON(sbstart(sb) != 0);
+	return stohs_index(sb, sbstart(sb));
+}
+
+static inline struct super_block *set_stohs_index(struct super_block *sb,
+						  int index,
+						  struct super_block *val)
+{
+	stopd(sb)->usi_data[index].sb = val;
+	return val;
+}
+
+/* Superblock to hidden vfsmount  */
+static inline struct vfsmount *stohiddenmnt_index(struct super_block *sb,
+						  int index)
+{
+	BUG_ON(index < 0);
+	return stopd(sb)->usi_data[index].hidden_mnt;
+}
+
+static inline void set_stohiddenmnt_index(struct super_block *sb, int index,
+					  struct vfsmount *mnt)
+{
+	BUG_ON(index < 0);
+	stopd(sb)->usi_data[index].hidden_mnt = mnt;
+}
+
+/* Get and put branches on the superblock. */
+static inline void set_branch_count(struct super_block *sb, int index,
+				    int count)
+{
+	BUG_ON(index < 0);
+	atomic_set(&stopd(sb)->usi_data[index].sbcount, count);
+}
+
+static inline int branch_count(struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+	return atomic_read(&stopd(sb)->usi_data[index].sbcount);
+}
+
+static inline void branchget(struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+	atomic_inc(&stopd(sb)->usi_data[index].sbcount);
+	BUG_ON(atomic_read(&stopd(sb)->usi_data[index].sbcount) < 0);
+}
+
+static inline void branchput(struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+	atomic_dec(&stopd(sb)->usi_data[index].sbcount);
+	BUG_ON(atomic_read(&stopd(sb)->usi_data[index].sbcount) < 0);
+}
+
+/* Dentry to Hidden Dentry  */
+static inline struct unionfs_dentry_info *__dtopd(const struct dentry *dent,
+						  int check)
+{
+	struct unionfs_dentry_info *ret;
+
+	ret = (struct unionfs_dentry_info *)(dent)->d_fsdata;
+	/* We are really only interested in catching poison here. */
+	if (ret && check) {
+		if ((ret->udi_bend > ret->udi_bcount)
+		    || (ret->udi_bend > sbmax(dent->d_sb))) {
+			printk(KERN_EMERG
+			       "udi_bend = %d, udi_count = %d, sbmax = %d\n",
+			       ret->udi_bend, ret->udi_bcount,
+			       sbmax(dent->d_sb));
+		}
+		BUG_ON(ret->udi_bend > ret->udi_bcount);
+		BUG_ON(ret->udi_bend > sbmax(dent->d_sb));
+	}
+
+	return ret;
+}
+
+#define dtopd(dent) __dtopd(dent, 1)
+#define dtopd_nocheck(dent) __dtopd(dent, 0)
+#define dtopd_lhs(dent) ((dent)->d_fsdata)
+
+/* Macros for locking a dentry. */
+static inline void lock_dentry(struct dentry *d)
+{
+#ifdef TRACKLOCK
+	printk("LOCK:%p\n", d);
+#endif
+	down(&dtopd(d)->udi_sem);
+}
+
+static inline void unlock_dentry(struct dentry *d)
+{
+#ifdef TRACKLOCK
+	printk("UNLOCK:%p\n", d);
+#endif
+	up(&dtopd(d)->udi_sem);
+}
+
+static inline void verify_locked(const struct dentry *d)
+{
+#ifdef TRACKLOCK
+	printk("MUST BE LOCKED:%p\n", d);
+#endif
+	BUG_ON(down_trylock(&dtopd(d)->udi_sem) == 0);
+}
+
+static inline int dbend(const struct dentry *dentry)
+{
+	verify_locked(dentry);
+	return dtopd(dentry)->udi_bend;
+}
+
+static inline int set_dbend(const struct dentry *dentry, int val)
+{
+	verify_locked(dentry);
+
+	BUG_ON((val < 0) && (val != -1));
+	BUG_ON(val > dtopd_nocheck(dentry)->udi_bcount);
+	BUG_ON(val > sbmax(dentry->d_sb));
+
+	dtopd(dentry)->udi_bend = val;
+	return dtopd(dentry)->udi_bend;
+}
+
+static inline int dbstart(const struct dentry *dentry)
+{
+	verify_locked(dentry);
+	return dtopd(dentry)->udi_bstart;
+}
+
+static inline int set_dbstart(const struct dentry *dentry, int val)
+{
+	verify_locked(dentry);
+
+	BUG_ON((val < 0) && (val != -1));
+	BUG_ON(val > dtopd_nocheck(dentry)->udi_bcount);
+	BUG_ON(val > sbmax(dentry->d_sb));
+
+	dtopd_nocheck(dentry)->udi_bstart = val;
+	return dtopd(dentry)->udi_bstart;
+}
+
+static inline int dbopaque(const struct dentry *dentry)
+{
+	verify_locked(dentry);
+	return dtopd(dentry)->udi_bopaque;
+}
+
+static inline int set_dbopaque(const struct dentry *dentry, int val)
+{
+	verify_locked(dentry);
+
+	BUG_ON((val < 0) && (val != -1));
+	BUG_ON(val > dtopd_nocheck(dentry)->udi_bcount);
+	BUG_ON(val > sbmax(dentry->d_sb));
+	BUG_ON(val > dbend(dentry));
+
+	dtopd_nocheck(dentry)->udi_bopaque = val;
+	return dtopd(dentry)->udi_bopaque;
+}
+
+/* Dentry to hidden dentry functions */
+#define dtohd_index(dent, index) __dtohd_index(dent, index, 1)
+#define dtohd_index_nocheck(dent, index) __dtohd_index(dent, index, 0)
+/* This pointer should not be generally used except for maintainence functions. */
+#define dtohd_ptr(dent) (dtopd_nocheck(dent)->udi_dentry)
+static inline struct dentry *__dtohd_index(const struct dentry *dent, int index,
+					   int docheck)
+{
+	struct dentry *d;
+
+	verify_locked(dent);
+	BUG_ON(index < 0);
+	if (docheck) {
+		if (index > sbend(dent->d_sb)) {
+			printk
+			    ("Dentry index out of super bounds: index=%d, sbend=%d\n",
+			     index, sbend(dent->d_sb));
+			BUG_ON(index > sbend(dent->d_sb));
+		}
+		if (index > dtopd(dent)->udi_bcount) {
+			printk
+			    ("Dentry index out of array bounds: index=%d, count=%d\n",
+			     index, dtopd(dent)->udi_bcount);
+			printk("Generation of dentry: %d\n",
+			       atomic_read(&dtopd(dent)->udi_generation));
+			printk("Generation of sb: %d\n",
+			       atomic_read(&stopd(dent->d_sb)->usi_generation));
+			BUG_ON(index > dtopd(dent)->udi_bcount);
+		}
+	}
+	d = dtopd(dent)->udi_dentry[index];
+
+	BUG_ON(d && (atomic_read(&d->d_count) <= 0));
+
+	return d;
+}
+
+static inline struct dentry *dtohd(const struct dentry *dent)
+{
+	struct dentry *d;
+	int index;
+
+	verify_locked(dent);
+	BUG_ON(dbstart(dent) < 0);
+	index = dbstart(dent);
+	d = dtohd_index(dent, index);
+
+	return d;
+}
+
+// Dentry to Hidden Dentry based on index
+#define set_dtohd_index(dent, index, val) __set_dtohd_index(dent, index, val, 1)
+#define set_dtohd_index_nocheck(dent, index, val) __set_dtohd_index(dent, index, val, 0)
+static inline struct dentry *__set_dtohd_index(struct dentry *dent, int index,
+					       struct dentry *val, int docheck)
+{
+#ifdef FIST_MALLOC_DEBUG
+	struct dentry *old;
+#endif
+
+	verify_locked(dent);
+	BUG_ON(index < 0);
+	if (docheck) {
+		if (index > sbend(dent->d_sb)) {
+			printk
+			    ("Dentry index out of super bounds: index=%d, sbend=%d\n",
+			     index, sbend(dent->d_sb));
+			BUG_ON(index > sbend(dent->d_sb));
+		}
+		if (index > dtopd(dent)->udi_bcount) {
+			printk
+			    ("Dentry index out of array bounds: index=%d, count=%d\n",
+			     index, dtopd(dent)->udi_bcount);
+			printk("Generation of dentry: %d\n",
+			       atomic_read(&dtopd(dent)->udi_generation));
+			printk("Generation of sb: %d\n",
+			       atomic_read(&stopd(dent->d_sb)->usi_generation));
+			BUG_ON(index > dtopd(dent)->udi_bcount);
+		}
+	}
+#ifdef FIST_MALLOC_DEBUG
+	old = dtopd(dent)->udi_dentry[index];
+	record_set(dent, index, val, old, line, file);
+#endif
+	dtopd(dent)->udi_dentry[index] = val;
+
+	return val;
+}
+
+extern int fist_get_debug_value(void);
+extern int fist_set_debug_value(int val);
+extern void fist_dprint_internal(const char *file, const char *function,
+				 int line, int level, char *str, ...)
+    __attribute__ ((format(__printf__, 5, 6)));
+
+extern void fist_print_dentry(const char *, const struct dentry *);
+extern void __fist_print_dentry(const char *, const struct dentry *, int);
+extern void fist_print_generic_dentry(const char *, const struct dentry *);
+extern void fist_print_generic_dentry3(const char *, const char *,
+				       const struct dentry *);
+extern void __fist_print_generic_dentry(const char *, const char *, const
+					struct dentry *, int);
+extern void fist_print_inode(const char *, const struct inode *);
+extern void fist_print_generic_inode(const char *, const struct inode *);
+extern void fist_print_file(const char *, const struct file *);
+extern void fist_checkinode(const struct inode *, const char *);
+extern void fist_print_sb(const char *str, const struct super_block *);
+
+extern char *add_indent(void);
+extern char *del_indent(void);
+
+#define fist_dprint(level, str, args...) fist_dprint_internal(__FILE__, __FUNCTION__, __LINE__, level, KERN_DEBUG str, ## args)
+#define print_entry(format, args...) fist_dprint(4, "%sIN:  %s %s:%d " format "\n", add_indent(), __FUNCTION__, __FILE__, __LINE__, ##args)
+#define print_entry_location() fist_dprint(4, "%sIN:  %s %s:%d\n", add_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_exit_location() fist_dprint(5, "%s OUT: %s %s:%d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_exit_status(status) fist_dprint(5, "%s OUT: %s %s:%d, STATUS: %d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, status)
+#define print_exit_pointer(status) \
+do { \
+  if (IS_ERR(status)) \
+    fist_dprint(5, "%s OUT: %s %s:%d, RESULT: %ld\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, PTR_ERR(status)); \
+  else \
+    fist_dprint(5, "%s OUT: %s %s:%d, RESULT: 0x%p\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, status); \
+} while (0)
+
+#define print_util_entry(format, args...) fist_dprint(6, "%sIN:  %s %s:%d" format "\n", add_indent(), __FUNCTION__, __FILE__, __LINE__, ##args)
+#define print_util_entry_location() fist_dprint(6, "%sIN:  %s %s:%d\n", add_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_util_exit_location() fist_dprint(7, "%s OUT: %s %s:%d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__)
+#define print_util_exit_status(status) fist_dprint(7, "%s OUT: %s %s:%d, STATUS: %d\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, status)
+#define print_util_exit_pointer(status) \
+do { \
+  if (IS_ERR(status)) \
+    fist_dprint(7, "%s OUT: %s %s:%d, RESULT: %ld\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, PTR_ERR(status)); \
+  else \
+    fist_dprint(5, "%s OUT: %s %s:%d, RESULT: 0x%x\n", del_indent(), __FUNCTION__, __FILE__, __LINE__, PTR_ERR(status)); \
+} while (0)
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionfs.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionfs.h	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,830 @@
+#ifndef __UNIONFS_H_
+#define __UNIONFS_H_
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/limits.h>
+#include <linux/random.h>
+#include <linux/poll.h>
+#include <linux/buffer_head.h>
+#include <linux/pagemap.h>
+#include <linux/namei.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/page-flags.h>
+#include <linux/writeback.h>
+#include <linux/page-flags.h>
+#include <linux/statfs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+#include <linux/security.h>
+#include <linux/compat.h>
+
+#include <linux/swap.h>
+
+#include <asm/system.h>
+#include <asm/mman.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+#include <linux/poll.h>
+
+#ifndef UNIONFS_UNSUPPORTED
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15))
+#warning You are compiling Unionfs on an unsupported kernel version.
+#warning To compile Unionfs, you will need to define UNIONFS_UNSUPPORTED.
+#warning Try adding: EXTRACFLAGS=-DUNIONFS_UNSUPPORTED to fistdev.mk
+#endif
+#endif
+
+#include <linux/spinlock.h>
+#define wq_write_lock_irqsave(lock,flags) spin_lock_irqsave(lock,flags)
+#define wq_write_unlock(lock) spin_unlock(lock)
+#define wq_write_lock_irq(lock) spin_lock_irq(lock)
+#define wq_write_unlock_irqrestore(lock,flags) spin_unlock_irqrestore(lock,flags)
+
+/* number of characters while generating unique temporary file names */
+#define	UNIONFS_TMPNAM_LEN	12
+
+/* fist file systems superblock magic */
+#define UNIONFS_SUPER_MAGIC 0xf15f083d
+
+/* unionfs root inode number */
+#define UNIONFS_ROOT_INO     1
+
+/* Mount time flags */
+#define MOUNT_FLAG(sb)     (stopd(sb)->usi_mount_flag)
+
+/*UUID typedef needed later*/
+typedef uint8_t uuid_t[16];
+
+/* Operations vectors defined in specific files. */
+extern struct file_operations unionfs_main_fops;
+extern struct file_operations unionfs_dir_fops;
+extern struct inode_operations unionfs_main_iops;
+extern struct inode_operations unionfs_dir_iops;
+extern struct inode_operations unionfs_symlink_iops;
+extern struct super_operations unionfs_sops;
+extern struct dentry_operations unionfs_dops;
+extern struct export_operations unionfs_export_ops;
+
+/* How long should an entry be allowed to persist */
+#define RDCACHE_JIFFIES 5*HZ
+/* unionfs inode data in memory */
+struct unionfs_inode_info {
+	int b_start;
+	int b_end;
+	atomic_t uii_generation;
+	int uii_stale;
+	/* Stuff for readdir over NFS. */
+	spinlock_t uii_rdlock;
+	struct list_head uii_readdircache;
+	int uii_rdcount;
+	int uii_hashsize;
+	int uii_cookie;
+	/* The hidden inodes */
+	struct inode **uii_inode;
+	/* to keep track of reads/writes for unlinks before closes */
+	atomic_t uii_totalopens;
+};
+
+struct unionfs_inode_container {
+	struct unionfs_inode_info info;
+	struct inode vfs_inode;
+};
+
+/* unionfs dentry data in memory */
+struct unionfs_dentry_info {
+	/* The semaphore is used to lock the dentry as soon as we get into a
+	 * unionfs function from the VFS.  Our lock ordering is that children
+	 * go before their parents. */
+	struct semaphore udi_sem;
+	int udi_bstart;
+	int udi_bend;
+	int udi_bopaque;
+	int udi_bcount;
+	atomic_t udi_generation;
+	struct dentry **udi_dentry;
+};
+
+/* A putmap is used so that older files can still do branchput correctly. */
+struct putmap {
+	atomic_t count;
+	int bend;
+	int map[0];
+};
+
+/* These are the pointers to our various objects. */
+struct unionfs_usi_data {
+	struct super_block *sb;
+	struct vfsmount *hidden_mnt;
+	atomic_t sbcount;
+	int branchperms;
+};
+
+/* unionfs super-block data in memory */
+struct unionfs_sb_info {
+	int b_end;
+
+	atomic_t usi_generation;
+	unsigned long usi_mount_flag;
+	struct rw_semaphore usi_rwsem;
+
+	struct unionfs_usi_data *usi_data;
+
+	/* These map branch numbers for old generation numbers to the new bindex,
+	 * so that branchput will behave properly. */
+	int usi_firstputmap;
+	int usi_lastputmap;
+	struct putmap **usi_putmaps;
+
+#ifdef UNIONFS_IMAP
+	int usi_persistent;
+	/* These will need a lock. */
+	uint64_t usi_next_avail;
+	uint8_t usi_num_bmapents;
+	struct bmapent *usi_bmap;
+	struct file *usi_forwardmap;
+	struct file **usi_reversemaps;
+	struct file **usi_map_table;
+	int *usi_bnum_table;	//This is a table of branches to fsnums.
+#endif
+};
+
+/*
+ * structure for making the linked list of entries by readdir on left branch
+ * to compare with entries on right branch
+ */
+struct filldir_node {
+	struct list_head file_list;	// list for directory entries
+	char *name;		// name entry
+	int hash;		// name hash
+	int namelen;		// name len since name is not 0 terminated
+	int bindex;		// we can check for duplicate whiteouts and files in the same branch in order to return -EIO.
+	int whiteout;		// is this a whiteout entry?
+	char iname[DNAME_INLINE_LEN_MIN];	// Inline name, so we don't need to separately kmalloc small ones
+};
+
+/* Cache creation/deletion routines. */
+void destroy_filldir_cache(void);
+int init_filldir_cache(void);
+int init_inode_cache(void);
+void destroy_inode_cache(void);
+int init_dentry_cache(void);
+void destroy_dentry_cache(void);
+
+/* Initialize and free readdir-specific  state. */
+int init_rdstate(struct file *file);
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex);
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos);
+void free_rdstate(struct unionfs_dir_state *state);
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout);
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen);
+
+struct dentry **alloc_new_dentries(int objs);
+struct unionfs_usi_data *alloc_new_data(int objs);
+
+/* Directory hash table. */
+struct unionfs_dir_state {
+	unsigned int uds_cookie;	/* The cookie, which is based off of uii_rdversion */
+	unsigned int uds_offset;	/* The entry we have returned. */
+	int uds_bindex;
+	loff_t uds_dirpos;	/* The offset within the lower level directory. */
+	int uds_size;		/* How big is the hash table? */
+	int uds_hashentries;	/* How many entries have been inserted? */
+	unsigned long uds_access;
+	/* This cache list is used when the inode keeps us around. */
+	struct list_head uds_cache;
+	struct list_head uds_list[0];
+};
+
+/* Compat stuff.. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+
+# ifdef __CHECKER__
+#  define __bitwise__ __attribute__((bitwise))
+# else
+#  define __bitwise__
+# endif
+
+typedef unsigned __bitwise__ gfp_t;
+void *kzalloc(size_t size, gfp_t flags);
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) */
+
+#ifdef FIST_MALLOC_DEBUG
+
+extern void *unionfs_kzalloc(size_t size, gfp_t flags, int line,
+			     const char *file);
+extern void *unionfs_kmalloc(size_t size, gfp_t flags, int line,
+			     const char *file);
+extern void unionfs_kfree(void *ptr, int line, const char *file);
+
+extern struct dentry *unionfs_dget_parent(struct dentry *child, int line,
+					  const char *file);
+extern struct dentry *unionfs_dget(struct dentry *ptr, int line,
+				   const char *file);
+extern void unionfs_dput(struct dentry *ptr, int line, const char *file);
+extern struct inode *unionfs_igrab(struct inode *inode, int line, char *file);
+extern void unionfs_iput(struct inode *inode, int line, char *file);
+extern struct inode *unionfs_iget(struct super_block *sb, unsigned long ino,
+				  int line, char *file);
+extern struct dentry *unionfs_lookup_one_len(const char *name,
+					     struct dentry *parent, int len,
+					     int line, const char *file);
+void record_path_lookup(struct nameidata *nd, int line, const char *file);
+void record_path_release(struct nameidata *nd, int line, const char *file);
+struct file *unionfs_dentry_open(struct dentry *ptr, struct vfsmount *mnt,
+				 int flags, int line, const char *file);
+void record_set(struct dentry *upper, int index, struct dentry *ptr,
+		struct dentry *old, int line, const char *file);
+
+#define KZALLOC(size,flags) unionfs_kzalloc((size),(flags),__LINE__,__FILE__)
+#define KMALLOC(size,flags) unionfs_kmalloc((size),(flags),__LINE__,__FILE__)
+#define KFREE(ptr) unionfs_kfree((ptr),__LINE__,__FILE__)
+#define DGET(d) unionfs_dget((d),__LINE__,__FILE__)
+#define DPUT(d) unionfs_dput((d),__LINE__,__FILE__)
+# define IPUT(a)		unionfs_iput((a),__LINE__,__FILE__)
+# define IGET(a,b)		unionfs_iget((a),(b),__LINE__,__FILE__)
+# define IGRAB(a)		unionfs_igrab((a),__LINE__,__FILE__)
+#define LOOKUP_ONE_LEN(name,parent,len) unionfs_lookup_one_len((name),(parent),(len),__LINE__,__FILE__)
+# define RECORD_PATH_LOOKUP(nd)	record_path_lookup((nd),__LINE__,__FILE__)
+# define RECORD_PATH_RELEASE(nd) record_path_release((nd),__LINE__,__FILE__)
+/* This has the effect of reducing the reference count sooner or later,
+ * if the file is closed.  If it isn't then the mount will be busy and
+ * you can't unmount.
+ */
+# define DENTRY_OPEN(d,m,f) unionfs_dentry_open((d),(m),(f),__LINE__,__FILE__)
+# define GET_PARENT(dentry) unionfs_dget_parent((dentry),__LINE__,__FILE__)
+#else				/* not FIST_MALLOC_DEBUG */
+# define KZALLOC(a,b)		kzalloc((a),(b))
+# define KMALLOC(a,b)		kmalloc((a),(b))
+# define KFREE(a)		kfree((a))
+# define DPUT(a)		dput((a))
+# define DGET(a)		dget((a))
+# define IPUT(a)		iput((a))
+# define IGET(a,b)		iget((a),(b))
+# define IGRAB(a)		igrab((a))
+# define LOOKUP_ONE_LEN(a,b,c)	lookup_one_len((a),(b),(c))
+# define RECORD_PATH_LOOKUP(a)
+# define RECORD_PATH_RELEASE(a)
+# define DENTRY_OPEN(d,m,f)	dentry_open((d),(m),(f))
+# define GET_PARENT(d)		dget_parent(d)
+#endif				/* not FIST_MALLOC_DEBUG */
+
+/* We can only use 32-bits of offset for rdstate --- blech! */
+#define DIREOF (0xfffff)
+#define RDOFFBITS 20		/* This is the number of bits in DIREOF. */
+#define MAXRDCOOKIE (0xfff)
+/* Turn an rdstate into an offset. */
+static inline off_t rdstate2offset(struct unionfs_dir_state *buf)
+{
+	off_t tmp;
+	tmp =
+	    ((buf->uds_cookie & MAXRDCOOKIE) << RDOFFBITS) | (buf->
+							      uds_offset &
+							      DIREOF);
+	return tmp;
+}
+
+/* file private data. */
+struct unionfs_file_info {
+	int b_start;
+	int b_end;
+	atomic_t ufi_generation;
+
+	struct unionfs_dir_state *rdstate;
+	struct file **ufi_file;
+};
+
+/* File to private Data */
+#define ftopd(file) ((struct unionfs_file_info *)((file)->private_data))
+#define ftopd_lhs(file) ((file)->private_data)
+#define ftohf_ptr(file)  (ftopd(file)->ufi_file)
+#define fbstart(file) (ftopd(file)->b_start)
+#define fbend(file) (ftopd(file)->b_end)
+
+/* Inode to private data */
+static inline struct unionfs_inode_info *itopd(const struct inode *inode)
+{
+	return
+	    &(container_of(inode, struct unionfs_inode_container, vfs_inode)->
+	      info);
+}
+
+#define itohi_ptr(ino) (itopd(ino)->uii_inode)
+#define ibstart(ino) (itopd(ino)->b_start)
+#define ibend(ino) (itopd(ino)->b_end)
+
+/* Superblock to private data */
+#define stopd(super) ((struct unionfs_sb_info *)(super)->s_fs_info)
+#define stopd_lhs(super) ((super)->s_fs_info)
+#define sbstart(sb) 0
+#define sbend(sb) stopd(sb)->b_end
+#define sbmax(sb) (stopd(sb)->b_end + 1)
+
+#define unionfs_read_lock(sb) down_read(&stopd(sb)->usi_rwsem)
+#define unionfs_read_unlock(sb) up_read(&stopd(sb)->usi_rwsem)
+#define unionfs_write_lock(sb) down_write(&stopd(sb)->usi_rwsem)
+#define unionfs_write_unlock(sb) up_write(&stopd(sb)->usi_rwsem)
+
+/* The UNIONFS_NDEBUG versions are defines, the debug versions are inline
+ * functions with extra checks. */
+#ifdef UNIONFS_NDEBUG
+#include "unionfs_macros.h"
+#else
+#include "unionfs_debugmacros.h"
+#endif
+
+/* The double lock function needs to go after the debugmacros, so that
+ * dtopd is defined.  */
+static inline void double_lock_dentry(struct dentry *d1, struct dentry *d2)
+{
+	if (d2 < d1) {
+		struct dentry *tmp = d1;
+		d1 = d2;
+		d2 = tmp;
+	}
+	lock_dentry(d1);
+	lock_dentry(d2);
+}
+
+extern int new_dentry_private_data(struct dentry *dentry);
+void free_dentry_private_data(struct unionfs_dentry_info *udi);
+void update_bstart(struct dentry *dentry);
+#define sbt(sb) ((sb)->s_type->name)
+
+/*
+ * EXTERNALS:
+ */
+/* replicates the directory structure upto given dentry in given branch */
+extern struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+				     int bindex);
+struct dentry *create_parents_named(struct inode *dir, struct dentry *dentry,
+				    const char *name, int bindex);
+
+/* check if two branches overlap */
+extern int is_branch_overlap(struct dentry *dent1, struct dentry *dent2);
+
+/* partial lookup */
+extern int unionfs_partial_lookup(struct dentry *dentry);
+
+/* Pass an unionfs dentry and an index and it will try to create a whiteout in branch 'index'.
+   On error, it will proceed to a branch to the left */
+extern int create_whiteout(struct dentry *dentry, int start);
+/* copies a file from dbstart to newbindex branch */
+extern int copyup_file(struct inode *dir, struct file *file, int bstart,
+		       int newbindex, loff_t size);
+extern int copyup_named_file(struct inode *dir, struct file *file,
+			     char *name, int bstart, int new_bindex,
+			     loff_t len);
+
+/* copies a dentry from dbstart to newbindex branch */
+extern int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
+			 int new_bindex, struct file **copyup_file, loff_t len);
+extern int copyup_named_dentry(struct inode *dir, struct dentry *dentry,
+			       int bstart, int new_bindex, const char *name,
+			       int namelen, struct file **copyup_file,
+			       loff_t len);
+
+extern int remove_whiteouts(struct dentry *dentry, struct dentry *hidden_dentry,
+			    int bindex);
+
+/* Is this directory empty: 0 if it is empty, -ENOTEMPTY if not. */
+extern int check_empty(struct dentry *dentry,
+		       struct unionfs_dir_state **namelist);
+/* Delete whiteouts from this directory in branch bindex. */
+extern int delete_whiteouts(struct dentry *dentry, int bindex,
+			    struct unionfs_dir_state *namelist);
+
+/* Re-lookup a hidden dentry. */
+extern int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex);
+
+extern void unionfs_reinterpose(struct dentry *this_dentry);
+extern struct super_block *unionfs_duplicate_super(struct super_block *sb);
+
+/* Locking functions. */
+extern int unionfs_setlk(struct file *file, int cmd, struct file_lock *fl);
+extern int unionfs_getlk(struct file *file, struct file_lock *fl);
+
+/* Common file operations. */
+extern int unionfs_file_revalidate(struct file *file, int willwrite);
+extern int unionfs_open(struct inode *inode, struct file *file);
+extern int unionfs_file_release(struct inode *inode, struct file *file);
+extern int unionfs_flush(struct file *file);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+extern long unionfs_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg);
+#else
+extern int unionfs_ioctl(struct inode *unused, struct file *file,
+			 unsigned int cmd, unsigned long arg);
+#endif
+
+/* Inode operations */
+extern int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry);
+int unionfs_unlink(struct inode *dir, struct dentry *dentry);
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry);
+
+int unionfs_d_revalidate(struct dentry *dentry, struct nameidata *nd);
+
+/* The values for unionfs_interpose's flag. */
+#define INTERPOSE_DEFAULT	0
+#define INTERPOSE_LOOKUP	1
+#define INTERPOSE_REVAL		2
+#define INTERPOSE_REVAL_NEG	3
+#define INTERPOSE_PARTIAL	4
+
+extern int unionfs_interpose(struct dentry *this_dentry, struct super_block *sb,
+			     int flag);
+
+/* Branch management ioctls. */
+int unionfs_ioctl_branchcount(struct file *file, unsigned int cmd,
+			      unsigned long arg);
+int unionfs_ioctl_incgen(struct file *file, unsigned int cmd,
+			 unsigned long arg);
+int unionfs_ioctl_addbranch(struct inode *inode, unsigned int cmd,
+			    unsigned long arg);
+int unionfs_ioctl_delbranch(struct super_block *sb, unsigned long arg);
+int unionfs_ioctl_rdwrbranch(struct inode *inode, unsigned int cmd,
+			     unsigned long arg);
+int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
+			    unsigned long arg);
+
+/* Verify that a branch is valid. */
+int check_branch(struct nameidata *nd);
+
+/* Extended attribute functions. */
+extern void *xattr_alloc(size_t size, size_t limit);
+extern void xattr_free(void *ptr, size_t size);
+
+extern ssize_t unionfs_getxattr(struct dentry *dentry, const char *name,
+				void *value, size_t size);
+extern int unionfs_removexattr(struct dentry *dentry, const char *name);
+extern ssize_t unionfs_listxattr(struct dentry *dentry, char *list,
+				 size_t size);
+
+int unionfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		     size_t size, int flags);
+
+/* The root directory is unhashed, but isn't deleted. */
+static inline int d_deleted(struct dentry *d)
+{
+	return d_unhashed(d) && (d != d->d_sb->s_root);
+}
+
+/* returns the sum of the n_link values of all the underlying inodes of the passed inode */
+static inline int get_nlinks(struct inode *inode)
+{
+	int sum_nlinks = 0;
+	int dirs = 0;
+	int bindex;
+	struct inode *hidden_inode;
+
+	if (!S_ISDIR(inode->i_mode))
+		return itohi(inode)->i_nlink;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		hidden_inode = itohi_index(inode, bindex);
+		if (!hidden_inode || !S_ISDIR(hidden_inode->i_mode))
+			continue;
+		BUG_ON(hidden_inode->i_nlink < 0);
+
+		/* A deleted directory. */
+		if (hidden_inode->i_nlink == 0)
+			continue;
+		dirs++;
+		/* A broken directory (e.g., squashfs). */
+		if (hidden_inode->i_nlink == 1)
+			sum_nlinks += 2;
+		else
+			sum_nlinks += (hidden_inode->i_nlink - 2);
+	}
+
+	if (!dirs)
+		return 0;
+	return sum_nlinks + 2;
+}
+
+static inline void fist_copy_attr_atime(struct inode *dest,
+					const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+}
+static inline void fist_copy_attr_times(struct inode *dest,
+					const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+}
+static inline void fist_copy_attr_timesizes(struct inode *dest,
+					    const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+	dest->i_size = src->i_size;
+	dest->i_blocks = src->i_blocks;
+}
+static inline void fist_copy_attr_all(struct inode *dest,
+				      const struct inode *src)
+{
+	print_entry_location();
+
+	dest->i_mode = src->i_mode;
+	/* we do not need to copy if the file is a deleted file */
+	if (dest->i_nlink > 0)
+		dest->i_nlink = get_nlinks(dest);
+	dest->i_uid = src->i_uid;
+	dest->i_gid = src->i_gid;
+	dest->i_rdev = src->i_rdev;
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+	dest->i_blksize = src->i_blksize;
+	dest->i_blkbits = src->i_blkbits;
+	dest->i_size = src->i_size;
+	dest->i_blocks = src->i_blocks;
+	dest->i_flags = src->i_flags;
+
+	print_exit_location();
+}
+
+struct dentry *unionfs_lookup_backend(struct dentry *dentry, int lookupmode);
+int is_stale_inode(struct inode *inode);
+void make_stale_inode(struct inode *inode);
+
+#define IS_SET(sb, check_flag) (check_flag & MOUNT_FLAG(sb))
+
+/* unionfs_permission, check if we should bypass error to facilitate copyup */
+#define IS_COPYUP_ERR(err) (err == -EROFS)
+
+/* unionfs_open, check if we need to copyup the file */
+#define OPEN_WRITE_FLAGS (O_WRONLY | O_RDWR | O_APPEND)
+#define IS_WRITE_FLAG(flag) (flag & (OPEN_WRITE_FLAGS))
+
+static inline int branchperms(struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+
+	return stopd(sb)->usi_data[index].branchperms;
+}
+static inline int set_branchperms(struct super_block *sb, int index, int perms)
+{
+	BUG_ON(index < 0);
+
+	stopd(sb)->usi_data[index].branchperms = perms;
+
+	return perms;
+}
+
+/* Is this file on a read-only branch? */
+static inline int __is_robranch_super(struct super_block *sb, int index,
+				      char *file, const char *function,
+				      int line)
+{
+	int err = 0;
+
+	print_util_entry_location();
+
+	if (!(branchperms(sb, index) & MAY_WRITE))
+		err = -EROFS;
+
+	print_util_exit_status(err);
+	return err;
+}
+
+/* Is this file on a read-only branch? */
+static inline int __is_robranch_index(struct dentry *dentry, int index,
+				      char *file, const char *function,
+				      int line)
+{
+	int err = 0;
+	int perms;
+
+	print_util_entry_location();
+
+	BUG_ON(index < 0);
+
+	perms = stopd(dentry->d_sb)->usi_data[index].branchperms;
+
+	if ((!(perms & MAY_WRITE))
+	    || (IS_RDONLY(dtohd_index(dentry, index)->d_inode)))
+		err = -EROFS;
+
+	print_util_exit_status(err);
+
+	return err;
+}
+static inline int __is_robranch(struct dentry *dentry, char *file,
+				const char *function, int line)
+{
+	int index;
+	int err;
+
+	print_util_entry_location();
+
+	index = dtopd(dentry)->udi_bstart;
+	BUG_ON(index < 0);
+
+	err = __is_robranch_index(dentry, index, file, function, line);
+
+	print_util_exit_status(err);
+
+	return err;
+}
+
+#define is_robranch(d) __is_robranch(d, __FILE__, __FUNCTION__, __LINE__)
+#define is_robranch_super(s, n) __is_robranch_super(s, n, __FILE__, __FUNCTION__, __LINE__)
+
+/* What do we use for whiteouts. */
+#define WHPFX ".wh."
+#define WHLEN 4
+/* If a directory contains this file, then it is opaque.  We start with the
+ * .wh. flag so that it is blocked by loomkup.
+ */
+#define UNIONFS_DIR_OPAQUE_NAME "__dir_opaque"
+#define UNIONFS_DIR_OPAQUE WHPFX UNIONFS_DIR_OPAQUE_NAME
+
+/* construct whiteout filename */
+static inline char *alloc_whname(const char *name, int len)
+{
+	char *buf;
+
+	buf = KMALLOC(len + WHLEN + 1, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	strcpy(buf, WHPFX);
+	strlcat(buf, name, len + WHLEN + 1);
+
+	return buf;
+}
+
+#ifdef UNIONFS_IMAP
+/*
+* Defines,structs,and functions for persistent used by kernel and user
+*/
+#define MAX_MAPS 256
+#define UUID_LEN 16
+#define FORWARDMAP_MAGIC 0x4b1cb38f
+#define REVERSEMAP_MAGIC 0Xfcafad71
+#define FORWARDMAP_VERSION 0x02
+#define REVERSEMAP_VERSION 0x01
+#define FIRST_VALID_INODE 3
+struct fmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t usedbranches;
+	uint8_t uuid[UUID_LEN];
+};
+
+struct rmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t fwduuid[UUID_LEN];
+	uint8_t revuuid[UUID_LEN];
+	fsid_t fsid;
+};
+struct bmapent {
+	fsid_t fsid;
+	uint8_t uuid[UUID_LEN];
+};
+struct fmapent {
+	uint8_t fsnum;
+	uint64_t inode;
+};
+
+/* Persistant Inode functions */
+extern int read_uin(struct super_block *sb, uint8_t branchnum,
+		    ino_t inode_number, int flag, ino_t * uino);
+extern int write_uin(struct super_block *sb, ino_t ino, int bindex,
+		     ino_t hidden_ino);
+extern int get_lin(struct super_block *sb, ino_t inode_number,
+		   struct fmapent *entry);
+extern int parse_imap_option(struct super_block *sb,
+			     struct unionfs_dentry_info *hidden_root_info,
+			     char *options);
+extern void cleanup_imap_data(struct super_block *sb);
+#endif				/*#ifdef UNIONFS_IMAP */
+
+/* Definitions for various ways to handle errors.
+   Each flag's value is its bit position */
+
+/* 1 = DELETE_ALL, 0 = check for DELETE_WHITEOUT */
+#ifdef UNIONFS_DELETE_ALL
+#define DELETE_ALL		4
+#endif
+
+/* 1 = use current user's permissions, 0 = use original owner's permissions */
+#define COPYUP_CURRENT_USER     8
+
+#define VALID_MOUNT_FLAGS (DELETE_ALL | COPYUP_OWNER)
+
+/*
+ * MACROS:
+ */
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif				/* not SEEK_SET */
+
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif				/* not SEEK_CUR */
+
+#ifndef SEEK_END
+#define SEEK_END 2
+#endif				/* not SEEK_END */
+
+#ifndef DEFAULT_POLLMASK
+#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
+#endif
+
+/*
+ * EXTERNALS:
+ */
+
+/* JS: These two functions are here because it is kind of daft to copy and paste the
+ * contents of the two functions to 32+ places in unionfs
+ */
+static inline struct dentry *lock_parent(struct dentry *dentry)
+{
+	struct dentry *dir = DGET(dentry->d_parent);
+
+	down(&dir->d_inode->i_sem);
+	return dir;
+}
+
+static inline void unlock_dir(struct dentry *dir)
+{
+	up(&dir->d_inode->i_sem);
+	DPUT(dir);
+}
+
+#endif				/* __KERNEL__ */
+
+/*
+ * DEFINITIONS FOR USER AND KERNEL CODE:
+ * (Note: ioctl numbers 1--9 are reserved for fistgen, the rest
+ *  are auto-generated automatically based on the user's .fist file.)
+ */
+# define FIST_IOCTL_GET_DEBUG_VALUE	_IOR(0x15, 1, int)
+# define FIST_IOCTL_SET_DEBUG_VALUE	_IOW(0x15, 2, int)
+# define UNIONFS_IOCTL_BRANCH_COUNT	_IOR(0x15, 10, int)
+# define UNIONFS_IOCTL_INCGEN		_IOR(0x15, 11, int)
+# define UNIONFS_IOCTL_ADDBRANCH	_IOW(0x15, 12, int)
+# define UNIONFS_IOCTL_DELBRANCH	_IOW(0x15, 13, int)
+# define UNIONFS_IOCTL_RDWRBRANCH	_IOW(0x15, 14, int)
+# define UNIONFS_IOCTL_QUERYFILE	_IOR(0x15, 15, int)
+
+/* We don't support normal remount, but unionctl uses it. */
+# define UNIONFS_REMOUNT_MAGIC		0x4a5a4380
+
+/* should be at least LAST_USED_UNIONFS_PERMISSION<<1 */
+#define MAY_NFSRO			16
+
+struct unionfs_addbranch_args {
+	unsigned int ab_branch;
+	char *ab_path;
+	unsigned int ab_perms;
+};
+
+struct unionfs_rdwrbranch_args {
+	unsigned int rwb_branch;
+	unsigned int rwb_perms;
+};
+
+#endif				/* not __UNIONFS_H_ */
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionfs_macros.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionfs_macros.h	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionfs_macros.h,v 1.10 2006/02/13 00:18:40 jsipek Exp $
+ */
+
+#ifndef __UNIONFS_H_
+#error This file should only be included from unionfs.h!
+#endif
+
+/* File to hidden file. */
+static inline struct file *ftohf(struct file *f)
+{
+	return ftopd(f)->ufi_file[fbstart(f)];
+}
+
+static inline struct file *ftohf_index(struct file *f, int index)
+{
+	return ftopd(f)->ufi_file[index];
+}
+
+static inline void set_ftohf_index(struct file *f, int index, struct file *val)
+{
+	ftopd(f)->ufi_file[index] = val;
+}
+
+static inline void set_ftohf(struct file *f, struct file *val)
+{
+	ftopd(f)->ufi_file[fbstart(f)] = val;
+}
+
+/* Inode to hidden inode. */
+static inline struct inode *itohi(struct inode *i)
+{
+	return itopd(i)->uii_inode[ibstart(i)];
+}
+
+static inline struct inode *itohi_index(struct inode *i, int index)
+{
+	return itopd(i)->uii_inode[index];
+}
+
+static inline void set_itohi_index(struct inode *i, int index,
+				   struct inode *val)
+{
+	itopd(i)->uii_inode[index] = val;
+}
+
+static inline void set_itohi(struct inode *i, struct inode *val)
+{
+	itopd(i)->uii_inode[ibstart(i)] = val;
+}
+
+/* Superblock to hidden superblock. */
+static inline struct super_block *stohs(struct super_block *o)
+{
+	return stopd(o)->usi_data[sbstart(o)].sb;
+}
+
+static inline struct super_block *stohs_index(struct super_block *o, int index)
+{
+	return stopd(o)->usi_data[index].sb;
+}
+
+static inline void set_stohs_index(struct super_block *o, int index,
+				   struct super_block *val)
+{
+	stopd(o)->usi_data[index].sb = val;
+}
+
+static inline void set_stohs(struct super_block *o, struct super_block *val)
+{
+	stopd(o)->usi_data[sbstart(o)].sb = val;
+}
+
+/* Super to hidden mount. */
+static inline struct vfsmount *stohiddenmnt_index(struct super_block *o,
+						  int index)
+{
+	return stopd(o)->usi_data[index].hidden_mnt;
+}
+
+static inline void set_stohiddenmnt_index(struct super_block *o, int index,
+					  struct vfsmount *val)
+{
+	stopd(o)->usi_data[index].hidden_mnt = val;
+}
+
+/* Branch count macros. */
+static inline int branch_count(struct super_block *o, int index)
+{
+	return atomic_read(&stopd(o)->usi_data[index].sbcount);
+}
+
+static inline void set_branch_count(struct super_block *o, int index, int val)
+{
+	atomic_set(&stopd(o)->usi_data[index].sbcount, val);
+}
+
+static inline void branchget(struct super_block *o, int index)
+{
+	atomic_inc(&stopd(o)->usi_data[index].sbcount);
+}
+
+static inline void branchput(struct super_block *o, int index)
+{
+	atomic_dec(&stopd(o)->usi_data[index].sbcount);
+}
+
+/* Dentry macros */
+static inline struct unionfs_dentry_info *dtopd(const struct dentry *dent)
+{
+	return (struct unionfs_dentry_info *)dent->d_fsdata;
+}
+
+#define dtopd_lhs(dent) ((dent)->d_fsdata)
+#define dtopd_nocheck(dent) dtopd(dent)
+#define dbstart(dent) (dtopd(dent)->udi_bstart)
+#define set_dbstart(dent, val) do { dtopd(dent)->udi_bstart = val; } while(0)
+#define dbend(dent) (dtopd(dent)->udi_bend)
+#define set_dbend(dent, val) do { dtopd(dent)->udi_bend = val; } while(0)
+#define dbopaque(dent) (dtopd(dent)->udi_bopaque)
+#define set_dbopaque(dent, val) do { dtopd(dent)->udi_bopaque = val; } while (0)
+
+static inline void set_dtohd_index(struct dentry *dent, int index,
+				   struct dentry *val)
+{
+	dtopd(dent)->udi_dentry[index] = val;
+}
+
+static inline struct dentry *dtohd_index(const struct dentry *dent, int index)
+{
+	return dtopd(dent)->udi_dentry[index];
+}
+
+static inline struct dentry *dtohd(const struct dentry *dent)
+{
+	return dtopd(dent)->udi_dentry[dbstart(dent)];
+}
+
+#define set_dtohd_index_nocheck(dent, index, val) set_dtohd_index(dent, index, val)
+#define dtohd_index_nocheck(dent, index) dtohd_index(dent, index)
+
+#define dtohd_ptr(dent) (dtopd_nocheck(dent)->udi_dentry)
+
+/* Macros for locking a dentry. */
+#define lock_dentry(d) down(&dtopd(d)->udi_sem)
+#define unlock_dentry(d) up(&dtopd(d)->udi_sem)
+#define verify_locked(d)
+
+/* All of these should be noops. */
+static inline int fist_get_debug_value(void)
+{
+	return 0;
+}
+static inline int fist_set_debug_value(int val)
+{
+	return -ENOTSUPP;
+}
+
+#define fist_print_dentry(msg, o)
+#define __fist_print_dentry(msg, o, i)
+#define fist_print_generic_dentry(msg, o)
+#define fist_print_generic_dentry3(msg, o)
+#define __fist_print_generic_dentry(msg, o, i)
+#define fist_print_inode(msg, o)
+#define fist_print_generic_inode(msg, o)
+#define fist_print_file(msg, o)
+#define fist_checkinode(o, msg)
+#define fist_print_sb(msg, o)
+
+#define fist_dprint(args...)
+#define print_entry(args...)
+#define print_entry_location()
+#define print_exit_location()
+#define print_exit_status(status)
+#define print_exit_pointer(status)
+#define print_util_entry(args...)
+#define print_util_entry_location()
+#define print_util_exit_location()
+#define print_util_exit_status(status)
+#define print_util_exit_pointer(status)
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionfs.mod.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionfs.mod.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,117 @@
+#include <linux/module.h>
+#include <linux/vermagic.h>
+#include <linux/compiler.h>
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+
+#undef unix
+struct module __this_module
+__attribute__((section(".gnu.linkonce.this_module"))) = {
+ .name = __stringify(KBUILD_MODNAME),
+ .init = init_module,
+#ifdef CONFIG_MODULE_UNLOAD
+ .exit = cleanup_module,
+#endif
+};
+
+static const struct modversion_info ____versions[]
+__attribute_used__
+__attribute__((section("__versions"))) = {
+	{ 0xd32c915c, "struct_module" },
+	{ 0xe95696e7, "vfs_create" },
+	{ 0xcf1fe90f, "d_path" },
+	{ 0x96c05b2d, "kmem_cache_destroy" },
+	{ 0x12da5bb2, "__kmalloc" },
+	{ 0x97b206d8, "security_ops" },
+	{ 0x2b1778ee, "get_sb_nodev" },
+	{ 0x2f1b5cbf, "generic_file_llseek" },
+	{ 0x5a27c0c5, "__mark_inode_dirty" },
+	{ 0xd6ee688f, "vmalloc" },
+	{ 0xfc2543a8, "vfs_readdir" },
+	{ 0x89b301d4, "param_get_int" },
+	{ 0xbeb16aff, "vfs_link" },
+	{ 0x79aa04a2, "get_random_bytes" },
+	{ 0x74cc238d, "current_kernel_time" },
+	{ 0x23310184, "malloc_sizes" },
+	{ 0xf03a211d, "vfs_llseek" },
+	{ 0x20000329, "simple_strtoul" },
+	{ 0xc88c7ada, "_spin_lock" },
+	{ 0xffe7d2c3, "dput" },
+	{ 0x4364c43c, "seq_printf" },
+	{ 0xa03d6a57, "__get_user_4" },
+	{ 0x74ccc6a6, "vfs_follow_link" },
+	{ 0x6c3e2634, "d_find_alias" },
+	{ 0xc659a6d6, "rwsem_down_write_failed" },
+	{ 0xf4900a8d, "dentry_open" },
+	{ 0xb4d1020c, "vfs_mknod" },
+	{ 0x85df9b6c, "strsep" },
+	{ 0xd414c791, "generic_read_dir" },
+	{ 0x2fd1d81c, "vfree" },
+	{ 0x98bd6f46, "param_set_int" },
+	{ 0xd31e37a1, "igrab" },
+	{ 0x201be703, "vfs_symlink" },
+	{ 0x1d26aa98, "sprintf" },
+	{ 0x7d11c268, "jiffies" },
+	{ 0xd533bec7, "__might_sleep" },
+	{ 0x500e0f7e, "vfs_rmdir" },
+	{ 0xce378d15, "unlock_rename" },
+	{ 0xdd0a2ba2, "strlcat" },
+	{ 0x7c60d66e, "getname" },
+	{ 0x1b7d4074, "printk" },
+	{ 0x9f42c98d, "d_rehash" },
+	{ 0x8cba25c9, "rwsem_wake" },
+	{ 0x2f287f0d, "copy_to_user" },
+	{ 0x2cd3086, "__down_failed_trylock" },
+	{ 0xaec4759f, "vprintk" },
+	{ 0x177db3cd, "kmem_cache_free" },
+	{ 0x24db2f29, "lock_rename" },
+	{ 0x7f215d1a, "dcache_lock" },
+	{ 0x542ac514, "path_release" },
+	{ 0x608c9ae, "fput" },
+	{ 0x69900829, "_spin_unlock" },
+	{ 0x118f01ea, "putname" },
+	{ 0xa3eda7a8, "inode_init_once" },
+	{ 0x7dceceac, "capable" },
+	{ 0x2328ae0f, "kmem_cache_alloc" },
+	{ 0xb2fd5ceb, "__put_user_4" },
+	{ 0x8dfcfaa5, "path_lookup" },
+	{ 0x2edfde60, "mntput_no_expire" },
+	{ 0x840e938a, "d_alloc" },
+	{ 0x107d6ba3, "__get_free_pages" },
+	{ 0xdd004bdc, "unlock_new_inode" },
+	{ 0x95105d4, "vfs_statfs" },
+	{ 0x5950c7ce, "vfs_mkdir" },
+	{ 0xe51cdc5d, "vfs_unlink" },
+	{ 0x17bce82f, "kmem_cache_create" },
+	{ 0xedb27b70, "register_filesystem" },
+	{ 0x9941ccb8, "free_pages" },
+	{ 0x1d10cdb2, "kzalloc" },
+	{ 0x93892132, "iput" },
+	{ 0x37a0cba, "kfree" },
+	{ 0xcf67c9b0, "iunique" },
+	{ 0xf9ae11e9, "generic_permission" },
+	{ 0x351ccbe8, "d_splice_alias" },
+	{ 0x60a4461c, "__up_wakeup" },
+	{ 0xcb956da, "unregister_filesystem" },
+	{ 0xf2e89af8, "init_special_inode" },
+	{ 0x25da070, "snprintf" },
+	{ 0xc5ebe7a1, "lookup_one_len" },
+	{ 0x96b27088, "__down_failed" },
+	{ 0xc65dd31d, "vfs_rename" },
+	{ 0xd6c963c, "copy_from_user" },
+	{ 0x38e011c9, "notify_change" },
+	{ 0xae57a38d, "clear_inode" },
+	{ 0x9f5b043, "d_instantiate" },
+	{ 0x1f0b2def, "get_write_access" },
+	{ 0x8e87c4af, "rwsem_down_read_failed" },
+	{ 0x75ee388e, "iget_locked" },
+	{ 0xd5b562b8, "generic_shutdown_super" },
+};
+
+static const char __module_depends[]
+__attribute_used__
+__attribute__((section(".modinfo"))) =
+"depends=";
+
+
+MODULE_INFO(srcversion, "47B7DB80EF1920648319C46");
--- linux-2.6.13.1/fs/unionfs/unionimap.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionimap.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,516 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionimap.c,v 1.25 2006/02/09 04:41:00 jsipek Exp $
+ */
+
+#include "unionimap.h"
+
+/**
+ *	print_usage()
+ *	Function used to print out usage information
+ *	when an error is encountered
+ */
+void print_usage(void)
+{
+	fprintf(stderr,
+		"unionimap version: $Id: unionimap.c,v 1.25 2006/02/09 04:41:00 jsipek Exp $\n");
+	fprintf(stderr, "Distributed with Unionfs " UNIONFS_VERSION "\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Usage: unionimap [-c] [-a ARG:] filename path\n");
+	fprintf(stderr, " flag -c: create forward map with name filename\n");
+	fprintf(stderr,
+		" flag -a ARG: create reverse map with name filename and path and add it to forwardmap ARG\n");
+	fprintf(stderr,
+		" flag -d: if set once will dump the header of the map if twice it will also dump the contents\n");
+	fprintf(stderr, " flag -h: prints this message then quits\n");
+	fprintf(stderr,
+		" please note that -c -a and -d are mutually exclusive\n");
+}
+
+/**
+ * create_forwardmap(char *filename)
+ * verifies that the forward map is valid.
+ *
+ */
+int create_forwardmap(char *filename)
+{
+	int byteswritten = 0, err = 0;
+	int fwrdmap = 0;
+	struct fmaphdr header;
+	void *table = NULL;
+	uuid_t uuid;
+
+	fwrdmap = creat(filename, S_IRUSR | S_IWUSR);
+	if (fwrdmap < 0) {
+		err = -EINVAL;
+		goto out;
+	}
+	memset(&header, 0, sizeof(struct fmaphdr));
+	header.version = FORWARDMAP_VERSION;
+	header.magic = FORWARDMAP_MAGIC;
+	header.usedbranches = 0;
+	uuid_generate(uuid);
+	memcpy(&header.uuid, &uuid, UUID_LEN);
+	byteswritten = write(fwrdmap, (void *)&header, sizeof(struct fmaphdr));
+	if (byteswritten < sizeof(struct fmaphdr)) {
+		perror("Failed Writting header: ");
+		err = -EIO;
+		goto out;
+	}
+	table = malloc(sizeof(struct bmapent[256]));
+	if (!table) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memset(table, 0, sizeof(struct bmapent[256]));
+	byteswritten = write(fwrdmap, table, sizeof(struct bmapent[256]));
+	if (byteswritten < sizeof(struct bmapent[256])) {
+		perror("Failed writting table: ");
+		err = -EIO;
+		goto out;
+	}
+      out:
+	if (fwrdmap)
+		close(fwrdmap);
+	if (table)
+		free(table);
+
+	return err;
+}
+int open_forwardmap(struct fmaphdr *header, char *forwardmap)
+{
+	int fwrdmap = 0, bytesread = 0, err = 0;
+	fwrdmap = open(forwardmap, O_RDWR);
+	if (fwrdmap < 0) {
+		perror("Open on Forwardmap  Failed: ");
+		err = errno;
+		goto out_error;
+	}
+	bytesread = read(fwrdmap, (void *)header, sizeof(struct fmaphdr));
+	if (bytesread < 0 || bytesread < sizeof(struct fmaphdr)) {
+		err = -EINVAL;
+		goto out_error;
+	}
+	if (header->magic != FORWARDMAP_MAGIC
+	    || header->version != FORWARDMAP_VERSION) {
+		err = -EINVAL;
+		goto out_error;
+	}
+	if (header->usedbranches == 255) {
+		fprintf(stderr,
+			"Forwardmap already contains maximum number of reverse maps");
+		err = -EINVAL;
+		goto out_error;
+	}
+	err = fwrdmap;
+	goto out;
+      out_error:
+	if (fwrdmap)
+		close(fwrdmap);
+      out:
+	return err;
+}
+int check_if_entry_exists(int fwrdmap, struct statfs stat, char *path)
+{
+	int err = 0, bytesread = 0, i;
+	struct fmaphdr header;
+	struct bmapent btable[256];
+	fsid_t fsid;
+
+	if (fwrdmap < 0) {
+		err = -EINVAL;
+		goto out;
+	}
+	err = lseek(fwrdmap, 0L, SEEK_SET);
+	if (err) {
+		goto out;
+	}
+	bytesread = read(fwrdmap, (void *)&header, sizeof(struct fmaphdr));
+	if (bytesread != sizeof(struct fmaphdr)) {
+		err = -EIO;
+		goto out;
+	}
+	bytesread = read(fwrdmap, (void *)&btable, sizeof(struct bmapent[256]));
+	if (bytesread != sizeof(struct bmapent[256])) {
+		err = -EIO;
+		goto out;
+	}
+	if (((unsigned int *)&stat.f_fsid)[0]
+	    || ((unsigned int *)&stat.f_fsid)[1]) {
+		fsid = stat.f_fsid;
+	} else {
+		err = mkfsid(path, &fsid);
+		if (err) {
+			goto out;
+		}
+	}
+	for (i = 0; i < header.usedbranches; i++) {
+		if (!memcmp(&fsid, &btable[i].fsid, sizeof(fsid_t))) {
+			err = 1;
+			break;
+		}
+	}
+      out:
+	return err;
+}
+int create_reversemap(char *filename, char *path, char *forwardmap)
+{
+	int byteswritten = 0, err = 0, seekres = 0;
+	off_t offset = 0;
+	int fwrdmap = 0, revmap = 0;
+	struct fmaphdr fwdheader;
+	struct rmaphdr revheader;
+	struct statfs stat;
+	struct bmapent ent;
+	uuid_t uuid;
+
+	fwrdmap = open_forwardmap(&fwdheader, forwardmap);
+	if (fwrdmap < 0) {
+		err = fwrdmap;
+		goto out;
+	}
+	memset(&stat, 0, sizeof(struct statfs));
+	err = statfs(path, &stat);
+	if (err) {
+		perror("statfs failed on path: ");
+		goto out;
+	}
+	err = check_if_entry_exists(fwrdmap, stat, path);
+	if (err) {
+		if (err > 0) {
+			err = -EINVAL;
+			fprintf(stderr,
+				"Specified fs already exists in the forward map\n");
+		}
+		goto out;
+	}
+	revmap = open(filename, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
+	if (!revmap) {
+		err = -EINVAL;
+		perror("Open on Reversemap failed: ");
+		goto out;
+	}
+	revheader.version = REVERSEMAP_VERSION;
+	revheader.magic = REVERSEMAP_MAGIC;
+	uuid_generate(uuid);
+	memcpy(&revheader.revuuid, &uuid, UUID_LEN);
+	memcpy(&revheader.fwduuid, &fwdheader.uuid, UUID_LEN);
+
+	if (((unsigned int *)&stat.f_fsid)[0]
+	    || ((unsigned int *)&stat.f_fsid)[1]) {
+		revheader.fsid = stat.f_fsid;
+	} else {
+		err = mkfsid(path, &revheader.fsid);
+		if (err) {
+			goto out;
+		}
+
+	}
+	byteswritten = write(revmap, &revheader, sizeof(struct rmaphdr));
+	if (byteswritten < sizeof(struct rmaphdr)) {
+		err = -EIO;
+		perror("Reversemap Write failed: ");
+		goto out;
+	}
+
+	offset =
+	    sizeof(struct fmaphdr) +
+	    (fwdheader.usedbranches * sizeof(struct bmapent));
+	seekres = lseek(fwrdmap, offset, SEEK_SET);
+	if (!(seekres == offset)) {
+		err = -EIO;
+		perror("Couldent seek to offset in uuid table: ");
+	}
+	errno = 0;
+	memcpy(&ent.uuid, &uuid, UUID_LEN);
+	memcpy(&ent.fsid, &revheader.fsid, sizeof(fsid_t));
+	byteswritten = write(fwrdmap, &ent, sizeof(struct bmapent));
+	if (byteswritten < sizeof(struct bmapent)) {
+		perror("Forwardmap Write failed to write uuid to table: ");
+		err = -EIO;
+		goto out;
+	}
+	fwdheader.usedbranches++;
+	offset = (int)&(((struct fmaphdr *)(0))->usedbranches);
+	seekres = lseek(fwrdmap, offset, SEEK_SET);
+	if (!(seekres == offset)) {
+		perror("Couldent seek to usedbranch offset: ");
+		err = -EIO;
+		goto out;
+	}
+	byteswritten = write(fwrdmap, &fwdheader.usedbranches, sizeof(uint8_t));
+	if (byteswritten < sizeof(uint8_t)) {
+		perror("Forwardmap Write failed to update usedbranches: ");
+		err = -EIO;
+		goto out;
+	}
+
+      out:
+	if (fwrdmap) {
+		close(fwrdmap);
+	}
+	if (revmap) {
+		close(revmap);
+	}
+	return err;
+}
+int print_forwardmap(int file, int debug_level)
+{
+	int err = 0, bytesread = 0, i;
+	struct fmaphdr header;
+	struct bmapent btable[256];
+	char *uuid_unparsed;
+	struct fmapent entry;
+
+	if (file < 0 || debug_level <= 0) {
+		err = -EINVAL;
+		goto out;
+	}
+	err = lseek(file, 0L, SEEK_SET);
+	if (err) {
+		goto out;
+	}
+	bytesread = read(file, (void *)&header, sizeof(struct fmaphdr));
+	if (bytesread != sizeof(struct fmaphdr)) {
+		err = -EIO;
+		goto out;
+	}
+	uuid_unparsed = (char *)malloc(37);
+	if (!uuid_unparsed) {
+		err = -EIO;
+		goto out;
+	}
+	memset(uuid_unparsed, 0, 37);
+	fprintf(stdout, "Unionfs Forwardmap:\n");
+	fprintf(stdout, "Magic: %x\n", header.magic);
+	fprintf(stdout, "Version: %d\n", header.version);
+	fprintf(stdout, "Used Branches: %d\n", header.usedbranches);
+	uuid_unparse(header.uuid, uuid_unparsed);
+	fprintf(stdout, "UUID: %s\n", uuid_unparsed);
+	bytesread = read(file, (void *)&btable, sizeof(struct bmapent[256]));
+	if (bytesread != sizeof(struct bmapent[256])) {
+		err = -EIO;
+		goto out;
+	}
+	for (i = 0; i < header.usedbranches; i++) {
+		fprintf(stdout, "Branch at index : %d\n", i);
+		fprintf(stdout, "fsid: %04x%04x\n",
+			((unsigned int *)&btable[i].fsid)[0],
+			((unsigned int *)&btable[i].fsid)[1]);
+		uuid_unparse(btable[i].uuid, uuid_unparsed);
+		fprintf(stdout, "uuid: %s\n", uuid_unparsed);
+	}
+	if (debug_level > 1) {
+		unsigned long inode = 1;
+		fprintf(stdout, "%-11s %-8s %-22s\n", "Unionfs", "FS Num",
+			"Lower-Level");
+		while (read(file, (void *)&entry, sizeof(struct fmapent))) {
+			fprintf(stdout, "%-11lu %-8d %-22llu\n", inode++,
+				entry.fsnum,
+				(long long unsigned int)entry.inode);
+		}
+	}
+      out:
+	return err;
+
+}
+int print_reversemap(int file, int debug_level)
+{
+
+	int err = 0, bytesread = 0;
+	struct rmaphdr header;
+	char *uuid_unparsed = NULL;
+	uint64_t inode;
+
+	if (file < 0 || debug_level <= 0) {
+		err = -EINVAL;
+		goto out;
+	}
+	err = lseek(file, 0L, SEEK_SET);
+	if (err) {
+		goto out;
+	}
+	bytesread = read(file, (void *)&header, sizeof(struct rmaphdr));
+	if (bytesread != sizeof(struct rmaphdr)) {
+		err = -EIO;
+		goto out;
+	}
+	uuid_unparsed = (char *)malloc(37);
+	if (!uuid_unparsed) {
+		err = -ENOMEM;
+		goto out;
+	}
+	memset(uuid_unparsed, 0, 37);
+	fprintf(stdout, "Unionfs Reversemap:\n");
+	fprintf(stdout, "Magic: %x\n", header.magic);
+	fprintf(stdout, "Version: %d\n", header.version);
+	uuid_unparse(header.fwduuid, uuid_unparsed);
+	fprintf(stdout, "Forward UUID: %s\n", uuid_unparsed);
+	uuid_unparse(header.revuuid, uuid_unparsed);
+	fprintf(stdout, "Reverse UUID: %s\n", uuid_unparsed);
+	fprintf(stdout, "fsid: %04x%04x\n", ((unsigned int *)&header.fsid)[0],
+		((unsigned int *)&header.fsid)[1]);
+	if (debug_level > 1) {
+		fprintf(stdout, "%-11s %-22s\n", "Lower", "Unionfs");
+		unsigned long lowerlevel = 0;
+		while (read(file, (void *)&inode, sizeof(uint64_t))) {
+			if (inode) {
+				fprintf(stdout, "%-11lu %-22llu\n",
+					lowerlevel++,
+					(long long unsigned int)inode);
+			}
+		}
+	}
+      out:
+	if (uuid_unparsed) {
+		free(uuid_unparsed);
+	}
+	return err;
+}
+int dump_map(char *filename, int debug_level)
+{
+	int err = 0, bytesread = 0, file = 0;
+	uint32_t magic;
+
+	file = open(filename, O_RDONLY);
+	if (file < 0) {
+		err = -EINVAL;
+		goto out;
+	}
+	bytesread = read(file, (void *)&magic, sizeof(uint32_t));
+	if (bytesread < sizeof(uint32_t)) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (magic == FORWARDMAP_MAGIC) {
+		err = print_forwardmap(file, debug_level);
+	} else if (magic == REVERSEMAP_MAGIC) {
+		err = print_reversemap(file, debug_level);
+	} else {
+		err = -EINVAL;
+	}
+      out:
+	if (file) {
+		close(file);
+	}
+
+	return err;
+}
+
+int main(int argc, char **argv)
+{
+	int c = 0;		//Temp varliable to hold our character for the switch
+	int cflag = 0, aflag = 0, dflag = 0;
+	int err = 0;
+	char *avalue = NULL;
+	if (argc < 2) {
+		print_usage();
+		err = -EINVAL;
+		goto out;
+	}
+	while ((c = getopt(argc, argv, "a:cd")) != -1) {
+		switch (c) {
+		case 'c':
+			cflag = c;
+			break;
+		case 'a':
+			aflag = 1;
+			avalue = strdup(optarg);
+			if (!avalue) {
+				perror("strdup");
+				exit(1);
+			}
+			break;
+		case 'd':
+			dflag++;
+			break;
+		case '?':
+			if (isprint(optopt))
+				fprintf(stderr, "Unknown option `-%c'.\n",
+					optopt);
+			else
+				fprintf(stderr,
+					"Unknown option character `\\x%x'.\n",
+					optopt);
+			print_usage();
+			err = -EINVAL;
+			goto out;
+			break;
+		default:
+			print_usage();
+			err = -EINVAL;
+			goto out;
+			break;
+		}
+	}
+	if (optind == argc) {
+		print_usage();
+		err = -EINVAL;
+		goto out;
+	}
+	if (!(cflag ^ aflag ^ dflag)) {
+		print_usage();
+		err = -EINVAL;
+		goto out;
+	}
+	if (cflag) {
+		err = create_forwardmap(argv[optind]);
+		if (err) {
+			unlink(argv[optind]);
+		}
+		goto out;
+	} else if (aflag) {
+		if (optind + 1 > argc) {
+			print_usage();
+			err = -EINVAL;
+			goto out;
+		}
+
+		err = create_reversemap(argv[optind], argv[optind + 1], avalue);
+		if (err) {
+			unlink(argv[optind]);
+			goto out;
+		}
+
+	} else if (dflag) {
+		err = dump_map(argv[optind], dflag);
+		if (err) {
+			goto out;
+		}
+	}
+      out:
+	free(avalue);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unionimap.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unionimap.h	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionimap.h,v 1.11 2006/01/03 01:15:56 jsipek Exp $
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <sys/statfs.h>
+#include <sys/stat.h>
+#include <uuid/uuid.h>
+#include <string.h>
+/*
+ * Defines,structs,and functions for persistent inodes used by kernel and user
+ */
+#define MAX_MAPS 256
+#define UUID_LEN 16
+#define FORWARDMAP_MAGIC 0x4b1cb38f
+#define REVERSEMAP_MAGIC 0Xfcafad71
+#define FORWARDMAP_VERSION 0x02
+#define REVERSEMAP_VERSION 0x01
+
+typedef u_int8_t uint8_t;
+typedef u_int32_t uint32_t;
+typedef u_int64_t uint64_t;
+
+struct fmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t usedbranches;
+	uint8_t uuid[UUID_LEN];
+};
+struct bmapent {
+	fsid_t fsid;
+	uint8_t uuid[UUID_LEN];
+};
+
+struct rmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t fwduuid[UUID_LEN];
+	uint8_t revuuid[UUID_LEN];
+	fsid_t fsid;
+};
+
+struct bpair {
+	fsid_t fsid;
+	uint8_t fsnum;
+};
+
+struct fmapent {
+	uint8_t fsnum;
+	uint64_t inode;
+};
+
+extern int mkfsid(char *path, fsid_t * fsid);
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/unlink.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/unlink.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unlink.c,v 1.38.2.1 2006/04/17 09:36:34 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+#ifdef UNIONFS_DELETE_ALL
+static int unionfs_unlink_all(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bstart, bend, bindex;
+	int err = 0;
+	int global_err = 0;
+
+	print_entry_location();
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bend; bindex >= bstart; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+
+		/* avoid destroying the hidden inode if the file is in use */
+		DGET(hidden_dentry);
+		if (!(err = is_robranch_super(dentry->d_sb, bindex)))
+			err = vfs_unlink(hidden_dir_dentry->d_inode,
+					 hidden_dentry);
+		DPUT(hidden_dentry);
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		unlock_dir(hidden_dir_dentry);
+
+		if (err) {
+			/* passup the last error we got */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			global_err = err;
+		}
+	}
+
+	/* check if encountered error in the above loop */
+	if (global_err) {
+		/* If we failed in the leftmost branch, then err will be set
+		 * and we should move one over to create the whiteout.
+		 * Otherwise, we should try in the leftmost branch. */
+		if (err) {
+			if (dbstart(dentry) == 0) {
+				goto out;
+			}
+			err = create_whiteout(dentry, dbstart(dentry) - 1);
+		} else {
+			err = create_whiteout(dentry, dbstart(dentry));
+		}
+	} else if (dbopaque(dentry) != -1) {
+		/* There is a hidden lower-priority file with the same name. */
+		err = create_whiteout(dentry, dbopaque(dentry));
+	}
+      out:
+	/* propagate number of hard-links */
+	if (dentry->d_inode->i_nlink != 0) {
+		dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+		if (!err && global_err)
+			dentry->d_inode->i_nlink--;
+	}
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (global_err || dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	print_exit_status(err);
+	return err;
+}
+#endif
+static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bindex;
+	int err = 0;
+
+	print_entry_location();
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bindex = dbstart(dentry);
+
+	hidden_dentry = dtohd_index(dentry, bindex);
+	if (!hidden_dentry)
+		goto out;
+
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+
+	/* avoid destroying the hidden inode if the file is in use */
+	DGET(hidden_dentry);
+	if (!(err = is_robranch_super(dentry->d_sb, bindex)))
+		err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
+	DPUT(hidden_dentry);
+	fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+	unlock_dir(hidden_dir_dentry);
+
+	if (err) {
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+	}
+
+	if (err) {
+		if (dbstart(dentry) == 0) {
+			goto out;
+		}
+		err = create_whiteout(dentry, dbstart(dentry) - 1);
+	} else if (dbopaque(dentry) != -1) {
+		/* There is a hidden lower-priority file with the same name. */
+		err = create_whiteout(dentry, dbopaque(dentry));
+	} else {
+		err = create_whiteout(dentry, dbstart(dentry));
+	}
+      out:
+	if (!err)
+		dentry->d_inode->i_nlink--;
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	print_exit_status(err);
+	return err;
+
+}
+
+int unionfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_unlink", dentry);
+
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(dir->i_sb, DELETE_ALL))
+		err = unionfs_unlink_all(dir, dentry);
+	else
+#endif
+		err = unionfs_unlink_whiteout(dir, dentry);
+	/* call d_drop so the system "forgets" about us */
+	if (!err)
+		d_drop(dentry);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,
+			       struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry = NULL;
+
+	print_entry_location();
+	fist_print_dentry("IN unionfs_rmdir_first: ", dentry);
+
+	/* Here we need to remove whiteout entries. */
+	err = delete_whiteouts(dentry, dbstart(dentry), namelist);
+	if (err) {
+		goto out;
+	}
+
+	hidden_dentry = dtohd(dentry);
+
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+
+	/* avoid destroying the hidden inode if the file is in use */
+	DGET(hidden_dentry);
+	if (!(err = is_robranch(dentry))) {
+		err = vfs_rmdir(hidden_dir_dentry->d_inode, hidden_dentry);
+	}
+	DPUT(hidden_dentry);
+
+	fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+
+      out:
+	if (hidden_dir_dentry) {
+		unlock_dir(hidden_dir_dentry);
+	}
+	fist_print_dentry("OUT unionfs_rmdir_first: ", dentry);
+	print_exit_status(err);
+	return err;
+}
+
+#ifdef UNIONFS_DELETE_ALL
+static int unionfs_rmdir_all(struct inode *dir, struct dentry *dentry,
+			     struct unionfs_dir_state *namelist)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bstart, bend, bindex;
+	int err = 0;
+	int global_err = 0;
+
+	print_entry_location();
+	fist_print_dentry("IN unionfs_rmdir_all: ", dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bend; bindex >= bstart; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+		if (S_ISDIR(hidden_dentry->d_inode->i_mode)) {
+			delete_whiteouts(dentry, bindex, namelist);
+			if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+				err =
+				    vfs_rmdir(hidden_dir_dentry->d_inode,
+					      hidden_dentry);
+			}
+		} else {
+			err = -EISDIR;
+		}
+
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		unlock_dir(hidden_dir_dentry);
+		if (err) {
+			int local_err =
+			    unionfs_refresh_hidden_dentry(dentry, bindex);
+			if (local_err) {
+				err = local_err;
+				goto out;
+			}
+
+			if (!IS_COPYUP_ERR(err) && err != -ENOTEMPTY
+			    && err != -EISDIR)
+				goto out;
+
+			global_err = err;
+		}
+	}
+
+	/* check if encountered error in the above loop */
+	if (global_err) {
+		/* If we failed in the leftmost branch, then err will be set and we should
+		 * move one over to create the whiteout.  Otherwise, we should try in the
+		 * leftmost branch.
+		 */
+		if (err) {
+			if (dbstart(dentry) == 0) {
+				goto out;
+			}
+			err = create_whiteout(dentry, dbstart(dentry) - 1);
+		} else {
+			err = create_whiteout(dentry, dbstart(dentry));
+		}
+	} else {
+		err = create_whiteout(dentry, dbstart(dentry));
+	}
+
+      out:
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+
+	fist_print_dentry("OUT unionfs_rmdir_all: ", dentry);
+	print_exit_status(err);
+	return err;
+}
+#endif
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct unionfs_dir_state *namelist = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	fist_print_dentry("IN unionfs_rmdir: ", dentry);
+
+	/* check if this unionfs directory is empty or not */
+	err = check_empty(dentry, &namelist);
+	if (err) {
+#if 0
+		/* vfs_rmdir(our caller) unhashed the dentry.  This will recover
+		 * the Unionfs inode number for the directory itself, but the 
+		 * children are already lost.  It seems that tmpfs manages its
+		 * way around this by upping the refcount on everything.
+		 *
+		 * Even if we do this, we still lose the inode numbers of the
+		 * children.  The best way to fix this is to fix the VFS (or
+		 * use persistent inode maps). */
+		if (d_unhashed(dentry))
+			d_rehash(dentry);
+#endif
+		goto out;
+	}
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(dir->i_sb, DELETE_ALL)) {
+		/* delete all. */
+		err = unionfs_rmdir_all(dir, dentry, namelist);
+	} else {		/* Delete the first directory. */
+#endif
+		err = unionfs_rmdir_first(dir, dentry, namelist);
+		/* create whiteout */
+		if (!err) {
+			err = create_whiteout(dentry, dbstart(dentry));
+		} else {
+			int new_err;
+
+			if (dbstart(dentry) == 0)
+				goto out;
+
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+
+			new_err = create_whiteout(dentry, dbstart(dentry) - 1);
+			if (new_err != -EEXIST)
+				err = new_err;
+		}
+
+#ifdef UNIONFS_DELETE_ALL
+	}
+#endif
+      out:
+	/* call d_drop so the system "forgets" about us */
+	if (!err)
+		d_drop(dentry);
+
+	if (namelist)
+		free_rdstate(namelist);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/usercommon.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/usercommon.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: usercommon.c,v 1.8 2006/01/03 01:15:56 jsipek Exp $
+ */
+/*
+ * Copyright (c) 2003-2005 Erez Zadok
+ * Copyright (c) 2003-2005 Charles P. Wright
+ * Copyright (c) 2003-2005 Mohammad Nayyer Zubair
+ * Copyright (c) 2003-2005 Puja Gupta
+ * Copyright (c) 2003-2005 Harikesavan Krishnan
+ * Copyright (c) 2003-2005 Stony Brook University
+ * Copyright (c) 2003-2005 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/sysmacros.h>
+/*
+ * This function will take a patch and check it against /proc/mounts to
+ * find its mount point. If uniononly is set  then it will make sure its
+ * a unionf  mount point. This function assumes the both options and actual_path
+ * are valid and not null;
+ */
+int find_union(const char *path, char **options, char **actual_path,
+	       int uniononly)
+{
+	FILE *f = NULL;
+	char *s = NULL;
+	char *s2 = NULL;
+	char *p;
+	char *q;
+	int candidate = 0;
+	int mallocsize = 1024;	/* Just a reasonable starting value. */
+
+      retry:
+	if (*options) {
+		free(*options);
+		*options = NULL;
+	}
+
+	if (*actual_path) {
+		free(*actual_path);
+		*actual_path = NULL;
+	}
+	if (f) {
+		fclose(f);
+		f = NULL;
+	}
+	s2 = realloc(s, mallocsize);
+	if (!s2) {
+		fprintf(stderr, "realloc(%d): %s\n", mallocsize,
+			strerror(errno));
+		goto out;
+	}
+	s = s2;
+
+	f = fopen("/proc/mounts", "r");
+	if (!f) {
+		fprintf(stderr, "fopen(/proc/mounts): %s\n", strerror(errno));
+		goto out;
+	}
+	while (fgets(s, mallocsize, f)) {
+		int testcan;
+
+		/* If we don't have enough information, we should remalloc it. */
+		if (strlen(s) == (mallocsize - 1)) {
+			mallocsize *= 2;
+			goto retry;
+		}
+
+		p = strchr(s, ' ');
+		if (!p)
+			continue;
+		p++;
+
+		q = strchr(p, ' ');
+		if (!q)
+			continue;
+		*q++ = '\0';
+
+		testcan = strlen(p);
+		if (testcan <= candidate) {
+			continue;
+		}
+
+		if (!strncmp(path, p, testcan)) {
+			if (*actual_path) {
+				free(*actual_path);
+			}
+			*actual_path = strdup(p);
+			if (!*actual_path) {
+				fprintf(stderr, "strdup: %s\n",
+					strerror(errno));
+				goto out;
+			}
+			p = strchr(q, ' ');
+			if (!p)
+				continue;
+			*p++ = '\0';
+			if (uniononly) {
+				if (strcmp(q, "unionfs")) {
+					candidate = 0;
+					continue;
+				}
+			}
+			candidate = testcan;
+
+			q = strrchr(p, ' ');
+			if (!q)
+				continue;
+			*q = '\0';
+			q = strrchr(p, ' ');
+			if (!q)
+				continue;
+			*q = '\0';
+
+			if (*options) {
+				free(*options);
+			}
+			*options = strdup(p);
+			if (!*options) {
+				fprintf(stderr, "strdup: %s\n",
+					strerror(errno));
+				goto out;
+			}
+		}
+	}
+
+      out:
+	if (s)
+		free(s);
+	if (f)
+		fclose(f);
+
+	if (*options) {
+		return 0;
+	}
+
+	errno = -ENOENT;
+	return -1;
+}
+
+/**
+ * Takes the device and creates an fsid from it by placing major in the first
+ * int and minor in the second.
+ */
+void fillfsid(dev_t dev, fsid_t * fsid)
+{
+	((unsigned int *)fsid)[0] = major(dev);
+	((unsigned int *)fsid)[1] = minor(dev);
+}
+
+int mkfsid(char *path, fsid_t * fsid)
+{
+	int err = 0;
+	char *actual_path = NULL;
+	char *options = NULL;
+	struct stat stat_struct;
+
+	memset(&stat_struct, 0, sizeof(struct stat));
+
+	err = find_union(path, &options, &actual_path, 0);
+	if (err) {
+		printf("find_union failed:\n");
+		goto out;
+	}
+	err = stat(actual_path, &stat_struct);
+	if (err) {
+		perror("Couldent stat path: ");
+		goto out;
+	}
+
+	fillfsid(stat_struct.st_dev, fsid);
+
+      out:
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
--- linux-2.6.13.1/fs/unionfs/xattr.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13.1/fs/unionfs/xattr.c	2007-07-29 03:52:04.000000000 +0200
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: xattr.c,v 1.29 2006/01/13 03:00:24 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* This is lifted from fs/xattr.c */
+void *xattr_alloc(size_t size, size_t limit)
+{
+	void *ptr;
+
+	if (size > limit)
+		return ERR_PTR(-E2BIG);
+
+	if (!size)		/* size request, no buffer is needed */
+		return NULL;
+	else if (size <= PAGE_SIZE)
+		ptr = KMALLOC((unsigned long)size, GFP_KERNEL);
+	else
+		ptr = vmalloc((unsigned long)size);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+	return ptr;
+}
+
+void xattr_free(void *ptr, size_t size)
+{
+	if (!size)		/* size request, no buffer was needed */
+		return;
+	else if (size <= PAGE_SIZE)
+		KFREE(ptr);
+	else
+		vfree(ptr);
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ * ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+ */
+ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,
+			 size_t size)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	/* Define these anyway so we don't need as much ifdef'ed code. */
+	char *encoded_name = NULL;
+	char *encoded_value = NULL;
+
+	print_entry_location();
+
+	lock_dentry(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	fist_dprint(8, "getxattr: name=\"%s\", value %lu bytes\n", name,
+		    (unsigned long)size);
+
+	if (hidden_dentry->d_inode->i_op->getxattr) {
+		encoded_name = (char *)name;
+
+		encoded_value = (char *)value;
+
+		down(&hidden_dentry->d_inode->i_sem);
+		/* lock_kernel() already done by caller. */
+		err =
+		    hidden_dentry->d_inode->i_op->getxattr(hidden_dentry,
+							   encoded_name,
+							   encoded_value, size);
+		/* unlock_kernel() will be done by caller. */
+		up(&hidden_dentry->d_inode->i_sem);
+
+	}
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+int
+unionfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		 size_t size, int flags)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	print_entry_location();
+
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	fist_dprint(8, "setxattr: name=\"%s\", value %lu bytes, flags=%x\n",
+		    name, (unsigned long)size, flags);
+
+	if (hidden_dentry->d_inode->i_op->setxattr) {
+		down(&hidden_dentry->d_inode->i_sem);
+		/* lock_kernel() already done by caller. */
+		err = hidden_dentry->d_inode->i_op->
+		    setxattr(hidden_dentry, name, value, size, flags);
+		/* unlock_kernel() will be done by caller. */
+		up(&hidden_dentry->d_inode->i_sem);
+	}
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+int unionfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_name;
+	print_entry_location();
+
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	fist_dprint(8, "removexattr: name=\"%s\"\n", name);
+
+	if (hidden_dentry->d_inode->i_op->removexattr) {
+		encoded_name = (char *)name;
+
+		down(&hidden_dentry->d_inode->i_sem);
+		/* lock_kernel() already done by caller. */
+		err =
+		    hidden_dentry->d_inode->i_op->removexattr(hidden_dentry,
+							      encoded_name);
+		/* unlock_kernel() will be done by caller. */
+		up(&hidden_dentry->d_inode->i_sem);
+	}
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_sem down
+ */
+ssize_t unionfs_listxattr(struct dentry * dentry, char *list, size_t size)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_list = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	if (hidden_dentry->d_inode->i_op->listxattr) {
+		encoded_list = list;
+		down(&hidden_dentry->d_inode->i_sem);
+		/* lock_kernel() already done by caller. */
+		err =
+		    hidden_dentry->d_inode->i_op->listxattr(hidden_dentry,
+							    encoded_list, size);
+		/* unlock_kernel() will be done by caller. */
+		up(&hidden_dentry->d_inode->i_sem);
+	}
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
