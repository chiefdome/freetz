--- man/inadyn.8	2005-09-08 08:50:00.000000000 +0200
+++ man/inadyn.8	2007-05-29 13:18:22.743253080 +0200
@@ -36,6 +36,8 @@ inadyn \- a client for open DNS servers.
 .I sec
 ] [\-\-forced_update_period
 .I sec
+] [\-\-pid_file
+.I path/name
 ] [\-\-log_file
 .I path/name
 ] [\-\-background] [\-\-verbose
@@ -140,6 +142,9 @@ should be given in seconds.
 .I \-\-log_file
 The name, including the full path, of a log file.
 .TP
+.I \-\-pid_file
+The name, including the full path, of a file which holds inadyn's process id.
+.TP
 .I \-\-background
 run in background. Output is sent to the UNIX syslog facilities 
 or to a log file, if one was specified.
--- src/dyndns.c	2007-03-12 08:07:32.000000000 +0100
+++ src/dyndns.c	2007-05-29 13:18:22.931412504 +0200
@@ -46,15 +46,15 @@ DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dyna
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infcnt, char* p_ok_string);
 
 DYNDNS_SYSTEM_INFO dns_system_table[] = 
 { 
@@ -156,77 +156,78 @@ static RC_TYPE dyn_dns_wait_for_cmd(DYN_
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {	
     DYNDNS_ORG_SPECIFIC_DATA *p_dyndns_specific = 
 		(DYNDNS_ORG_SPECIFIC_DATA*) p_sys_info->p_specific_data;
+
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-        p_self->info.dyndns_server_name.name,
-        p_self->info.dyndns_server_name.port,
-		p_self->info.dyndns_server_url,
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
 		p_dyndns_specific->p_system,
-		p_self->alias_info.names[cnt].name,
-		p_self->info.my_ip_address.name,
-		p_self->alias_info.names[cnt].name,
-        p_self->info.dyndns_server_name.name,
-		p_self->info.credentials.p_enc_usr_passwd_buffer
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].my_ip_address.name,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer
 		);
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-        p_self->info.dyndns_server_name.name,
-        p_self->info.dyndns_server_name.port,
-		p_self->info.dyndns_server_url,
-		p_self->alias_info.hashes[cnt].str,
-        p_self->info.dyndns_server_name.name);
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].hashes.str,
+		p_self->info[infcnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-        p_self->info.dyndns_server_name.name,
-        p_self->info.dyndns_server_name.port,
-		p_self->info.dyndns_server_url,		
-		p_self->alias_info.names[cnt].name,
-        p_self->info.credentials.p_enc_usr_passwd_buffer,
-		p_self->info.dyndns_server_name.name);
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer,
+		p_self->info[infcnt].dyndns_server_name.name);
 }
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int infcnt, int alcnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-        p_self->info.dyndns_server_name.name,
-        p_self->info.dyndns_server_name.port,
-		p_self->info.dyndns_server_url,		
-		p_self->alias_info.names[cnt].name,
-		p_self->info.my_ip_address.name,
-        p_self->info.credentials.p_enc_usr_passwd_buffer,
-		p_self->info.dyndns_server_name.name		
+		p_self->info[infcnt].dyndns_server_name.name,
+		p_self->info[infcnt].dyndns_server_name.port,
+		p_self->info[infcnt].dyndns_server_url,
+		p_self->info[infcnt].alias_info[alcnt].names.name,
+		p_self->info[infcnt].my_ip_address.name,
+		p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer,
+		p_self->info[infcnt].dyndns_server_name.name
 		);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, int infcnt, void *p_specific_data)
 {
     return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-        p_self->info.ip_server_name.name, p_self->info.ip_server_name.port, p_self->info.ip_server_url);
+        p_self->info[infcnt].ip_server_name.name, p_self->info[infcnt].ip_server_name.port, p_self->info[infcnt].ip_server_url);
 }
 
 /* 
 	Send req to IP server and get the response
 */
-static RC_TYPE do_ip_server_transaction(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_ip_server_transaction(DYN_DNS_CLIENT *p_self, int servernum)
 {
 	RC_TYPE rc = RC_OK;
 	HTTP_CLIENT *p_http;
 
-	p_http = &p_self->http_to_ip_server;
+	p_http = &p_self->http_to_ip_server[servernum];
 
-	rc = http_client_init(&p_self->http_to_ip_server);
+	rc = http_client_init(p_http);
 	if (rc != RC_OK)
 	{
 		return rc;
@@ -239,7 +240,8 @@ static RC_TYPE do_ip_server_transaction(
 			HTTP_TRANSACTION *p_tr = &p_self->http_tr;
 
             p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-                                                     p_self->info.p_dns_system->p_specific_data);
+				servernum,
+				p_self->info[servernum].p_dns_system->p_specific_data);
 			if (p_self->dbg.level > 2) 
 			{
 				DBG_PRINTF((LOG_DEBUG, "The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -249,14 +251,14 @@ static RC_TYPE do_ip_server_transaction(
 			p_tr->max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
 			p_tr->rsp_len = 0;
 
-			rc = http_client_transaction(&p_self->http_to_ip_server, &p_self->http_tr);		
+			rc = http_client_transaction(p_http, &p_self->http_tr);		
 			p_self->p_work_buffer[p_tr->rsp_len] = 0;
 		}
 	}
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(p_http);
 	
 	return rc;
 }
@@ -268,10 +270,10 @@ static RC_TYPE do_ip_server_transaction(
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different 
 */
-static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self, int servernum)
 {
 	int ip1 = 0, ip2 = 0, ip3 = 0, ip4 = 0;
-	int count;
+	int count, i;
 	char *p_ip;
 	char *p_current_str = p_self->http_tr.p_rsp;
 	BOOL found;
@@ -314,9 +316,14 @@ static RC_TYPE do_parse_my_ip_address(DY
 
 	if (found)
 	{        
+		i = 0;
+		do
+		{
         sprintf(new_ip_str, DYNDNS_IP_ADDR_FORMAT, ip1, ip2, ip3, ip4);
-        p_self->info.my_ip_has_changed = (strcmp(new_ip_str, p_self->info.my_ip_address.name) != 0);
-		strcpy(p_self->info.my_ip_address.name, new_ip_str);
+			p_self->info[i].my_ip_has_changed = (strcmp(new_ip_str, p_self->info[i].my_ip_address.name) != 0);
+			strcpy(p_self->info[i].my_ip_address.name, new_ip_str);
+		}
+		while(++i < p_self->info_count);
 		return RC_OK;
 	}
 	else
@@ -336,20 +343,26 @@ static RC_TYPE do_parse_my_ip_address(DY
 */
 static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
 {
-	int i;	
+	int i, j;
 
-    if (p_self->info.my_ip_has_changed ||
+	/*uses fix test if ip of server 0 has changed */
+	/*that should be ok even if changes dyn_dns_update_ip to */
+	/*iterate over servernum, but not if it's fix set to =! 0 */
+	if (p_self->info[0].my_ip_has_changed ||
         p_self->force_addr_update ||
 	(p_self->times_since_last_update > p_self->forced_update_times)
        )
     {
-        for (i = 0; i < p_self->alias_info.count; ++i)
+		for (i = 0; i < p_self->info_count; i++)
 	    {
-            p_self->alias_info.update_required[i] = TRUE;
+			for (j = 0; j < p_self->info[i].alias_count; j++)
+			{
+				p_self->info[i].alias_info[j].update_required = TRUE;
 			{
 				DBG_PRINTF((LOG_WARNING,"I:" MODULE_TAG "IP address for alias '%s' needs update to '%s'\n",
-					p_self->alias_info.names[i].name,
-					p_self->info.my_ip_address.name ));
+						p_self->info[i].alias_info[j].names.name,
+						p_self->info[i].my_ip_address.name));
+				}
 			}
         }
     }
@@ -360,7 +373,7 @@ static RC_TYPE do_check_alias_update_tab
 /* DynDNS org.specific response validator.
     'good' or 'nochange' are the good answers,
 */
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	(void) p_ok_string;
     return ( (strstr(p_rsp, DYNDNS_OK_RESPONSE) != NULL) ||
@@ -372,17 +385,17 @@ static BOOL is_dyndns_server_rsp_ok( DYN
     fail blabla and n.n.n.n
     are the good answers. We search our own IP address in response and that's enough.
 */
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	(void) p_ok_string;
-    return (strstr(p_rsp, p_self->info.my_ip_address.name) != NULL);
+    return (strstr(p_rsp, p_self->info[infnr].my_ip_address.name) != NULL);
 }
 
 /** generic http dns server ok parser 
 	parses a given string. If found is ok,
 	Example : 'SUCCESS CODE='
 */
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	if (p_ok_string == NULL)
 	{
@@ -396,7 +409,7 @@ static BOOL is_generic_server_rsp_ok( DY
 		CODE=200
 		CODE=707, for duplicated updates
 */
-BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string)
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, int infnr, char* p_ok_string)
 {
 	return 
 	(		
@@ -407,19 +420,21 @@ BOOL is_zoneedit_server_rsp_ok( DYN_DNS_
 
 static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self)
 {
-	int i;
+	int i, j;
 	RC_TYPE rc = RC_OK;
 	
 	do 
 	{			
-		for (i = 0; i < p_self->alias_info.count; ++i)
+		for (i = 0; i < p_self->info_count; i++)
 		{
-			if (p_self->alias_info.update_required[i] != TRUE)
+			for (j = 0; j < p_self->info[i].alias_count; j++)
+		{
+				if (p_self->info[i].alias_info[j].update_required != TRUE)
 			{
 				continue;
 			}	
 			
-			rc = http_client_init(&p_self->http_to_dyndns);
+				rc = http_client_init(&p_self->http_to_dyndns[i]);
 			if (rc != RC_OK)
 			{
 				break;
@@ -428,9 +443,9 @@ static RC_TYPE do_update_alias_table(DYN
 			/*build dyndns transaction*/
 			{
 				HTTP_TRANSACTION http_tr;
-				http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-                        (struct _DYN_DNS_CLIENT*) p_self,i,
-						(struct DYNDNS_SYSTEM*) p_self->info.p_dns_system);
+					http_tr.req_len = p_self->info[i].p_dns_system->p_dns_update_req_func(
+						(struct _DYN_DNS_CLIENT*) p_self, i, j,
+						(struct DYNDNS_SYSTEM*) p_self->info[i].p_dns_system);
 				http_tr.p_req = (char*) p_self->p_req_buffer;
 				http_tr.p_rsp = (char*) p_self->p_work_buffer;
 				http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
@@ -438,7 +453,7 @@ static RC_TYPE do_update_alias_table(DYN
 				p_self->p_work_buffer[http_tr.rsp_len+1] = 0;
 				
 				/*send it*/
-				rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);					
+					rc = http_client_transaction(&p_self->http_to_dyndns[i], &http_tr);					
 
 				if (p_self->dbg.level > 2)
 				{
@@ -449,18 +464,18 @@ static RC_TYPE do_update_alias_table(DYN
 				if (rc == RC_OK)
 				{
 					BOOL update_ok = 
-                        p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self, 
+							p_self->info[i].p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self, 
                             http_tr.p_rsp, 
-							p_self->info.p_dns_system->p_success_string);
+							i,
+							p_self->info[i].p_dns_system->p_success_string);
 					if (update_ok)
 					{
-			                        p_self->alias_info.update_required[i] = FALSE;
+							p_self->info[i].alias_info[j].update_required = FALSE;
 
 						DBG_PRINTF((LOG_WARNING,"I:" MODULE_TAG "Alias '%s' to IP '%s' updated successful.\n", 
-							p_self->alias_info.names[i].name,
-							p_self->info.my_ip_address.name));                        
+								p_self->info[i].alias_info[j].names.name,
+								p_self->info[i].my_ip_address.name));                        
 						p_self->times_since_last_update = 0;
-							
 					}
 					else
 					{
@@ -476,7 +491,7 @@ static RC_TYPE do_update_alias_table(DYN
 			}
 			
 			{
-				RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns[i]);
 				if (rc == RC_OK)
 				{
 					rc = rc2;
@@ -488,6 +503,7 @@ static RC_TYPE do_update_alias_table(DYN
 			}
 			os_sleep_ms(1000);
 		}
+		}
 		if (rc != RC_OK)
 		{
 			break;
@@ -504,8 +520,8 @@ RC_TYPE get_default_config_data(DYN_DNS_
 
 	do
 	{
-        p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);	
-        if (p_self->info.p_dns_system == NULL)
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);	
+		if (p_self->info[0].p_dns_system == NULL)
         {
             rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
             break;
@@ -527,13 +543,15 @@ static RC_TYPE get_encoded_user_passwd(D
 	RC_TYPE rc = RC_OK;
 	const char* format = "%s:%s";
 	char *p_tmp_buff = NULL;
-	int size = strlen(p_self->info.credentials.my_password) + 
-			   strlen(p_self->info.credentials.my_username) + 
-			   strlen(format) + 1;
-	int actual_len;
+	int size, actual_len;
+	int i = 0;
 
 	do
 	{
+		size = strlen(p_self->info[i].credentials.my_password) + 
+			strlen(p_self->info[i].credentials.my_username) + 
+			strlen(format) + 1;
+
 		p_tmp_buff = (char *) malloc(size);
 		if (p_tmp_buff == NULL)
 		{
@@ -542,8 +560,8 @@ static RC_TYPE get_encoded_user_passwd(D
 		}
 
 		actual_len = sprintf(p_tmp_buff, format, 
-				p_self->info.credentials.my_username, 
-				p_self->info.credentials.my_password);
+				p_self->info[i].credentials.my_username, 
+				p_self->info[i].credentials.my_password);
 		if (actual_len >= size)
 		{
 			rc = RC_OUT_BUFFER_OVERFLOW;
@@ -551,16 +569,23 @@ static RC_TYPE get_encoded_user_passwd(D
 		}
 
 		/*encode*/
-		p_self->info.credentials.p_enc_usr_passwd_buffer = b64encode(p_tmp_buff);	
-		p_self->info.credentials.encoded = 
-			(p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer = b64encode(p_tmp_buff);	
+		p_self->info[i].credentials.encoded = 
+			(p_self->info[i].credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[i].credentials.size = strlen(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+
+		if (p_tmp_buff != NULL)
+		{
+			free(p_tmp_buff);
+			p_tmp_buff = NULL;
 	}
-	while(0);
+	}
+	while(++i < p_self->info_count);
 
 	if (p_tmp_buff != NULL)
 	{
 		free(p_tmp_buff);
+		p_tmp_buff = NULL;
 	}
 	return rc;	
 }
@@ -585,6 +610,7 @@ RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT
 	DYN_DNS_CLIENT *p_self;
     BOOL http_to_dyndns_constructed = FALSE;
     BOOL http_to_ip_constructed = FALSE;
+	int i;
 
 	if (pp_self == NULL)
 	{
@@ -620,21 +646,28 @@ RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT
 			break;
 		}
 		
-        
-		rc = http_client_construct(&p_self->http_to_ip_server);
+		i = 0;		
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			rc = http_client_construct(&p_self->http_to_ip_server[i++]);
 		if (rc != RC_OK)
 		{	
 			rc = RC_OUT_OF_MEMORY;
 			break;
 		}
+		}
         http_to_ip_constructed = TRUE;
 	
-		rc = http_client_construct(&p_self->http_to_dyndns);
+		i = 0;
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			rc = http_client_construct(&p_self->http_to_dyndns[i++]);
 		if (rc != RC_OK)
 		{		
 			rc = RC_OUT_OF_MEMORY;
 			break;
 		}
+		}
         http_to_dyndns_constructed = TRUE;
 	
 		(p_self)->cmd = NO_CMD;
@@ -642,8 +675,11 @@ RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;	
 		(p_self)->initialized = FALSE;
 	
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
+		i = 0;		
+		while(i < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			p_self->info[i++].credentials.p_enc_usr_passwd_buffer = NULL;
+		}
 	}
 	while(0);
 
@@ -663,11 +699,11 @@ RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT
         }
         if (http_to_dyndns_constructed) 
         {
-            http_client_destruct(&p_self->http_to_dyndns);
+			http_client_destruct(p_self->http_to_dyndns, DYNDNS_MAX_SERVER_NUMBER);
         }
         if (http_to_ip_constructed) 
         {
-            http_client_destruct(&p_self->http_to_ip_server);
+			http_client_destruct(p_self->http_to_ip_server, DYNDNS_MAX_SERVER_NUMBER);
         }            
     }
 
@@ -680,6 +716,7 @@ RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
+	int i;
 	RC_TYPE rc;
 	if (p_self == NULL)
 	{
@@ -691,13 +728,13 @@ RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT 
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
+	rc = http_client_destruct(p_self->http_to_ip_server, DYNDNS_MAX_SERVER_NUMBER);
 	if (rc != RC_OK)
 	{		
 		
 	}
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
+	rc = http_client_destruct(p_self->http_to_dyndns, DYNDNS_MAX_SERVER_NUMBER);
 	if (rc != RC_OK)
 	{	
 		
@@ -715,13 +752,17 @@ RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT 
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
+	i = 0;		
+	while(i < DYNDNS_MAX_SERVER_NUMBER)
+	{
+		if (p_self->info[i].credentials.p_enc_usr_passwd_buffer != NULL)
 	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
+			free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
+		}
+		i++;
 	}
 
-
 	free(p_self);
 	p_self = NULL;
 
@@ -736,6 +777,8 @@ RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT 
 */
 RC_TYPE dyn_dns_init(DYN_DNS_CLIENT *p_self)
 {
+	int i = 0;
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
@@ -749,22 +792,26 @@ RC_TYPE dyn_dns_init(DYN_DNS_CLIENT *p_s
 	p_self->abort_on_network_errors = FALSE;
 	p_self->force_addr_update = FALSE;
 
-    if (strlen(p_self->info.proxy_server_name.name) > 0)
+	do
     {
-        http_client_set_port(&p_self->http_to_ip_server, p_self->info.proxy_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_ip_server, p_self->info.proxy_server_name.name);
+		if (strlen(p_self->info[i].proxy_server_name.name) > 0)
+		{
+			http_client_set_port(&p_self->http_to_ip_server[i], p_self->info[i].proxy_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_ip_server[i], p_self->info[i].proxy_server_name.name);
 
-        http_client_set_port(&p_self->http_to_dyndns, p_self->info.proxy_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_dyndns, p_self->info.proxy_server_name.name);
+			http_client_set_port(&p_self->http_to_dyndns[i], p_self->info[i].proxy_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_dyndns[i], p_self->info[i].proxy_server_name.name);
     }
     else
     {
-        http_client_set_port(&p_self->http_to_ip_server, p_self->info.ip_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_ip_server, p_self->info.ip_server_name.name);
+			http_client_set_port(&p_self->http_to_ip_server[i], p_self->info[i].ip_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_ip_server[i], p_self->info[i].ip_server_name.name);
 
-        http_client_set_port(&p_self->http_to_dyndns, p_self->info.dyndns_server_name.port);
-        http_client_set_remote_name(&p_self->http_to_dyndns, p_self->info.dyndns_server_name.name);    
+			http_client_set_port(&p_self->http_to_dyndns[i], p_self->info[i].dyndns_server_name.port);
+			http_client_set_remote_name(&p_self->http_to_dyndns[i], p_self->info[i].dyndns_server_name.name);    
+		}
     }
+	while(++i < p_self->info_count);
 
 	p_self->cmd = NO_CMD;
     if (p_self->cmd_check_period == 0)
@@ -807,6 +854,8 @@ RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT 
 */
 RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
 {
+	int servernum = 0; /* server to use for requesting IP */
+                     /*use server 0 by default, should be always exist */
 	RC_TYPE rc;
 
 	if (p_self == NULL)
@@ -817,7 +866,7 @@ RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT
 	do
 	{
 		/*ask IP server something so he will respond and give me my IP */
-		rc = do_ip_server_transaction(p_self);
+		rc = do_ip_server_transaction(p_self, servernum);
 		if (rc != RC_OK)
 		{
 			DBG_PRINTF((LOG_WARNING,"W: DYNDNS: Error '%s' (0x%x) when talking to IP server\n",
@@ -830,7 +879,7 @@ RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT
 		}
 
 		/*extract my IP, check if different than previous one*/
-		rc = do_parse_my_ip_address(p_self);
+		rc = do_parse_my_ip_address(p_self, servernum);
 		if (rc != RC_OK)
 		{	
 			break;
@@ -838,7 +887,7 @@ RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT
 		
 		if (p_self->dbg.level > 1)
 		{
-			DBG_PRINTF((LOG_WARNING,"W: DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name));		
+			DBG_PRINTF((LOG_WARNING,"W: DYNDNS: My IP address: %s\n", p_self->info[servernum].my_ip_address.name));		
 		}
 
 		/*step through aliases list, resolve them and check if they point to my IP*/
@@ -909,19 +958,6 @@ int dyn_dns_main(DYN_DNS_CLIENT *p_dyndn
         }
 	}
 
-	if (p_dyndns->change_persona)
-	{
-		OS_USER_INFO os_usr_info;
-		memset(&os_usr_info, 0, sizeof(os_usr_info));
-		os_usr_info.gid = p_dyndns->sys_usr_info.gid;
-		os_usr_info.uid = p_dyndns->sys_usr_info.uid;
-		rc = os_change_persona(&os_usr_info);
-		if (rc != RC_OK)
-		{
-			return rc;
-		}
-	}
-
     /*if silent required, close console window*/
     if (p_dyndns->run_in_background == TRUE)
     {
@@ -936,6 +972,39 @@ int dyn_dns_main(DYN_DNS_CLIENT *p_dyndn
         }
     }
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename && strlen(p_dyndns->p_pidfilename) != 0)
+	{
+		FILE *fp;
+		int obj;
+		char pid[7];
+		if ((fp = fopen(p_dyndns->p_pidfilename, "w")))
+		{
+			sprintf(pid, "%d\n", getpid());
+			obj = fwrite(pid, strlen(pid), 1, fp);
+			fclose(fp);
+		}
+		free(p_dyndns->p_pidfilename);
+		p_dyndns->p_pidfilename = NULL;
+		if (!fp || obj != 1)
+		{
+			return RC_FILE_IO_OPEN_ERROR;
+		}
+	}
+
+	if (p_dyndns->change_persona)
+	{
+		OS_USER_INFO os_usr_info;
+		memset(&os_usr_info, 0, sizeof(os_usr_info));
+		os_usr_info.gid = p_dyndns->sys_usr_info.gid;
+		os_usr_info.uid = p_dyndns->sys_usr_info.uid;
+		rc = os_change_persona(&os_usr_info);
+		if (rc != RC_OK)
+		{
+			return rc;
+		}
+	}
+
     dyn_dns_print_hello(NULL);
 
 	/* the real work here */
--- src/dyndns.h	2007-03-12 08:04:28.000000000 +0100
+++ src/dyndns.h	2007-05-29 13:18:22.940420136 +0200
@@ -25,7 +25,7 @@ Foundation, Inc., 59 Temple Place - Suit
 #include "http_client.h"
 #include "debug_if.h"
 
-#define DYNDNS_VERSION_STRING  "1.96.2"
+#define DYNDNS_VERSION_STRING  "1.96.2 with multi services- & pid-patch"
 #define DYNDNS_AGENT_NAME  "inadyn/" DYNDNS_VERSION_STRING
 #define DYNDNS_EMAIL_ADDR	"inarcis2002@hotpop.com"
 
@@ -133,7 +133,8 @@ typedef enum
 #define DYNDNS_DEFAULT_ITERATIONS	0 /*forever*/
 #define DYNDNS_HTTP_RESPONSE_BUFFER_SIZE	(2500) /*Bytes*/
 #define DYNDNS_HTTP_REQUEST_BUFFER_SIZE		(2500) /*Bytes*/
-#define DYNDNS_MAX_ALIAS_NUMBER		10 /*maximum number of aliases that can be maintained*/
+#define DYNDNS_MAX_ALIAS_NUMBER		10 /*maximum number of aliases per server that can be maintained*/
+#define DYNDNS_MAX_SERVER_NUMBER	5 /*maximum number of servers that can be maintained*/
 
 /*local configs*/
 #define DYNDNS_MY_IP_ADDRESS_LENGTH	20 /*chars*/
@@ -154,8 +155,8 @@ struct DYNDNS_SYSTEM;
 /** Function to prepare DNS system specific server requests 
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, int infnr, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int infnr, int alnr, struct DYNDNS_SYSTEM *p_sys_info);
 typedef struct 
 {
     const char* p_key;
@@ -209,6 +210,13 @@ typedef struct 
 
 typedef struct 
 {
+	DYNDNS_SERVER_NAME names;
+	int update_required;
+	DYNDNS_HASH_TYPE hashes; 
+} DYNDNS_ALIAS_INFO;
+
+typedef struct 
+{
     BOOL my_ip_has_changed;
 	DYNDNS_SERVER_NAME my_ip_address;
 	DYNDNS_CREDENTIALS credentials;
@@ -218,18 +226,12 @@ typedef struct 
 	DYNDNS_SERVER_NAME ip_server_name;
 	char ip_server_url[DYNDNS_SERVER_URL_LENGTH];
 	DYNDNS_SERVER_NAME proxy_server_name;
+	DYNDNS_ALIAS_INFO alias_info[DYNDNS_MAX_ALIAS_NUMBER];
+	int alias_count;
 } DYNDNS_INFO_TYPE;
 
 typedef struct 
 {
-	DYNDNS_SERVER_NAME names[DYNDNS_MAX_ALIAS_NUMBER];
-	int update_required[DYNDNS_MAX_ALIAS_NUMBER];
-	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER]; 
-	int count;
-} DYNDNS_ALIAS_INFO;
-
-typedef struct
-{
 	int uid;
 	int gid;
 } USER_INFO;
@@ -248,8 +250,8 @@ typedef struct DYN_DNS_CLIENT
 	BOOL debug_to_syslog;
 	BOOL change_persona;
 
-	HTTP_CLIENT http_to_ip_server;
-	HTTP_CLIENT http_to_dyndns;
+	HTTP_CLIENT http_to_ip_server[DYNDNS_MAX_SERVER_NUMBER];
+	HTTP_CLIENT http_to_dyndns[DYNDNS_MAX_SERVER_NUMBER];
 	HTTP_TRANSACTION http_tr;
 	char *p_work_buffer; /* for HTTP responses*/
 	int work_buffer_size;
@@ -258,14 +260,15 @@ typedef struct DYN_DNS_CLIENT
 
 
 	USER_INFO sys_usr_info; /*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE info; /*servers, names, passwd*/
-	DYNDNS_ALIAS_INFO alias_info;
+	DYNDNS_INFO_TYPE info[DYNDNS_MAX_SERVER_NUMBER]; /*servers, names, passwd*/
+	int info_count;
 
 	BOOL abort_on_network_errors;
 	BOOL force_addr_update;
     BOOL use_proxy;
 	BOOL abort;
 
+	char *p_pidfilename;
 	/*dbg*/
 	DBG_TYPE dbg;
 } DYN_DNS_CLIENT;
--- src/http_client.c	2004-10-15 18:37:00.000000000 +0200
+++ src/http_client.c	2007-05-29 13:18:22.946425224 +0200
@@ -56,10 +56,16 @@ RC_TYPE http_client_construct(HTTP_CLIEN
 /*
 	Resource free.
 */	
-RC_TYPE http_client_destruct(HTTP_CLIENT *p_self)
+RC_TYPE http_client_destruct(HTTP_CLIENT *p_self, int num)
 {
+	int i = 0, rv;
+
 	/*free*/
-	return super_destruct(&p_self->super);
+	while(i < num)
+	{
+		rv = super_destruct(&p_self[i++].super);
+	}
+	return rv;
 }
 
 
--- src/http_client.h	2004-06-03 00:04:00.000000000 +0200
+++ src/http_client.h	2007-05-29 13:18:22.952430312 +0200
@@ -61,7 +61,7 @@ RC_TYPE http_client_construct(HTTP_CLIEN
 /*
 	Resource free.
 */	
-RC_TYPE http_client_destruct(HTTP_CLIENT *p_self);
+RC_TYPE http_client_destruct(HTTP_CLIENT *p_self, int num);
 
 /* 
 	Sets up the object.
--- src/inadyn_cmd.c	2005-09-09 23:17:30.000000000 +0200
+++ src/inadyn_cmd.c	2007-05-29 13:18:22.969444728 +0200
@@ -39,6 +39,8 @@ Foundation, Inc., 59 Temple Place - Suit
 #include "base64.h"
 #include "get_cmd.h"
 
+static int curr_info;
+
 /* command line options */
 #define DYNDNS_INPUT_FILE_OPT_STRING "--input_file"
 
@@ -54,6 +56,7 @@ static RC_TYPE get_update_period_handler
 static RC_TYPE get_update_period_sec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -113,6 +116,7 @@ static CMD_DESCRIPTION_TYPE cmd_options_
 	{"--forced_update_period", 1,   {get_forced_update_period_handler, NULL},"how often the IP is updated even if it is not changed. [in sec]"},
 
 	{"--log_file",	1,	{get_logfile_name, NULL},		"log file path abd name"},
+	{"--pid_file",	1,	{get_pidfile_name, NULL},		"pid file path abd name"},
 	{"--background", 0,	{set_silent_handler, NULL},		"run in background. output to log file or to syslog"},
 
 	{"--verbose",	1,	{set_verbose_handler, NULL},	"set dbg level. 0 to 5"},
@@ -211,7 +215,6 @@ static RC_TYPE set_silent_handler(CMD_DA
 	return RC_OK;
 }
 
-
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -228,6 +231,22 @@ static RC_TYPE get_logfile_name(CMD_DATA
 	return RC_OK;
 }
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *)malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 static RC_TYPE get_username_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
@@ -238,11 +257,11 @@ static RC_TYPE get_username_handler(CMD_
 	}
 
 	/*user*/
-	if (sizeof(p_self->info.credentials.my_username) < strlen(p_cmd->argv[current_nr]))
+	if (sizeof(p_self->info[curr_info].credentials.my_username) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[curr_info].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -255,13 +274,13 @@ static RC_TYPE get_password_handler(CMD_
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.credentials.my_password) < strlen(p_cmd->argv[current_nr]))
+	/*password*/
+	if (sizeof(p_self->info[curr_info].credentials.my_password) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
 
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	strcpy(p_self->info[curr_info].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -282,7 +301,7 @@ static RC_TYPE get_alias_handler(CMD_DAT
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count >= DYNDNS_MAX_ALIAS_NUMBER)
+	if (p_self->info[curr_info].alias_count >= DYNDNS_MAX_ALIAS_NUMBER)
 	{
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -291,23 +310,23 @@ static RC_TYPE get_alias_handler(CMD_DAT
         p_hash = strstr(p_cmd->argv[current_nr],",");
         if (p_hash)
 	{
-	    if (sizeof(*p_self->alias_info.hashes) < strlen(p_hash))
+	    if (sizeof(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].hashes) < strlen(p_hash))
 	    {
 		return RC_DYNDNS_BUFFER_TOO_SMALL;
 	    }
-	    strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str, p_hash);
+	    strcpy(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].hashes.str, p_hash);
 	    *p_hash = '\0';
 	}
 
 
 	/*user*/
-	if (sizeof(p_self->alias_info.names[p_self->alias_info.count]) < strlen(p_cmd->argv[current_nr]))
+	if (sizeof(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].name, (p_cmd->argv[current_nr]));
+	strcpy(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names.name, (p_cmd->argv[current_nr]));
 
-	p_self->alias_info.count ++;
+	p_self->info[curr_info].alias_count++;
 	return RC_OK;
 }
 
@@ -349,24 +368,24 @@ static RC_TYPE get_ip_server_name_handle
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.ip_server_name) < strlen(p_cmd->argv[current_nr]) + 1)
+	/*ip_server_name*/
+	if (sizeof(p_self->info[curr_info].ip_server_name) < strlen(p_cmd->argv[current_nr]) + 1)
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
 
-    p_self->info.ip_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.ip_server_name.name, &port);
+    p_self->info[curr_info].ip_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].ip_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.ip_server_name.port = port;
+        p_self->info[curr_info].ip_server_name.port = port;
     }        
 
-	if (sizeof(p_self->info.ip_server_url) < strlen(p_cmd->argv[current_nr + 1]) + 1)
+	if (sizeof(p_self->info[curr_info].ip_server_url) < strlen(p_cmd->argv[current_nr + 1]) + 1)
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.ip_server_url, p_cmd->argv[current_nr + 1]);
+	strcpy(p_self->info[curr_info].ip_server_url, p_cmd->argv[current_nr + 1]);
 
 	return rc;
 }
@@ -382,17 +401,17 @@ static RC_TYPE get_dns_server_name_handl
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.dyndns_server_name) < strlen(p_cmd->argv[current_nr]))
+	/*dyndns_server_name*/
+	if (sizeof(p_self->info[curr_info].dyndns_server_name) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.dyndns_server_name.name, &port);
+    p_self->info[curr_info].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].dyndns_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.dyndns_server_name.port = port;
+        p_self->info[curr_info].dyndns_server_name.port = port;
     }                                   
 	return rc;
 }
@@ -405,12 +424,12 @@ RC_TYPE get_dns_server_url_handler(CMD_D
 		return RC_INVALID_POINTER;
 	}
 
-	/*name*/
-	if (sizeof(p_self->info.dyndns_server_url) < strlen(p_cmd->argv[current_nr]))
+	/*dyndns_server_url*/
+	if (sizeof(p_self->info[curr_info].dyndns_server_url) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[curr_info].dyndns_server_url, p_cmd->argv[current_nr]);
 	return RC_OK;
 }
 
@@ -427,17 +446,17 @@ static RC_TYPE get_proxy_server_handler(
 		return RC_INVALID_POINTER;
 	}
 
-	/*user*/
-	if (sizeof(p_self->info.proxy_server_name) < strlen(p_cmd->argv[current_nr]))
+	/*proxy_server_name*/
+	if (sizeof(p_self->info[curr_info].proxy_server_name) < strlen(p_cmd->argv[current_nr]))
 	{
 		return  RC_DYNDNS_BUFFER_TOO_SMALL;
 	}
     
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info.proxy_server_name.name, &port);
+    p_self->info[curr_info].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], p_self->info[curr_info].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[curr_info].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -571,6 +590,7 @@ static RC_TYPE get_dyndns_system_handler
 {
     DYNDNS_SYSTEM *p_dns_system = NULL;
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
@@ -592,7 +612,21 @@ static RC_TYPE get_dyndns_system_handler
         return RC_DYNDNS_INVALID_OPTION;
     }
 
-    p_self->info.p_dns_system = p_dns_system;
+	for (curr_info = 0; curr_info < p_self->info_count &&
+	     curr_info < DYNDNS_MAX_SERVER_NUMBER &&
+	     p_self->info[curr_info].p_dns_system != p_dns_system; curr_info++)
+	{
+	}
+	if (curr_info >= p_self->info_count)
+	{
+		if (curr_info < DYNDNS_MAX_SERVER_NUMBER)
+		{
+			p_self->info_count++;
+			p_self->info[curr_info].p_dns_system = p_dns_system;
+		}
+	   	else
+			return RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
 	
 	return RC_OK;
 }
@@ -886,6 +920,7 @@ static RC_TYPE get_options_from_file_han
 */
 RC_TYPE get_config_data(DYN_DNS_CLIENT *p_self, int argc, char** argv)
 {
+	int i;
 	RC_TYPE rc = RC_OK;
 	
 	do
@@ -929,49 +964,53 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 		}	
 
         /*settings that may change due to cmd line options*/
+	i = 0;
+	do
         {
     		/*ip server*/
-            if (strlen(p_self->info.ip_server_name.name) == 0)
+            if (strlen(p_self->info[i].ip_server_name.name) == 0)
             {
-                if (sizeof(p_self->info.ip_server_name.name) < strlen(p_self->info.p_dns_system->p_ip_server_name))
+                if (sizeof(p_self->info[i].ip_server_name.name) < strlen(p_self->info[i].p_dns_system->p_ip_server_name))
                 {
                     rc = RC_DYNDNS_BUFFER_TOO_SMALL;
                     break;
                 }
-                strcpy(p_self->info.ip_server_name.name, p_self->info.p_dns_system->p_ip_server_name);
+                strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
 
-                if (sizeof(p_self->info.ip_server_url) < strlen(p_self->info.p_dns_system->p_ip_server_url))
+                if (sizeof(p_self->info[i].ip_server_url) < strlen(p_self->info[i].p_dns_system->p_ip_server_url))
                 {
                     rc = RC_DYNDNS_BUFFER_TOO_SMALL;
                     break;
                 }
-                strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+                strcpy(p_self->info[i].ip_server_url, p_self->info[i].p_dns_system->p_ip_server_url);				
             }
             
     		/*dyndns server*/
-            if (strlen(p_self->info.dyndns_server_name.name) == 0)
+            if (strlen(p_self->info[i].dyndns_server_name.name) == 0)
             {
-        		if (sizeof(p_self->info.dyndns_server_name.name) < strlen(p_self->info.p_dns_system->p_dyndns_server_name))
+		if (sizeof(p_self->info[i].dyndns_server_name.name) < strlen(p_self->info[i].p_dns_system->p_dyndns_server_name))
         		{
         			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
         			break;
         		}
-        		strcpy(p_self->info.dyndns_server_name.name, p_self->info.p_dns_system->p_dyndns_server_name);
+		strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
 
-        		if (sizeof(p_self->info.dyndns_server_url) < strlen(p_self->info.p_dns_system->p_dyndns_server_url))
+		if (sizeof(p_self->info[i].dyndns_server_url) < strlen(p_self->info[i].p_dns_system->p_dyndns_server_url))
         		{
         			rc = RC_DYNDNS_BUFFER_TOO_SMALL;
         			break;
         		}
-        		strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+		strcpy(p_self->info[i].dyndns_server_url, p_self->info[i].p_dns_system->p_dyndns_server_url);
             }
         }
+	while(++i < p_self->info_count);
 
 		/*check if the neccessary params have been provided*/
 		if ( 
-			(strlen(p_self->info.dyndns_server_name.name) == 0)  ||
-			(strlen(p_self->info.ip_server_name.name)	  == 0)  ||
-			(p_self->alias_info.count == 0)
+			(p_self->info_count == 0) ||
+			(p_self->info[0].alias_count == 0) ||
+			(strlen(p_self->info[0].dyndns_server_name.name) == 0)  ||
+			(strlen(p_self->info[0].ip_server_name.name)	 == 0)
 			)
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
