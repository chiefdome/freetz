#!/bin/sh
# Freetz controller
CR=$'\r'

redirect() {
    cat << EOF
Status: 302 Found$CR
Location: $1$CR
$CR
EOF
    exit
}

# remove trailing slash from URL
redirect_folder() {
# violates RFC (demands absolute URL) but is supported by major browsers
    redirect "$SCRIPT_NAME${PATH_INFO%/}${QUERY_STRING:+?$QUERY_STRING}"
}

# redirect within the (virtual) URL tree
redirect_freetz() {
    redirect "$SCRIPT_NAME$1"
}

# pass control to another CGI
CGI_DIR=${SCRIPT_FILENAME%/*}/cgi-bin
dispatch() {
    local name=$1 url_prefix=$2
    export PATH_INFO=${PATH_INFO#"$url_prefix"}
    export SCRIPT_NAME="$SCRIPT_NAME$url_prefix"
    export SCRIPT_FILENAME="$CGI_DIR/$name"
    exec "$SCRIPT_FILENAME" "$@"
}

error_not_found() {
# during development
    cgi_info
}

cgi_info() {
    cat << EOF
Content-Type: text/plain$CR
$CR
REQUEST_URI=$REQUEST_URI
SCRIPT_NAME=$SCRIPT_NAME
SCRIPT_FILENAME=$SCRIPT_FILENAME
PATH_INFO=$PATH_INFO

EOF
    set | grep -v '^CONFIG_\|^MOD_'
}

case $PATH_INFO in
    /)			redirect_freetz /status ;;
    */)			redirect_folder ;;
    "")
    	case $REQUEST_METHOD in
	    POST) dispatch exec.cgi ;;
	    *) redirect_freetz /status ;;
	esac
	;;
    /status)		dispatch status.cgi /status ;;
    /status/?*)
    	cgi=${PATH_INFO#/status/}
	if [ "$cgi" = "daemons" ]; then
	    case $REQUEST_METHOD in
		POST) dispatch exec.cgi ;;
		*) dispatch daemons.cgi /status/daemons ;;
	    esac
	else
	    QUERY_STRING="cgi=$cgi${QUERY_STRING:+&$QUERY_STRING}"
	    dispatch pkgstatus.cgi /status
	fi
	;;

    /packages)		dispatch packages.cgi /packages ;;
    /packages/?*/?*)
    	dispatch extras.cgi /packages
    	;;
    /extras)
    	dispatch extras.cgi /extras # FIXME: integrate into /packages?
	;;
    /packages/?*)
	pkg=${PATH_INFO#/packages/}
    	case $REQUEST_METHOD in
	    POST)
# form=def_$pkg might override this settings because it comes last; FIXME
	    	QUERY_STRING="form=pkg_$pkg${QUERY_STRING:+&$QUERY_STRING}"
		dispatch save.cgi
	    	;;
	    *)
		QUERY_STRING="pkg=$pkg${QUERY_STRING:+&$QUERY_STRING}"
		dispatch pkgconf.cgi /packages
		;;
	esac
	;;

    /conf)
    	case $REQUEST_METHOD in
	    POST)
	    	QUERY_STRING="form=pkg_mod${QUERY_STRING:+&$QUERY_STRING}"
		dispatch save.cgi
		;;
	    *)
	    	dispatch settings.cgi /conf
		;;
	esac
	;;
    /conf/password)
    	case $REQUEST_METHOD in
	    POST) dispatch passwd_save.cgi ;;
	    *) dispatch passwd.cgi /conf/password ;;
	esac
	;;
    /conf/?*)
    	id=${PATH_INFO#/conf/}
	QUERY_STRING="id=$id${QUERY_STRING:+&$QUERY_STRING}"
	case $REQUEST_METHOD in
	    POST) dispatch file_save.cgi ;;
	    *) dispatch file.cgi "$PATH_INFO" ;;
	esac
	;;

    /shell)		dispatch rudi_shell.cgi ;;
# /shell/exec is not only target of POST requests; that's why we cannot simply
# POST to /shell
    /shell/exec)	dispatch rudi_shellcmd.cgi ;;
    /shell/upload)	dispatch rudi_upload.cgi ;;
    /backup)
    	case $REQUEST_METHOD in
	    POST) dispatch do_restore.cgi ;;
	    *) dispatch backup_restore.cgi ;;
	esac
	;;
    /backup/download)	dispatch do_backup.cgi ;;
    /about)		dispatch about.cgi ;;
    /update)
    	case $REQUEST_METHOD in
	    POST) dispatch do_update.cgi ;;
	    *)
		QUERY_STRING="cmd=firmware_update"
		dispatch exec.cgi
		;;
	esac
	;;
    /update/external)
    	case $REQUEST_METHOD in
	    POST) dispatch do_external.cgi ;;
	    *)
		QUERY_STRING="cmd=external_update"
		dispatch exec.cgi
		;;
	esac
    	;;

    *)			error_not_found ;;
esac
