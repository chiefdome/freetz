diff -ur inadyn-mt.v.02.24.36/man/inadyn.8 inadyn-mt.v.02.24.36-pid-new/man/inadyn.8
--- man/inadyn.8	2011-03-31 17:18:47.000000000 -0400
+++ man/inadyn.8	2011-04-02 17:03:08.395703039 -0400
@@ -142,6 +142,9 @@
 myip.dk /, dhis.org /, among others.  And, of course, dynamic dns server should be
 set to one that supports IPv6.
 .TP
+.I \-\-ip_server_name_global[:port] url
+The client IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers.
+.TP
 .I \-\-dyndns_server_name[:port]
 The server that receives the update DNS requests. When no proxy is specified it is sufficient to set the
 dyndns_system so that the default servers will be taken. The option is useful for generic DynDNS services that support HTTP update.
@@ -160,6 +163,8 @@
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
 Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+
+Multiple servers are allowed. Server related parameters are applied to the most recent dyndns_system option parameter appearing on the command line (a given system may appear more than once). Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port; host alias names.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
@@ -183,6 +188,9 @@
 .I \-\-log_file
 The name, including the full path, of a log file.
 .TP
+.I \-\-pid_file
+The name, including the full path, of a pid file.
+.TP
 .I \-\-cache_dir
 Directory to which ip, and time update files are written.  Defaults to /tmp on **NIX systems.
 .TP
diff -ur inadyn-mt.v.02.24.36/man/inadyn-mt.8 inadyn-mt.v.02.24.36-pid-new/man/inadyn-mt.8
--- man/inadyn-mt.8	2011-03-31 17:18:47.000000000 -0400
+++ man/inadyn-mt.8	2011-04-02 17:03:08.409702477 -0400
@@ -142,6 +142,9 @@
 myip.dk /, dhis.org /, among others.  And, of course, dynamic dns server should be
 set to one that supports IPv6.
 .TP
+.I \-\-ip_server_name_global[:port] url
+The client IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers.
+.TP
 .I \-\-dyndns_server_name[:port]
 The server that receives the update DNS requests. When no proxy is specified it is sufficient to set the
 dyndns_system so that the default servers will be taken. The option is useful for generic DynDNS services that support HTTP update.
@@ -160,6 +163,8 @@
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
 Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+
+Multiple servers are allowed. Server related parameters are applied to the most recent dyndns_system option parameter appearing on the command line (a given system may appear more than once). Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port; host alias names.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
@@ -183,6 +188,9 @@
 .I \-\-log_file
 The name, including the full path, of a log file.
 .TP
+.I \-\-pid_file
+The name, including the full path, of a pid file.
+.TP
 .I \-\-cache_dir
 Directory to which ip, and time update files are written.  Defaults to /tmp on **NIX systems.
 .TP
diff -ur inadyn-mt.v.02.24.36/readme.html inadyn-mt.v.02.24.36-pid-new/readme.html
--- readme.html	2011-03-31 17:18:47.000000000 -0400
+++ readme.html	2011-04-06 02:37:02.216971556 -0400
@@ -6,7 +6,7 @@
 <body>
 <p><b>inadyn-mt - Simple DYNAMIC DNS client.<br>
 </b></p>
-<p><b>Version 02.24.36, March 2011<br>
+<p><b>Version 02.24.36-ms_pid_02_patch, April 2011<br>
 </b></p>
 <p><b>INADYN Advanced Help<br>
 </b></p>
@@ -299,6 +299,9 @@
 information.<br>
 </p>
 
+<p style="margin-left: 20px;">'--ip_server_name_global &#60;name&#62;[:port] &#60;url&#62;': The client
+IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but 
+overrides unchanged dyndns_system default ip servers.<br>
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_name &#60;name&#62;[:port]': dynamic dns server name, and optional port.</name>
 </p>
@@ -324,7 +327,11 @@
 -For majimoto.net:  default@majimoto.net<br>
 -For zerigo.com:  default@zerigo.com<br>
 -For generic DNS system: custom@http_svr_basic_auth<br>
-DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br>
+DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br><br>
+
+Multiple servers are allowed.  Server related parameters are applied to the most recent dyndns_system option parameter appearing
+on the command line (a given system may appear more than once).  Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port;  
+host alias names.<br>
 </p>
 
 <p style="margin-left: 20px;">
@@ -333,6 +340,7 @@
 '--update_period_sec &#60;#&#62;': how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days<br>
 '--forced_update_period &#60;#&#62;': how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days.<br>
 '--log_file &#60;path/file&#62;': log file path and name<br>
+'--pid_file &#60;path/file&#62;': pid file path and name<br>
 '--background': runs in background.&nbsp; Output to syslog or to log file [if specified].<br>
 '--verbose &#60;#&#62;': set dbg level. 0 to 5<br>
 '--iterations &#60;#&#62;': set the number of DNS updates. Default is 0, which means infinity.<br>
@@ -482,6 +490,21 @@
 <br>
 </b>
 
+Ver.&nbsp; inadyn-mt 2.24.36-ms_pid_patch_02 - April 2011<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related variable inits<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.36-ms_pid_patch_01 - April 2011<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - unicode pid file name and path<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related snprintf return check<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.36-ms_pid_patch - April 2011<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - multiple update servers, single program instance<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added defaults override option, ip_server_name_global<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added pid file name and path option, pid_file<br><br>
+
 Ver.&nbsp; inadyn-mt 2.24.36 - March 2011<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - fix debug output out of bounds array index bug<br>
diff -ur inadyn-mt.v.02.24.36/src/dyndns.c inadyn-mt.v.02.24.36-pid-new/src/dyndns.c
--- src/dyndns.c	2011-03-31 17:18:47.000000000 -0400
+++ src/dyndns.c	2011-04-06 02:36:54.204828488 -0400
@@ -143,7 +143,9 @@
 static volatile	BOOL		global_is_online=true;
 static volatile BOOL		is_online_thread_exit=false;
 static volatile BOOL		is_alert_thread_exit=false;
-static volatile BOOL		is_update_pending=false;
+static volatile BOOL		is_global_update_pending=false;
+static volatile BOOL		is_global_in_proc_update_pending=false;
+static volatile BOOL		is_global_success_updates=false;
 
 #ifdef USE_THREADS
 
@@ -185,7 +187,7 @@
 int is_exit_requested_void(void *p_self);
 int do_is_dyndns_online(DYN_DNS_CLIENT *p_self);
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns);
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i);
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt);
 
 #ifdef USE_SNDFILE
 #ifdef USE_THREADS
@@ -215,17 +217,17 @@
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this,char srv_cnt, int nr, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
 
 static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
 static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
@@ -474,7 +476,7 @@
 	DYN_DNS_CMD	old_cmd;
 
 
-	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_update_pending,p_self);
+	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_global_update_pending,p_self);
 
 	if (old_cmd != NO_CMD)
 	{
@@ -514,7 +516,7 @@
 
 		if (!(p_self->forced_update_counter)) {
 
-			if (!(is_update_pending && !(p_self->retry_pending_off))) {
+			if (!(is_global_update_pending && !(p_self->retry_pending_off))) {
 
 				/*
 					If not retrying pendings, forced update retries fallback to update_period.
@@ -528,9 +530,9 @@
 					turned off.
 				*/
 
-				if (!(is_update_pending) || !(p_self->is_forced_update_attempted)) {
+				if (!(is_global_update_pending) || !(p_self->is_forced_update_attempted)) {
 
-					if (!(p_self->is_bad_config)) {
+					if (!(p_self->is_global_bad_config)) {
 
 						DBG_PRINTF((LOG_INFO,"I:DYNDNS: Command loop breaking for forced update...\n"));
 
@@ -568,7 +570,7 @@
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,DYNDNS_SYSTEM *p_sys_info)
 {
 
 	int bytes_stored=0;
@@ -581,64 +583,64 @@
 
 
 	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	                     p_self->info.dyndns_server_url,
+	                     p_self->info[srv_cnt].dyndns_server_name.url,
 	                     p_dyndns_specific->p_system,
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.my_ip_address.name[ip_store],
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->i_face.my_ip_address.name[ip_store],
 	                     p_self->wildcard ? "ON" : "OFF",
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.dyndns_server_name.name[ip_store],
-	                     p_self->info.credentials.p_enc_usr_passwd_buffer);
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].dyndns_server_name.name,
+	                     p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.hashes[cnt].str,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.hashes[cnt].str,
+				   p_self->i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->i_face.my_ip_address.name[ip_store],
 	               p_self->wildcard ? "ON" : "OFF",
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
@@ -649,28 +651,28 @@
 	}
 
 	return sprintf(p_self->p_req_buffer, GENERIC_TZO_AUTH_MY_IP_REQUEST_FORMAT,
-		       p_self->info.dyndns_server_url,
-		       p_self->alias_info.names[cnt].name,
-		       p_self->info.credentials.my_username,
-		       p_self->info.credentials.my_password,
-		       p_self->info.my_ip_address.name[ip_store],
-		       p_self->info.dyndns_server_name.name[ip_store]);
+		       p_self->info[srv_cnt].dyndns_server_name.url,
+		       p_self->info[srv_cnt].alias_info.names[cnt].name,
+		       p_self->info[srv_cnt].credentials.my_username,
+		       p_self->info[srv_cnt].credentials.my_password,
+		       p_self->i_face.my_ip_address.name[ip_store],
+		       p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->info.credentials.my_username,
-	               p_self->info.credentials.my_password,
-	               p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].credentials.my_username,
+	               p_self->info[srv_cnt].credentials.my_password,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	unsigned char digestbuf[MD5_DIGEST_BYTES];
 	char digeststr[MD5_DIGEST_BYTES*2+1];
@@ -689,116 +691,116 @@
 		return 0;
 	}
 
-	md5_buffer(p_self->info.credentials.my_password,
-		   strlen(p_self->info.credentials.my_password), digestbuf);
+	md5_buffer(p_self->info[srv_cnt].credentials.my_password,
+		   strlen(p_self->info[srv_cnt].credentials.my_password), digestbuf);
 
 	for (i = 0; i < MD5_DIGEST_BYTES; i++)
 		sprintf(&digeststr[i*2], "%02x", digestbuf[i]);
 
 	return sprintf(p_self->p_req_buffer, HE_IPV6TB_UPDATE_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->info.my_ip_address.name[ip_store],
-				p_self->info.credentials.my_username,
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->i_face.my_ip_address.name[ip_store],
+				p_self->info[srv_cnt].credentials.my_username,
 				digeststr,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.dyndns_server_name.name[ip_store]);
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, DHIS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.credentials.my_password,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].credentials.my_password,
+				   p_self->i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self,char srv_cnt, void *p_specific_data)
 {
 	(void)p_specific_data;
 
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-	               p_self->info.ip_server_name.name[ip_store], p_self->info.ip_server_url);
+	               p_self->info[srv_cnt].ip_server_name.name, p_self->info[srv_cnt].ip_server_name.url);
 }
 
 RC_TYPE dyn_dns_set_online_check_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[0].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[0].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[0].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info_online_status.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info_online_status.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info_online_status.name);
+		http_client_set_port(dest,p_self->info_online_status.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].ip_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].ip_server_name.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.dyndns_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.dyndns_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].dyndns_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].dyndns_server_name.port);
 	}
 
 
@@ -807,10 +809,14 @@
 
 RC_TYPE dyn_dns_set_http_clients(DYN_DNS_CLIENT *p_self)
 {
+	char	i;
 
-	dyn_dns_set_ip_server_dest(&p_self->http_to_ip_server,p_self);
-	dyn_dns_set_dyndns_server_dest(&p_self->http_to_dyndns,p_self);
 
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		dyn_dns_set_ip_server_dest(&p_self->info[i].http_to_ip_server,p_self,i);
+		dyn_dns_set_dyndns_server_dest(&p_self->info[i].http_to_dyndns,p_self,i);
+	}
 
 	return RC_OK;
 }
@@ -873,13 +879,13 @@
 		else
 			ip_enum=ip_6;
 
-		p_self->info.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info.my_ip_address.name[ip_enum])!=0);
+		p_self->i_face.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->i_face.my_ip_address.name[ip_enum])!=0);
 
-		strcpy(p_self->info.my_ip_address.name[ip_enum],p_ip_str);
+		strcpy(p_self->i_face.my_ip_address.name[ip_enum],p_ip_str);
 
 		/*put currently operated upon here -- for auto ip type too*/
-		strcpy(p_self->info.my_ip_address.name[ip_store],p_ip_str);
-		p_self->info.my_ip_has_changed[ip_store]=p_self->info.my_ip_has_changed[ip_enum];
+		strcpy(p_self->i_face.my_ip_address.name[ip_store],p_ip_str);
+		p_self->i_face.my_ip_has_changed[ip_store]=p_self->i_face.my_ip_has_changed[ip_enum];
 
 		free(p_ip_str);
 
@@ -895,20 +901,23 @@
 	iterate over any fallback addresses
 	break on first success
 */
-static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	RC_TYPE rc;
-	HTTP_CLIENT *p_http;
+	RC_TYPE				rc;
+	HTTP_CLIENT			*p_http;
+	DYNDNS_INFO_TYPE	*info;
 	
 
-	p_http = &p_self->http_to_ip_server;
+	info=&p_self->info[srv_index];
+
+	p_http = &info->http_to_ip_server;
 
 
-	rc = http_client_init_all(&p_self->http_to_ip_server);
+	rc = http_client_init_all(&info->http_to_ip_server);
 
 	if (rc != RC_OK)
 	{
-		http_client_shutdown(&p_self->http_to_ip_server);
+		http_client_shutdown(&info->http_to_ip_server);
 
 		return rc;
 	}
@@ -929,8 +938,8 @@
 			BOOL				is_got_afinet=false;
 
 
-			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-			                                      p_self->info.p_dns_system->p_specific_data);
+			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,srv_index,
+			                                      info->p_dns_system->p_specific_data);
 			if (p_self->dbg.level > LOG_CRIT) {
 
 				DBG_PRINTF((LOG_DEBUG,"The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -943,12 +952,12 @@
 
 
 			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Entering Loop.  Got %d sockets...\n",
-				p_self->http_to_ip_server.super.super.server_socket_count));
+				info->http_to_ip_server.super.super.server_socket_count));
 
-			for (i=0;i<p_self->http_to_ip_server.super.super.server_socket_count;i++,
-				p_self->http_to_ip_server.super.super.sock_index++) {
+			for (i=0;i<info->http_to_ip_server.super.super.server_socket_count;i++,
+				info->http_to_ip_server.super.super.sock_index++) {
 				
-				addr=p_self->http_to_ip_server.super.super.addr_ar[i];
+				addr=info->http_to_ip_server.super.super.addr_ar[i];
 
 				/*on *nix, IPv4 precedence could mean no IPv6 routes which could cause a crash on socket send*/
 				if (((is_got_afinet=(is_got_afinet || addr->ai_family==AF_INET)) && addr->ai_family==AF_INET6))
@@ -968,19 +977,19 @@
 					continue;
 					
 				/*doing any ip4?*/
-				if ((addr->ai_family==AF_INET) && !(p_self->info.is_update_ip4 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET) && !(p_self->info[srv_index].is_update_ip4 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 					
 				/*doing any ip6?*/
-				if ((addr->ai_family==AF_INET6) && !(p_self->info.is_update_ip6 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET6) && !(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 
-				if (!(RC_OK==(rc=http_client_transaction(&p_self->http_to_ip_server,&p_self->http_tr)))) {
+				if (!(RC_OK==(rc=http_client_transaction(&info->http_to_ip_server,&p_self->http_tr)))) {
 
 					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Failed getting %s ip from %s%s in check_my_ip_address...\n",
-						addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 				}
 				else {
 
@@ -999,16 +1008,16 @@
 					}
 					else {
 
-						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name[ip_store]));
+						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->i_face.my_ip_address.name[ip_store]));
 
-						p_self->info.is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
-						p_self->info.is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
+						p_self->info[srv_index].is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
+						p_self->info[srv_index].is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
 						
 						/*detect if just doing auto (based on ip server) and dump out when done*/
-						if ((is_got_ip4 && is_got_ip6) || !(p_self->info.is_update_ip4 && p_self->info.is_update_ip6))
+						if ((is_got_ip4 && is_got_ip6) || !(p_self->info[srv_index].is_update_ip4 && p_self->info[srv_index].is_update_ip6))
 
 							/*support ip4 only updates, on dual ip server*/
-							if ((p_self->info.is_update_ip4 && is_got_ip4) || !(p_self->info.is_update_ip4))							
+							if ((p_self->info[srv_index].is_update_ip4 && is_got_ip4) || !(p_self->info[srv_index].is_update_ip4))							
 
 								break;
 					}
@@ -1019,7 +1028,7 @@
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(&info->http_to_ip_server);
 
 
 	return rc;
@@ -1033,53 +1042,57 @@
         Check if my IP address has changed. -> ALL names have to be updated.
         Note: In the update function the property will set to false if update was successful.
 */
-static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	int			i;
-	DYNDNS_IPV	ip_v;
-	BOOL		is_ip_changed;
-	BOOL		is_dyndns_dual;
+	int					i;
+	DYNDNS_IPV			ip_v;
+	BOOL				is_ip_changed;
+	BOOL				is_dyndns_dual;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	for (i = 0; i < p_self->alias_info.count; ++i)
+	info=&p_self->info[srv_index];
+
+
+	for (i = 0; i < info->alias_info.count; ++i)
 	{
 
-		ip_v=p_self->alias_info.names[i].ip_v_enum;		
+		ip_v=info->alias_info.names[i].ip_v_enum;		
 
 		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
-		if (!(is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))))
+		if (!(is_dyndns_dual=(NULL!=strstr(info->alias_info.names[i].ip_v,DUAL_LIST))))
 
-			is_ip_changed=p_self->info.my_ip_has_changed[ip_v];
+			is_ip_changed=p_self->i_face.my_ip_has_changed[ip_v];
 		else
-			is_ip_changed=(p_self->info.my_ip_has_changed[ip_4] || p_self->info.my_ip_has_changed[ip_6]);
+			is_ip_changed=(p_self->i_face.my_ip_has_changed[ip_4] || p_self->i_face.my_ip_has_changed[ip_6]);
 
-		p_self->alias_info.update_required[i] = 
+		info->alias_info.update_required[i] = 
 
 			/*ip address changed?*/
 			(is_ip_changed
 
 			/*pending failed update?*/
-			|| (is_update_pending && !(p_self->alias_info.update_succeeded[i]))
+			|| (is_global_update_pending && !(info->alias_info.update_succeeded[i]))
 
 			/*administrative update?*/
 			|| (!(p_self->forced_update_counter)));
 
-		if (p_self->alias_info.update_required[i]) {	
+		if (info->alias_info.update_required[i]) {	
 	
 			if (is_dyndns_dual)
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s%s%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_4],",",p_self->info.my_ip_address.name[ip_6]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->i_face.my_ip_address.name[ip_4],",",p_self->i_face.my_ip_address.name[ip_6]));
 
 
 			else
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_v]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->i_face.my_ip_address.name[ip_v]));
 
-			p_self->alias_info.update_required[i]=!(p_self->alias_info.fatal_error[i]);
+			info->alias_info.update_required[i]=!(info->alias_info.fatal_error[i]);
 		}
 	}
 	
@@ -1136,7 +1149,7 @@
 static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
 {
 
-	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL)
+	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->i_face.my_ip_address.name[ip_store]) != NULL)
 			|| strstr(p_rsp, "has not changed") != NULL);	
 }
 
@@ -1223,7 +1236,7 @@
 {
 	(void)p_ok_string;
 
-	return ((strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL) ||
+	return ((strstr(p_rsp, p_self->i_face.my_ip_address.name[ip_store]) != NULL) ||
 		(strstr(p_rsp, "already in use") != NULL));
 }
 
@@ -1255,7 +1268,7 @@
 static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
 {
 
-	return (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]) != NULL);
+	return (strstr(p_rsp,p_self->i_face.my_ip_address.name[ip_store]) != NULL);
 }
 
 /*not yet implemented -- at moment, this seems only failure returned
@@ -1293,110 +1306,133 @@
 }
 
 static RC_TYPE update_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,
-										  int config_fails,RC_TYPE *rc)
+										  int config_fails,RC_TYPE rc,char srv_index)
 {
-	FILE *fp;
+	FILE				*fp;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	if (config_fails==p_self->alias_info.count)
+	info=&p_self->info[srv_index];
 
-		*rc=RC_DYNDNS_RSP_CONFIG;
+	/*global successes maintained across server iterations in main loop*/
+	is_global_success_updates=(is_global_success_updates || success_updates);
 
-	else {
+	if (config_fails==info->alias_info.count) {
 
-		if (success_updates) {
+		rc=RC_DYNDNS_RSP_CONFIG;
 
-			/*reset forced update period*/
-			p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
-			p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
+		if (!(srv_index==p_self->srv_cnt-1))
 
-			if ((fp=utf_fopen(p_self->time_cache, "w"))) {
+			return rc;
+	}
 
-				fprintf(fp,"%ld",time(NULL));
+	/*
+		reset on last server if any server successes
+	*/
+	if (is_global_success_updates && srv_index==p_self->srv_cnt-1) {
 
-				fclose(fp);
-			}
+		/*reset forced update period*/
+		p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
+		p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
+
+		if ((fp=utf_fopen(p_self->time_cache, "w"))) {
 
-			if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+			fprintf(fp,"%ld",time(NULL));
 
-				int			i;
-				DYNDNS_IPV	ip_enum;
-				BOOL		is_dyndns_dual;
+			fclose(fp);
+		}
+
+		if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+
+			int			i;
+			int			ii;
+			DYNDNS_IPV	ip_enum;
+			BOOL		is_dyndns_dual;
 				
-				for (i=0;i<p_self->alias_info.count;i++) {
+			for (ii=0;ii<p_self->srv_cnt;ii++) {
+
+				for (i=0;i<p_self->info[ii].alias_info.count;i++) {
 
-					is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST));
+					is_dyndns_dual=(NULL!=strstr(p_self->info[ii].alias_info.names[i].ip_v,DUAL_LIST));
 
-					ip_enum=p_self->alias_info.names[i].ip_v_enum;
+					ip_enum=p_self->info[ii].alias_info.names[i].ip_v_enum;
 
-					if (p_self->alias_info.update_succeeded[i]) { 						
+					if (p_self->info[ii].alias_info.update_succeeded[i]) { 						
 
 						if (!(is_dyndns_dual))
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_enum],
-								p_self->alias_info.names[i].name,":",p_self->alias_info.names[i].ip_v);
+							fprintf(fp,"%s %s%s%s\n",p_self->i_face.my_ip_address.name[ip_enum],
+									p_self->info[ii].alias_info.names[i].name,":",p_self->info[ii].
+									alias_info.names[i].ip_v);
 
 						else {
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_4],
-								p_self->alias_info.names[i].name,":","ip4");
+							fprintf(fp,"%s %s%s%s\n",p_self->i_face.my_ip_address.name[ip_4],
+									p_self->info[ii].alias_info.names[i].name,":","ip4");
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_6],
-								p_self->alias_info.names[i].name,":","ip6");
+							fprintf(fp,"%s %s%s%s\n",p_self->i_face.my_ip_address.name[ip_6],
+									p_self->info[ii].alias_info.names[i].name,":","ip6");
 						}
 					}
 				}
-
-				fclose(fp);
 			}
-		}
-	
-		/*any pending?*/
-		if (!(updates_needed && !(success_updates==updates_needed))) {
-
-			/*no pendings*/
-			if (success_updates) {
 
-				p_self->is_forced_update_attempted=false;
+			fclose(fp);
+		}		
+	}
 
-				*rc=RC_OK;
-			}
-		}
-		else {
+	/*any pending?*/
+	if ((updates_needed && !(success_updates==updates_needed))) {
 
-			if (*rc==RC_OK) /*not break after http client init*/
+		if (rc==RC_OK) /*not break after http client init*/
 			
-				*rc=RC_DYNDNS_RSP_NOTOK;
+			rc=RC_DYNDNS_RSP_NOTOK;
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
+		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
 						updates_needed-success_updates));
+	}
+	else {
+
+		/*no pendings this server*/
+		if (success_updates) {
+
+			/*no pendings any server*/
+			if (!(is_global_in_proc_update_pending) && srv_index==p_self->srv_cnt-1)
+
+				p_self->is_forced_update_attempted=false;
+
+			rc=RC_OK;
 		}
 	}
 
-	return *rc;
+	return rc;
 }
 
-static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset)
+static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset,char srv_index)
 {
-	int		i;
-	int		success_updates=0;	
-	int		update_ok=false;
-	int		config_fails=0;
-	int		updates_needed=p_self->alias_info.count;
-	BOOL	is_ipv4;
+	DYNDNS_INFO_TYPE	*info;
+	int					i;
+	int					success_updates=0;	
+	int					update_ok=false;
+	int					config_fails=0;
+	int					updates_needed=p_self->info[srv_index].alias_info.count;
+	BOOL				is_ipv4;
 
 	RC_TYPE rc = RC_OK;
 
 
+	info=&p_self->info[srv_index];
+
+
 	do
 	{
-		for (i = 0; i < p_self->alias_info.count; ++i) {
+		for (i = 0; i < info->alias_info.count; ++i) {
 
-			if (!(p_self->alias_info.update_required[i])) {
+			if (!(info->alias_info.update_required[i])) {
 
-				if (p_self->alias_info.fatal_error[i]) {
+				if (info->alias_info.fatal_error[i]) {
 
-					do_handle_bad_config(p_self,i);
+					do_handle_bad_config(p_self,i,srv_index);
 
 					config_fails++;
 				}
@@ -1406,48 +1442,48 @@
 			else {
 
 				/*dual stack with ip's updated in comma delimited list fashion?*/
-				if (NULL==(strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))) {
+				if (NULL==(strstr(info->alias_info.names[i].ip_v,DUAL_LIST))) {
 
-					if (!(ip_store==p_self->alias_info.names[i].ip_v_enum))
+					if (!(ip_store==info->alias_info.names[i].ip_v_enum))
 
-						strcpy(p_self->info.my_ip_address.name[ip_store],
-								p_self->info.my_ip_address.name[p_self->alias_info.names[i].ip_v_enum]);
+						strcpy(p_self->i_face.my_ip_address.name[ip_store],
+								p_self->i_face.my_ip_address.name[info->alias_info.names[i].ip_v_enum]);
 				}
 				else {
 
-					strcat(strcat(strcpy(p_self->info.my_ip_address.name[ip_store],p_self->info.my_ip_address.name[ip_4]),
-							","),p_self->info.my_ip_address.name[ip_6]);
+					strcat(strcat(strcpy(p_self->i_face.my_ip_address.name[ip_store],p_self->i_face.my_ip_address.name[ip_4]),
+							","),p_self->i_face.my_ip_address.name[ip_6]);
 
-					if (!(p_self->info.is_got_ip4 && p_self->info.is_got_ip6)) {
+					if (!(p_self->info[srv_index].is_got_ip4 && p_self->info[srv_index].is_got_ip6)) {
 
-						p_self->alias_info.update_succeeded[i]=false;
+						info->alias_info.update_succeeded[i]=false;
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping partially empty address (%s) update of alias "\
-							"%s\n",p_self->info.my_ip_address.name[ip_store],p_self->alias_info.names[i].name));
+							"%s\n",p_self->i_face.my_ip_address.name[ip_store],info->alias_info.names[i].name));
 
 						continue;
 					}
 				}
 
-				if (!(strlen(p_self->info.my_ip_address.name[ip_store]))) {
+				if (!(strlen(p_self->i_face.my_ip_address.name[ip_store]))) {
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",info->alias_info.names[i].name));
 
 					continue;
 				}
 
-				is_ipv4=(p_self->alias_info.names[i].ip_v_enum==ip_4);
+				is_ipv4=(info->alias_info.names[i].ip_v_enum==ip_4);
 
 				/*bind to dynamic dns server according to address type to be updated*/
-				http_client_set_is_ipv4(&p_self->http_to_dyndns,is_ipv4);
+				http_client_set_is_ipv4(&info->http_to_dyndns,is_ipv4);
 
-				if (!((rc=http_client_init(&p_self->http_to_dyndns))==RC_OK)) {
+				if (!((rc=http_client_init(&info->http_to_dyndns))==RC_OK)) {
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),info->alias_info.names[i].name));
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 				}
 				else {
 
@@ -1455,9 +1491,10 @@
 					{
 						HTTP_TRANSACTION http_tr;
 						
-						http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-							                  (struct _DYN_DNS_CLIENT*) p_self,i,
-								              (struct DYNDNS_SYSTEM*) p_self->info.p_dns_system);
+						http_tr.req_len = 
+							info->p_dns_system->p_dns_update_req_func((struct _DYN_DNS_CLIENT*) p_self,srv_index,i,
+							(struct DYNDNS_SYSTEM*) info->p_dns_system);
+
 						http_tr.p_req = (char*) p_self->p_req_buffer;
 						http_tr.p_rsp = (char*) p_self->p_work_buffer;
 						http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
@@ -1465,7 +1502,7 @@
 						p_self->p_work_buffer[http_tr.rsp_len+1] = 0;				
 
 						/*send it*/
-						rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);
+						rc = http_client_transaction(&info->http_to_dyndns, &http_tr);
 						http_tr.p_rsp[http_tr.rsp_len]=0;
 
 						if (p_self->dbg.level > 2)
@@ -1477,14 +1514,13 @@
 						/*error in send?*/
 						if (!(rc == RC_OK))
 
-							p_self->alias_info.update_succeeded[i]=false;
+							info->alias_info.update_succeeded[i]=false;
 
 						else {
 
 							update_ok =
-								p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
-									    http_tr.p_rsp,
-										p_self->info.p_dns_system->p_success_string);
+								info->p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
+									    http_tr.p_rsp,info->p_dns_system->p_success_string);
 
 							if (update_ok)
 							{
@@ -1498,12 +1534,12 @@
 									*is_forced_update_reset=true;
 								}
 #endif
-								p_self->alias_info.update_required[i]=false;
-								p_self->alias_info.update_succeeded[i]=true;
+								info->alias_info.update_required[i]=false;
+								info->alias_info.update_succeeded[i]=true;
 
 								DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n",
-											p_self->alias_info.names[i].name,
-											p_self->info.my_ip_address.name[ip_store]));
+											info->alias_info.names[i].name,
+											p_self->i_face.my_ip_address.name[ip_store]));
 
 								if (p_self->external_command)
 
@@ -1511,24 +1547,24 @@
 							}
 							else {
 
-								p_self->alias_info.update_succeeded[i]=false;
+								info->alias_info.update_succeeded[i]=false;
 
-								if (!(p_self->info.p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
+								if (!(info->p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
 
-									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",p_self->alias_info.names[i].name));
+									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",info->alias_info.names[i].name));
 								} 
 								else {
 
 									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
 
-									p_self->alias_info.fatal_error[i]=TRUE;
+									info->alias_info.fatal_error[i]=TRUE;
 
 									DBG_PRINTF((LOG_CRIT,"C:" MODULE_TAG "\n"\
 												ERROR_FLAG \
 												"Fatal dyndns server update error for "\
 												"alias, %s.\nThis client should be stopped and corrected for "\
 												"configuration errors, and restarted...\n" \
-												ERROR_FLAG,p_self->alias_info.names[i].name));
+												ERROR_FLAG,info->alias_info.names[i].name));
 
 									config_fails++;
 									updates_needed--;
@@ -1545,7 +1581,7 @@
 				}
 
 				{
-					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&info->http_to_dyndns);
 
 					if (!(rc2==RC_OK))
 
@@ -1553,7 +1589,7 @@
 
 				}				
 
-				if (i<p_self->alias_info.count-1)
+				if (i<info->alias_info.count-1)
 
 					os_sleep_ms(1000);
 			}
@@ -1564,7 +1600,7 @@
 	}
 	while(0);
 
-	return update_update_state(p_self,updates_needed,success_updates,config_fails,&rc);
+	return update_update_state(p_self,updates_needed,success_updates,config_fails,rc,srv_index);
 }
 
 RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self)
@@ -1576,8 +1612,9 @@
 
 	do
 	{
-		p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-		if (p_self->info.p_dns_system == NULL)
+
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
+		if (p_self->info[0].p_dns_system == NULL)
 		{
 			rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
 			break;
@@ -1651,7 +1688,7 @@
 	return rc;
 }
 
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self)
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 	RC_TYPE			rc=RC_OK;
 	char			*str_uri_encoded;
@@ -1661,23 +1698,23 @@
 	int				actual_len;
 
 
-	if (!(p_self->info.credentials.my_password) && !(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_password) && !(p_self->info[srv_cnt].credentials.my_username))
 
 		return RC_OK;
 
 	size=strlen(format)+1;
 
-	if (!(p_self->info.credentials.my_password))
+	if (!(p_self->info[srv_cnt].credentials.my_password))
 
-		p_self->info.credentials.my_password=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_password=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_password);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_password);
 
-	if (!(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_username))
 
-		p_self->info.credentials.my_username=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_username=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_username);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_username);
 
 	do
 	{
@@ -1689,8 +1726,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format,
-		                     p_self->info.credentials.my_username,
-		                     p_self->info.credentials.my_password);
+		                     p_self->info[srv_cnt].credentials.my_username,
+		                     p_self->info[srv_cnt].credentials.my_password);
 
 		if (actual_len >= size)
 		{
@@ -1700,15 +1737,15 @@
 
 		/*encode*/
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer =
+		p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer =
 		    b64encode(utf_8_uri_encoded(&str_uri_encoded,p_tmp_buff,"&#",";"));
 
 		free(str_uri_encoded);
 
-		p_self->info.credentials.encoded =
-		    (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[srv_cnt].credentials.encoded =
+		    (p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer != NULL);
 
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[srv_cnt].credentials.size = strlen(p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -1741,6 +1778,8 @@
 	DYN_DNS_CLIENT *p_self;
 	BOOL http_to_dyndns_constructed = FALSE;
 	BOOL http_to_ip_constructed = FALSE;
+	char i;
+
 
 	if (pp_self == NULL)
 	{
@@ -1777,34 +1816,38 @@
 		}
 
 
-		rc = http_client_construct(&p_self->http_to_ip_server);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
-		}
+		for (i=0;i<MAX_DNS_SERVER;i++) {
 
-		p_self->info.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			rc = http_client_construct(&p_self->info[i].http_to_ip_server);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		http_to_ip_constructed = TRUE;
+			rc = http_client_construct(&p_self->info[i].http_to_dyndns);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		rc = http_client_construct(&p_self->http_to_dyndns);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
 		}
+
+		http_to_ip_constructed = TRUE;
 		http_to_dyndns_constructed = TRUE;
 
+		p_self->i_face.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+		p_self->i_face.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+		p_self->i_face.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+
+
 		(p_self)->cmd = NO_CMD;
 		(p_self)->sleep_sec = DYNDNS_DEFAULT_SLEEP;
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
 		(p_self)->initialized = FALSE;
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
 		p_self->lang_file = NULL;
 
 	}
@@ -1824,25 +1867,29 @@
 		{
 			free (p_self->p_work_buffer);
 		}
-		if (http_to_dyndns_constructed)
 		{
-			http_client_destruct(&p_self->http_to_dyndns);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_dyndns);
+			}
 		}
-		if (http_to_ip_constructed)
 		{
-			http_client_destruct(&p_self->http_to_ip_server);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_ip_server);
+			}
 		}
-		if (p_self->info.my_ip_address.name[ip_store])
+		if (p_self->i_face.my_ip_address.name[ip_store])
 		{
-			free(p_self->info.my_ip_address.name[ip_store]);
+			free(p_self->i_face.my_ip_address.name[ip_store]);
 		}
-		if (p_self->info.my_ip_address.name[ip_4])
+		if (p_self->i_face.my_ip_address.name[ip_4])
 		{
-			free(p_self->info.my_ip_address.name[ip_4]);
+			free(p_self->i_face.my_ip_address.name[ip_4]);
 		}
-		if (p_self->info.my_ip_address.name[ip_6])
+		if (p_self->i_face.my_ip_address.name[ip_6])
 		{
-			free(p_self->info.my_ip_address.name[ip_6]);
+			free(p_self->i_face.my_ip_address.name[ip_6]);
 		}
 	}
 
@@ -1855,7 +1902,10 @@
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
-	RC_TYPE rc;
+	char	i;
+	char	ii;
+
+
 	if (p_self == NULL)
 	{
 		return RC_OK;
@@ -1866,18 +1916,55 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
-	if (rc != RC_OK)
-	{
+	free(p_self->ip_server_name_global.name);
+	p_self->ip_server_name_global.name=NULL;
+	free(p_self->ip_server_name_global.url);
+	p_self->ip_server_name_global.url=NULL;
 
-	}
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
-	if (rc != RC_OK)
-	{
+		http_client_destruct(&p_self->info[i].http_to_ip_server);
+		http_client_destruct(&p_self->info[i].http_to_dyndns);
+
+		free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer=NULL;
+
+		free(p_self->info[i].credentials.my_username);
+		p_self->info[i].credentials.my_username=NULL;
+
+		free(p_self->info[i].credentials.my_password);
+		p_self->info[i].credentials.my_password=NULL;
+
+		free(p_self->info[i].dyndns_server_name.url);
+		p_self->info[i].dyndns_server_name.url=NULL;
+
+		free(p_self->info[i].proxy_server_name.name);
+		p_self->info[i].proxy_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.name);
+		p_self->info[i].ip_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.url);
+		p_self->info[i].ip_server_name.url=NULL;
+
+		for (ii=0;ii<p_self->info[i].alias_info.count;ii++) {
+
+			free(p_self->info[i].alias_info.names[ii].name);
+			p_self->info[i].alias_info.names[ii].name=NULL;
+		}
 
 	}
 
+	free(p_self->i_face.my_ip_address.name[ip_store]);
+	p_self->i_face.my_ip_address.name[ip_store]=NULL;
+
+	free(p_self->i_face.my_ip_address.name[ip_4]);
+	p_self->i_face.my_ip_address.name[ip_4]=NULL;
+
+	free(p_self->i_face.my_ip_address.name[ip_6]);
+	p_self->i_face.my_ip_address.name[ip_6]=NULL;
+
+
 	if (p_self->p_work_buffer != NULL)
 	{
 		free(p_self->p_work_buffer);
@@ -1890,11 +1977,6 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
-	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
 
 	if (p_self->lang_file != NULL)
 	{
@@ -1922,51 +2004,6 @@
 		p_self->time_cache=NULL;
 	}
 
-	if (p_self->info.credentials.my_username != NULL)
-	{
-
-		free(p_self->info.credentials.my_username);
-		p_self->info.credentials.my_username=NULL;
-	}
-
-	if (p_self->info.credentials.my_password != NULL)
-	{
-
-		free(p_self->info.credentials.my_password);
-		p_self->info.credentials.my_password=NULL;
-	}
-
-	{
-		int i=0;
-
-
-		while (1) {
-
-			if (!(p_self->alias_info.names[i].name != NULL))
-
-				break;
-			else
-			{
-
-				free(p_self->alias_info.names[i].name);
-				p_self->alias_info.names[i].name=NULL;
-			}
-		}
-	}
-
-	if (p_self->info.ip_server_url != NULL)
-	{
-
-		free(p_self->info.ip_server_url);
-		p_self->info.ip_server_url=NULL;
-	}
-
-	if (p_self->info.dyndns_server_url != NULL)
-	{
-
-		free(p_self->info.dyndns_server_url);
-		p_self->info.dyndns_server_url=NULL;
-	}
 
 	if (p_self->external_command != NULL)
 	{
@@ -1975,40 +2012,9 @@
 		p_self->external_command=NULL;
 	}
 
-	if (p_self->info.proxy_server_name.name[ip_store] != NULL)
-	{
+	free(p_self->p_pidfilename);
+	p_self->p_pidfilename = NULL;
 
-		free(p_self->info.proxy_server_name.name[ip_store]);
-		p_self->info.proxy_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.ip_server_name.name[ip_store]);
-		p_self->info.ip_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_store]);
-		p_self->info.my_ip_address.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_4] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_4]);
-		p_self->info.my_ip_address.name[ip_4]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_6] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_6]);
-		p_self->info.my_ip_address.name[ip_6]=NULL;
-	}
 
 	free(p_self);
 	p_self = NULL;
@@ -2080,12 +2086,12 @@
 	return RC_OK;
 }
 
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i)
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt)
 {
 
 	/*might want to sound an error specific alert too*/
 
-	if (i<p_self->alias_info.count)
+	if (i<p_self->info[srv_cnt].alias_info.count)
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
 					ERROR_FLAG \
@@ -2093,7 +2099,7 @@
 					"fatal dyndns server update error for "\
 					"alias, %s.\nThis client should be stopped and corrected for "\
 					"configuration errors, and restarted...\n" \
-					ERROR_FLAG,p_self->alias_info.names[i]));
+					ERROR_FLAG,p_self->info[srv_cnt].alias_info.names[i]));
 	else
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
@@ -2107,21 +2113,21 @@
 	return RC_ERROR;
 }
 
-static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	/*ip update subsequent dns server return bad config related error*/
 
 	int	i;
 
-	for (i=0;i<p_self->alias_info.count;i++) {
+	for (i=0;i<p_self->info[srv_cnt].alias_info.count;i++) {
 
-		if (p_self->alias_info.fatal_error[i])
+		if (p_self->info[srv_cnt].alias_info.fatal_error[i])
 
 			break;
 	}
 
-	return do_handle_bad_config(p_self,i);
+	return do_handle_bad_config(p_self,i,srv_cnt);
 }
 
 /*
@@ -2134,7 +2140,7 @@
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_ERROR;
@@ -2149,9 +2155,9 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->is_bad_config)
+	if (p_self->is_global_bad_config)
 
-		return dyn_dns_handle_bad_config(p_self);
+		return dyn_dns_handle_bad_config(p_self,srv_cnt);
 
 	do
 	{
@@ -2164,7 +2170,7 @@
 
 				if ((is_exit=(p_self->net_retries<net_attempts++))) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;					
 
 					break;
 				}
@@ -2174,7 +2180,7 @@
 			else {
 
 				/*ask IP server something so will respond and give me my IP */
-				rc = check_my_ip_address(p_self);
+				rc = check_my_ip_address(p_self,srv_cnt);
 
 				if (rc==RC_OK)
 
@@ -2184,7 +2190,7 @@
 
 				if (p_self->net_retries<ip_attempts++) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -2211,7 +2217,7 @@
 			DBG_PRINTF((LOG_INFO,"I:DYNDNS: dyn_dns_update_ip checking alias table...\n"));
 
 			/*step through aliases list, resolve them and check if they point to my IP*/
-			rc = do_check_alias_update_table(p_self);
+			rc = do_check_alias_update_table(p_self,srv_cnt);
 			if (rc != RC_OK)
 			{
 				break;
@@ -2227,7 +2233,7 @@
 
 					if (p_self->net_retries<net_attempts++) {
 
-						is_update_pending=true;
+						p_self->info[srv_cnt].is_update_pending=true;
 
 						break;
 					}
@@ -2237,11 +2243,13 @@
 				else {
 
 					/*update IPs marked as not identical with my IP*/
-					rc = do_update_alias_table(p_self,&is_forced_update_reset);
+					rc = do_update_alias_table(p_self,&is_forced_update_reset,srv_cnt);
 
 					if (rc==RC_OK) {
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2250,14 +2258,18 @@
 
 					if (p_self->net_retries<ip_attempts++) {
 
-						is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));						
+						p_self->info[srv_cnt].is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));
+
+						p_self->info[srv_cnt].is_bad_config=!(p_self->info[srv_cnt].is_update_pending);
 						
 						break;
 					}
 
 					if (rc==RC_DYNDNS_RSP_CONFIG) { /*might want to trigger alert here*/
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2875,7 +2887,7 @@
 
 
 	*p_ras_thread_data=construct_and_launch_trap_ras_events(dyn_dns_update_ip_handler,p_dyndns,p_dyndns->\
-		                   http_to_ip_server.super.super.p_remote_host_name,\
+		                   info[0].http_to_ip_server.super.super.p_remote_host_name,\
 		                   p_dyndns->dbg.level);
 
 	if (*p_ras_thread_data) {
@@ -2913,20 +2925,6 @@
 	*src+=inc;
 }
 
-RC_TYPE dyn_dns_reinit(DYN_DNS_CLIENT *p_dyndns)
-{
-
-	RC_TYPE		rc=RC_OK;
-
-
-	dyn_dns_shutdown(p_dyndns);
-
-	rc=do_dyn_dns_init(p_dyndns);
-
-
-	return rc;
-}
-
 /*find the alias given by parameter alias in list of p_dyndns structure alias names and set
   correponding update state boolean to parameter is_updated
 
@@ -2939,6 +2937,7 @@
 {
 
 	int		i;
+	int		ii;
 	char	*alias_in=NULL;
 	char	*alias_ip_v=alias;
 	char	*p_alias_ip_v=NULL;
@@ -2973,39 +2972,42 @@
 		is_auto=true;
 	}
 
-	for (i=0;i<p_dyndns->alias_info.count;i++) {
+	for (ii=0;ii<p_dyndns->srv_cnt;ii++) {
 
-		/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
+		for (i=0;i<p_dyndns->info[ii].alias_info.count;i++) {
 
-		alias_cmp_src=safe_malloc(strlen(p_dyndns->alias_info.names[i].name)+9);
-		strcat(strcat(strcpy(alias_cmp_src,p_dyndns->alias_info.names[i].name),":"),p_dyndns->alias_info.names[i].ip_v);
+			/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
 
-		if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->alias_info.names[i].ip_v,DUAL_LIST) 
-			&& !(strcmp(p_dyndns->alias_info.names[i].name,alias_in)))) {
+			alias_cmp_src=safe_malloc(strlen(p_dyndns->info[ii].alias_info.names[i].name)+9);
+			strcat(strcat(strcpy(alias_cmp_src,p_dyndns->info[ii].alias_info.names[i].name),":"),p_dyndns->info[ii].alias_info.names[i].ip_v);
 
-			p_dyndns->alias_info.update_succeeded[i]=is_updated;
+			if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->info[ii].alias_info.names[i].ip_v,DUAL_LIST) 
+				&& !(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in)))) {
 
-			is_found=true;
-		}
-		else {
+				p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-			/*for aliases of type auto, set update state for either ip6, ip4*/
+				is_found=true;
+			}
+			else {
 
-			if (is_auto)
+				/*for aliases of type auto, set update state for either ip6, ip4*/
 
-				if (!(strcmp(p_dyndns->alias_info.names[i].name,alias_in))) {
+				if (is_auto)
 
-					p_dyndns->alias_info.update_succeeded[i]=is_updated;
+					if (!(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in))) {
 
-					is_found=true;
-				}
-		}
+						p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
+
+						is_found=true;
+					}
+			}
 
-		free(alias_cmp_src);
+			free(alias_cmp_src);
 
-		if (is_found)
+			if (is_found)
 
-			break;
+				break;
+		}
 	}
 
 	free(p_alias_ip_v);
@@ -3129,6 +3131,20 @@
 	return rc;
 }
 
+int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
+{
+	char	i;
+	int		alias_count=0;
+
+
+	for (i=0;i<MAX_DNS_SERVER;i++) {
+
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
+
+	return alias_count;
+}
+
 /*  Record the last ip as per that in ip cache file.  Report it via log output.
 
 	Set update need for each space separated ip, alias pair line read.  
@@ -3145,6 +3161,7 @@
 
 	fp=utf_fopen(p_dyndns->ip_cache,"r");
 
+
 	if (fp)	{
 
 		char	ch;
@@ -3183,11 +3200,11 @@
 
 					if (strstr(in_str,".")) {
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_4],in_str);
+						strcpy(p_dyndns->i_face.my_ip_address.name[ip_4],in_str);
 					}
 					else {
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_6],in_str);
+						strcpy(p_dyndns->i_face.my_ip_address.name[ip_6],in_str);
 					}
 				}
 				else { /*alias*/
@@ -3209,17 +3226,17 @@
 			}
 		}
 
-		is_update_pending=(alias_count<p_dyndns->alias_info.count);
+		is_global_update_pending=(alias_count<number_of_aliases(p_dyndns));
 
 		fclose(fp);
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_4]))
+		if (strlen(p_dyndns->i_face.my_ip_address.name[ip_4]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_4]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->i_face.my_ip_address.name[ip_4]));
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_6]))
+		if (strlen(p_dyndns->i_face.my_ip_address.name[ip_6]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_6]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->i_face.my_ip_address.name[ip_6]));
 
 		free(in_str);
 	}
@@ -3412,6 +3429,35 @@
 		}
 	}
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename) {
+		
+		if (strlen(p_dyndns->p_pidfilename) != 0)
+		{
+			FILE *fp=NULL;
+			int obj=0;
+			char pid[7];
+
+
+			if ((fp = utf_fopen(p_dyndns->p_pidfilename, "w")))
+			{
+
+#ifndef _WIN32
+				if (0<snprintf(pid, 7, "%d\n", getpid()))
+#else
+				if (0<_snprintf(pid, 7, "%d\n", _getpid()))
+#endif
+					obj = fwrite(pid, strlen(pid), 1, fp);
+
+				fclose(fp);
+			}
+			if (!fp || obj != 1)
+			{
+				return RC_FILE_IO_OPEN_ERROR;
+			}
+		}
+	}
+
 	dyn_dns_print_hello(NULL);
 
 	/*  now that log is open, report any command line errors eventhough registry params made up for them --
@@ -3444,7 +3490,18 @@
 
 	if (rc==RC_OK) {
 
-		rc = get_encoded_user_passwd(p_dyndns);
+		char	i;
+		RC_TYPE	pw_rc;
+
+
+		for (i=0;i<p_dyndns->srv_cnt;i++) {
+
+			if (!(RC_OK==(pw_rc=get_encoded_user_passwd(p_dyndns,i))))
+
+				if (rc==RC_OK) /*return first of any error(s)*/
+
+					rc=pw_rc;
+		}
 
 #ifdef _WIN32
 
@@ -3492,6 +3549,9 @@
 	RC_TYPE				rc=RC_OK;
 	BOOL				init_flag=FALSE;
 	int					current_iteration=0;
+	char				bad_config_count;
+	char				i;
+	int					success_count;
 
 #ifdef _WIN32
 
@@ -3513,23 +3573,45 @@
 
 		do
 		{
+			/*state across multiple server updates*/
+			bad_config_count=0;
+			is_global_success_updates=false; /*flagged in update_update_state*/
+			is_global_in_proc_update_pending=false;			
+			success_count=0;
 
-			/*update IP address in a loop*/
-			
-			if (((rc=dyn_dns_update_ip(p_dyndns))==RC_OK))
+			for (i=0;i<p_dyndns->srv_cnt;i++) {
 
-				increment_iterations(p_dyndns);
+				if (p_dyndns->cmd==CMD_STOP)
 
-			else {
+					break;
+
+				if (((rc=dyn_dns_update_ip(p_dyndns,i))==RC_OK))
+
+					success_count++;
+
+				else {
+
+					DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
+								errorcode_get_name(rc), rc, current_iteration));
 
-				DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
-					        errorcode_get_name(rc), rc, current_iteration));
+					if (p_dyndns->info[i].is_bad_config)
 
-				p_dyndns->is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG);
+						bad_config_count++;
+				}
 
-				rc=dyn_dns_reinit(p_dyndns);
+				is_global_in_proc_update_pending=(is_global_in_proc_update_pending || p_dyndns->info[i].is_update_pending);
 			}
 
+			is_global_update_pending=is_global_in_proc_update_pending;
+
+			/*bad config all aliases for all servers?*/
+			p_dyndns->is_global_bad_config=(bad_config_count==p_dyndns->srv_cnt);
+
+			if (success_count==p_dyndns->srv_cnt)
+
+				increment_iterations(p_dyndns);
+
+
 #ifdef USE_SNDFILE
 
 #ifndef USE_THREADS
@@ -3539,8 +3621,7 @@
 
 #endif
 
-			if (p_dyndns->cmd==CMD_STOP)
-			{
+			if (p_dyndns->cmd==CMD_STOP) {
 
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
 
@@ -3553,15 +3634,6 @@
 
 				break;
 			} 
-			else {
-
-				if (!(rc==RC_OK)) {
-
-					init_flag=false;
-
-					break;
-				}
-			}
 
 			/* sleep the time set in the ->sleep_sec data memeber*/
 			dyn_dns_wait_for_cmd(p_dyndns);
@@ -3570,8 +3642,8 @@
 			inc_update_times(p_dyndns,&(p_dyndns->times_since_last_update),1);
 
 			/*reset the command*/
-			if (!(p_dyndns->cmd==CMD_STOP))
-			{
+			if (!(p_dyndns->cmd==CMD_STOP))	{
+
 				p_dyndns->cmd=NO_CMD;
 			}
 			else {
@@ -3602,8 +3674,8 @@
 #endif
 
 
-	if (init_flag)
-	{
+	if (init_flag) {
+
 		/* dyn_dns_shutdown object */
 		rc = dyn_dns_shutdown(p_dyndns);
 	}
diff -ur inadyn-mt.v.02.24.36/src/dyndns.h inadyn-mt.v.02.24.36-pid-new/src/dyndns.h
--- src/dyndns.h	2011-03-31 17:18:47.000000000 -0400
+++ src/dyndns.h	2011-04-06 02:36:54.212826829 -0400
@@ -75,7 +75,7 @@
 
 #endif
 
-#define	DYNDNS_EXTRA_VERSION
+#define	DYNDNS_EXTRA_VERSION	"-ms_pid_patch_02"
 
 #define DYNDNS_VERSION_STRING	"02.24.36" DYNDNS_VERSION_SND DYNDNS_VERSION_THD DYNDNS_EXTRA_VERSION
 #define DYNDNS_AGENT_NAME		"inadyn-mt/" DYNDNS_VERSION_STRING
@@ -360,6 +360,8 @@
 #define DUAL_LIST			"coupled"
 #define MAX_IP_TYPE_SIZE	8
 
+#define MAX_DNS_SERVER		10
+
 /* typedefs */
 struct _DYN_DNS_CLIENT;
 struct DYNDNS_SYSTEM;
@@ -369,7 +371,7 @@
 /** Function to prepare DNS system specific server requests
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, char srv_cnt, int nr, struct DYNDNS_SYSTEM *p_sys_info);
 typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
 typedef int (*DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp);
 typedef struct
@@ -432,10 +434,17 @@
 
 typedef struct 
 {
-	char *name[3];
+	char *name;
+	char *url;
 	int port;
 } DYNDNS_SERVER_NAME;
 
+typedef struct 
+{
+	char *name[3];
+	int port;
+} DYNDNS_MY_IP;
+
 /*a given alias (dyn domain names) can
   be associated with one "ip type", of
   'dual', 'coupled', 'ip4', 'ip6', 'auto',
@@ -454,12 +463,20 @@
 
 typedef struct 
 {
-    BOOL my_ip_has_changed[3];
-	BOOL is_update_ip4;
-	BOOL is_update_ip6;
-	BOOL is_update_auto;
-	BOOL is_got_ip4;
-	BOOL is_got_ip6;
+	/*multiple of ip types (2 -- IPv4, IPv6)*/
+	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
+	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
+	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
+	int count;
+	int count_dual;
+} DYNDNS_ALIAS_INFO;
+
+typedef struct
+{
+    
+	BOOL my_ip_has_changed[3];
 
 	/*3 strings - ip_4, ip_6 address,
 	  and temp store, ip_store for
@@ -469,28 +486,31 @@
 	  convenient) -- for instance, 
 	  ip type "auto" (based on first 
 	  address returned by ip server)*/
-	DYNDNS_SERVER_NAME my_ip_address;
+	DYNDNS_MY_IP my_ip_address;
+} DYNDNS_IFACE_INFO;
+
+/*per update server*/
+typedef struct 
+{
+	BOOL is_update_ip4;
+	BOOL is_update_ip6;
+	BOOL is_update_auto;
+	BOOL is_got_ip4;
+	BOOL is_got_ip6;
+
+	HTTP_CLIENT			http_to_ip_server;
+	HTTP_CLIENT			http_to_dyndns;
 
 	DYNDNS_CREDENTIALS credentials;
 	DYNDNS_SYSTEM *p_dns_system;
 	DYNDNS_SERVER_NAME dyndns_server_name;
-	char *dyndns_server_url;
 	DYNDNS_SERVER_NAME ip_server_name;
-	char *ip_server_url;
 	DYNDNS_SERVER_NAME proxy_server_name;
-} DYNDNS_INFO_TYPE;
 
-typedef struct 
-{
-	/*multiple of ip types (2 -- IPv4, IPv6)*/
-	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
-	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
-	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
-	int count;
-	int count_dual;
-} DYNDNS_ALIAS_INFO;
+	DYNDNS_ALIAS_INFO	alias_info;
+	BOOL is_bad_config;
+	BOOL is_update_pending;
+} DYNDNS_INFO_TYPE;
 
 typedef struct
 {
@@ -533,8 +553,6 @@
 	BOOL		debug_to_syslog;
 	BOOL		change_persona;
 
-	HTTP_CLIENT			http_to_ip_server;
-	HTTP_CLIENT			http_to_dyndns;
 	HTTP_TRANSACTION	http_tr;
 	char				*p_work_buffer;		/* for HTTP responses*/
 	int					work_buffer_size;
@@ -544,20 +562,25 @@
 	char				*time_cache;
 	char				*ip_cache;
 
+	USER_INFO			sys_usr_info;			/*info about the current account running inadyn*/
 
-	USER_INFO			sys_usr_info;		/*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE	info;				/*servers, names, passwd*/
-	DYNDNS_INFO_TYPE	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
+	DYNDNS_IFACE_INFO	i_face;
 
-	DYNDNS_ALIAS_INFO	alias_info;
+	DYNDNS_INFO_TYPE	info[MAX_DNS_SERVER];	/*servers, names, passwd*/
+	char				srv_cnt;
+
+	DYNDNS_SERVER_NAME	info_online_status;		/*info about url to reach to confirm online status -- defaults to info*/
 
 	BOOL				abort_on_network_errors;
 	BOOL				force_addr_update;
 	BOOL				use_proxy;
 	BOOL				abort;
 	BOOL				wildcard;
-	BOOL				is_bad_config;
+	BOOL				is_global_bad_config; /*all servers*/
+
+	DYNDNS_SERVER_NAME ip_server_name_global;
 
+	char *p_pidfilename;
 	/*dbg*/
 	DBG_TYPE			dbg;
 } DYN_DNS_CLIENT;
@@ -633,7 +656,7 @@
 		- compare and update if neccessary
 */
 
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self);
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt);
 
 /* MAIN - Dyn DNS update entry point.*/
 
diff -ur inadyn-mt.v.02.24.36/src/errorcode.c inadyn-mt.v.02.24.36-pid-new/src/errorcode.c
--- src/errorcode.c	2011-03-31 17:18:47.000000000 -0400
+++ src/errorcode.c	2011-04-02 17:02:59.681008290 -0400
@@ -56,6 +56,7 @@
         {RC_HTTP_OBJECT_NOT_INITIALIZED,"RC_HTTP_OBJECT_NOT_INITIALIZED"},
         {RC_HTTP_BAD_PARAMETER,"RC_HTTP_BAD_PARAMETER"},
 
+		{RC_DYNDNS_TOO_MANY_SERVERS,"RC_DYNDNS_TOO_MANY_SERVERS"},
 		{RC_DYNDNS_INVALID_IP_ADDR,"RC_DYNDNS_INVALID_IP_ADDR"},
         {RC_DYNDNS_BUFFER_TOO_SMALL,"RC_DYNDNS_BUFFER_TOO_SMALL"},
         {RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE,"RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"},
diff -ur inadyn-mt.v.02.24.36/src/errorcode.h inadyn-mt.v.02.24.36-pid-new/src/errorcode.h
--- src/errorcode.h	2011-03-31 17:18:47.000000000 -0400
+++ src/errorcode.h	2011-04-02 17:02:59.684008183 -0400
@@ -46,6 +46,7 @@
     RC_HTTP_OBJECT_NOT_INITIALIZED				= 0x30,
     RC_HTTP_BAD_PARAMETER						= 0x31,
 
+	RC_DYNDNS_TOO_MANY_SERVERS					= 0x38,
 	RC_DYNDNS_INVALID_IP_ADDR					= 0x39,
     RC_DYNDNS_BUFFER_TOO_SMALL					= 0x40,
     RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
diff -ur inadyn-mt.v.02.24.36/src/inadyn_cmd.c inadyn-mt.v.02.24.36-pid-new/src/inadyn_cmd.c
--- src/inadyn_cmd.c	2011-03-31 17:18:47.000000000 -0400
+++ src/inadyn_cmd.c	2011-04-02 17:18:32.171813043 -0400
@@ -72,6 +72,7 @@
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -85,6 +86,7 @@
 #endif
 
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -120,6 +122,13 @@
 
 #endif
 
+/*
+	muti-services -- inc or set index based on
+	most recent server name option parameter
+	appearance.
+*/
+static server_index=0;
+
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
     {
         {"--help",		0,	{help_handler, NULL,0},	"help" },
@@ -160,6 +169,10 @@
          "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
          "The first IP in found http response is considered 'my IP'."},
 
+         {"--ip_server_name_global",	2,	{get_global_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers."},
+
         {"--online_check_url",	2,	{get_online_check_url_handler, NULL,0},
          "<srv_name[:port] local_url> - URL to reach to confirm online status.  "\
          "Default value:  " DYNDNS_MY_ONLINE_CHECK " /"},
@@ -203,6 +216,7 @@
 #endif
 
         {"--log_file",	1,	{get_logfile_name, NULL,0},		"<path/file> - log file path and name"},
+        {"--pid_file",	1,	{get_pidfile_name, NULL,0},		"pid file path and name"},
         {"--background", 0,	{set_silent_handler, NULL,0},		"run in background. output to log file or to syslog"},
 
 		{"--verbose",	1,	{set_verbose_handler, NULL,0},	"<#> - set dbg level. 0 to 5"},
@@ -257,6 +271,22 @@
         {NULL,		0,	{0, NULL,0},	"" }
     };
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *) safe_malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 void print_help_page(void)
 {
@@ -398,15 +428,15 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_username) {
+	if (p_self->info[server_index].credentials.my_username) {
 
-		free(p_self->info.credentials.my_username);
+		free(p_self->info[server_index].credentials.my_username);
 	}
 
 	/*user*/
-	p_self->info.credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -419,14 +449,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_password) {
+	if (p_self->info[server_index].credentials.my_password) {
 
-		free(p_self->info.credentials.my_password);
+		free(p_self->info[server_index].credentials.my_password);
 	}
 
 	/*password*/
-	p_self->info.credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	p_self->info[server_index].credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -452,7 +482,8 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count-p_self->alias_info.count_dual >= DYNDNS_MAX_ALIAS_NUMBER) {
+	if (p_self->info[server_index].alias_info.count-p_self->info[server_index].alias_info.count_dual 
+			>= DYNDNS_MAX_ALIAS_NUMBER) {
 
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -462,42 +493,46 @@
 
 	if (p_hash)	{
 
-		if (p_self->alias_info.hashes[p_self->alias_info.count].str)
+		if (p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str)
 
-			free(p_self->alias_info.hashes[p_self->alias_info.count].str);
+			free(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str);
 
 		/*allocate and copy hash len minus comma*/
-		p_self->alias_info.hashes[p_self->alias_info.count].str=safe_malloc(strlen(p_hash));
-		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str,(p_hash+1));
+		p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str
+			=safe_malloc(strlen(p_hash));
+
+		strcpy(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str,(p_hash+1));
 
 		alias_len=strlen(p_hash);
 	}
 	
-	if (p_self->alias_info.names[p_self->alias_info.count].name)
+	if (p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name)
 
-		free(p_self->alias_info.names[p_self->alias_info.count].name);
+		free(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name);
 
 	alias_len=strlen(p_cmd->argv[current_nr])-alias_len;
 
 	/*alias*/
-	p_self->alias_info.names[p_self->alias_info.count].name=safe_malloc(alias_len+1);
-	strncpy(p_self->alias_info.names[p_self->alias_info.count].name,p_cmd->argv[current_nr],alias_len);
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name
+		=safe_malloc(alias_len+1);
+	strncpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name,
+		p_cmd->argv[current_nr],alias_len);
 
 	/*default to letting ip server determine update type*/
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,"auto");
+	strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,"auto");
 
-	p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_store;
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_store;
 
 	/*IPv/type*/
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -510,7 +545,7 @@
 			}
 			else {
 
-				strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,ip_ver_str);
+				strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,ip_ver_str);
 
 				if (strcmp(ip_ver_str,"auto")) {
 
@@ -518,24 +553,24 @@
 
 						if (strcmp(ip_ver_str,"ip4"))
 
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_6;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_6;
 						else
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_4;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_4;
 					}
 				}
 
-				p_self->info.is_update_ip4=(p_self->info.is_update_ip4 || strstr(ip_ver_str,"ip4")
+				p_self->info[server_index].is_update_ip4=(p_self->info[server_index].is_update_ip4 || strstr(ip_ver_str,"ip4")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_ip6=(p_self->info.is_update_ip6 || strstr(ip_ver_str,"ip6")
+				p_self->info[server_index].is_update_ip6=(p_self->info[server_index].is_update_ip6 || strstr(ip_ver_str,"ip6")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_auto=(p_self->info.is_update_auto || strstr(ip_ver_str,"auto"));
+				p_self->info[server_index].is_update_auto=(p_self->info[server_index].is_update_auto || strstr(ip_ver_str,"auto"));
 			}
 		}
 	}
 
-	p_self->alias_info.count++;
+	p_self->info[server_index].alias_info.count++;
 
 
 	return RC_OK;
@@ -550,13 +585,13 @@
 
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -583,7 +618,7 @@
 
 		if ((RC_OK==(rc=do_get_alias_handler(p_cmd,current_nr,p_context,"ip6"))))
 
-			p_self->alias_info.count_dual++;
+			p_self->info[server_index].alias_info.count_dual++;
 	}
 
 	return rc;
@@ -629,7 +664,7 @@
 /** Returns the svr name and port if the format is :
  * name[:port] url.
  */
-static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_INFO_TYPE *info)
+static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_SERVER_NAME *info)
 {
 	RC_TYPE rc;
     int port = -1;
@@ -640,22 +675,22 @@
 	}
 
 	/*user*/
-    info->ip_server_name.port = HTTP_DEFAULT_PORT;
+    info->port = HTTP_DEFAULT_PORT;
 
-    rc = get_name_and_port(p_cmd->argv[current_nr], &info->ip_server_name.name[ip_store], &port);
+    rc = get_name_and_port(p_cmd->argv[current_nr], &info->name, &port);
 
     if (rc == RC_OK && port != -1)
     {
-        info->ip_server_name.port = port;
+        info->port = port;
     }        
 
-    if (info->ip_server_url)
+    if (info->url)
 
-		free(info->ip_server_url);
+		free(info->url);
 
-    info->ip_server_url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
+    info->url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
 
-    strcpy(info->ip_server_url, p_cmd->argv[current_nr + 1]);
+    strcpy(info->url, p_cmd->argv[current_nr + 1]);
 
     return rc;
 }
@@ -663,7 +698,34 @@
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info));
+    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info[server_index].ip_server_name));
+}
+
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	RC_TYPE			rc;
+	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
+	int				i;
+
+
+    if ((RC_OK==(rc=set_url_param(p_cmd,current_nr,&p_self->ip_server_name_global)))) {
+
+		for (i=0;i<MAX_DNS_SERVER;i++) {
+
+			if (!(p_self->info[i].ip_server_name.name)) {
+
+				p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->ip_server_name_global.name)+1);
+				strcpy(p_self->info[i].ip_server_name.name,p_self->ip_server_name_global.name);
+				
+				p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->ip_server_name_global.url)+1);
+				strcpy(p_self->info[i].ip_server_name.url,p_self->ip_server_name_global.url);
+				
+				p_self->info[i].ip_server_name.port=p_self->ip_server_name_global.port;
+			}
+		}
+	}
+
+	return rc;
 }
 
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -672,26 +734,112 @@
     return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info_online_status));
 }
 
+static char index_of(DYNDNS_SYSTEM *src,DYN_DNS_CLIENT *p_self)
+{
+
+	char i;
+
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		if (src==p_self->info[i].p_dns_system)
+
+			return i;
+	}
+
+	return -1;
+}
+
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
 	RC_TYPE rc;
 	int port = -1;
 
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
-   
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.dyndns_server_name.name[ip_store], &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
-    }                                   
+
+    p_self->info[server_index].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].dyndns_server_name.name, &port);
+
+	if (rc==RC_OK) {
+
+		if (port != -1) {
+
+			p_self->info[server_index].dyndns_server_name.port = port;
+		}
+    }
+
+
 	return rc;
 }
 
+/**
+    Searches the DYNDNS system by the argument.
+    Input is like: system@server.name
+    system=statdns|custom|dyndns|default
+    server name = dyndns.org | freedns.afraid.org
+    The result is a pointer in the table of DNS systems.
+*/
+static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYNDNS_SYSTEM *p_dns_system = NULL;
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	{
+		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
+		{
+			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
+			{
+				p_dns_system = &it->system;
+			}
+		}
+	}
+
+	if (p_dns_system == NULL)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
+
+
+   	/*new or existing server name can appear anywhere on command line.  if new, increment the global
+	  index (or counter, depending on how implement).  but, first check if it's already in list of
+	  servers and set index (or counter) correspondingly to it.  all "info" (server info structure)
+	  related handlers will use this index (or counter) until a new, or other existing name appears.*/
+
+	if (p_self->srv_cnt) {
+
+		if (!(p_self->srv_cnt<MAX_DNS_SERVER))
+
+			return RC_DYNDNS_TOO_MANY_SERVERS;
+
+
+		if (!(-1==(server_index=index_of(p_dns_system,p_self)))) {
+
+			return RC_OK;			
+		}
+		else {
+
+			server_index=p_self->srv_cnt;
+		}			
+	}
+
+	p_self->info[server_index].p_dns_system = p_dns_system;
+
+	p_self->srv_cnt+=1;
+
+
+	return RC_OK;
+}
+
 RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -700,14 +848,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.dyndns_server_url)
+	if (p_self->info[server_index].dyndns_server_name.url)
 
-		free(p_self->info.dyndns_server_url);
+		free(p_self->info[server_index].dyndns_server_name.url);
 
-	p_self->info.dyndns_server_url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].dyndns_server_name.url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
 	/*url*/
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].dyndns_server_name.url, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -726,11 +874,11 @@
 	}
 
 	/*user*/
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.proxy_server_name.name[ip_store], &port);
+    p_self->info[server_index].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[server_index].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -995,43 +1143,6 @@
 	return RC_OK;
 }
 
-/**
-    Searches the DYNDNS system by the argument.
-    Input is like: system@server.name
-    system=statdns|custom|dyndns|default
-    server name = dyndns.org | freedns.afraid.org
-    The result is a pointer in the table of DNS systems.
-*/
-static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
-{
-	DYNDNS_SYSTEM *p_dns_system = NULL;
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-	if (p_self == NULL)
-	{
-		return RC_INVALID_POINTER;
-	}
-
-	{
-		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
-		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
-		{
-			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
-			{
-				p_dns_system = &it->system;
-			}
-		}
-	}
-
-	if (p_dns_system == NULL)
-	{
-		return RC_DYNDNS_INVALID_OPTION;
-	}
-
-	p_self->info.p_dns_system = p_dns_system;
-
-	return RC_OK;
-}
-
 static RC_TYPE get_debug_level_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
@@ -2223,8 +2334,7 @@
 			rc = get_cmd_parse_data_with_error_handling(argv, argc, cmd_options_table,pf_err_handler);
 		}
 
-		if (rc != RC_OK ||
-		        p_self->abort)
+		if (rc != RC_OK || p_self->abort)
 		{
 			break;
 		}
@@ -2232,52 +2342,61 @@
 		/*settings that may change due to cmd line options*/
 		{
 			int	len=0;
+			int i;
 
 			
-    		/*ip server*/
-            if (!(p_self->info.ip_server_name.name[ip_store]))
-            {
-				p_self->info.ip_server_name.name[ip_store]=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_name)+1);
-				strcpy(p_self->info.ip_server_name.name[ip_store], p_self->info.p_dns_system->p_ip_server_name);
+            if (!(p_self->info_online_status.name))
+			{
+				p_self->info_online_status.name=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
+				strcpy(p_self->info_online_status.name,DYNDNS_MY_ONLINE_CHECK);
+
+				p_self->info_online_status.url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
+				strcpy(p_self->info_online_status.url,DYNDNS_MY_ONLINE_CHECK_URL);
 
-				p_self->info.ip_server_url=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_url)+1);
-				strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+				p_self->info_online_status.port=80;
             }
 
-            if (!(p_self->info_online_status.ip_server_name.name[ip_store]))
-			{
-				p_self->info_online_status.ip_server_name.name[ip_store]=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
-				strcpy(p_self->info_online_status.ip_server_name.name[ip_store],DYNDNS_MY_ONLINE_CHECK);
+			if (!(p_self->srv_cnt))
 
-				p_self->info_online_status.ip_server_url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
-				strcpy(p_self->info_online_status.ip_server_url,DYNDNS_MY_ONLINE_CHECK_URL);
+				p_self->srv_cnt=1; /*default server set in main*/
 
-				p_self->info_online_status.ip_server_name.port=80;
-            }
+			for (i=0;i<p_self->srv_cnt;i++) {
 
-    		/*dyndns server*/
-            if (!(p_self->info.dyndns_server_name.name[ip_store]))
-            {
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_name)))) {
+    			/*dyndns server*/
+				if (!(p_self->info[i].dyndns_server_name.name))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_name)))) {
 
-					p_self->info.dyndns_server_name.name[ip_store]=safe_malloc(len+1);
-        			strcpy(p_self->info.dyndns_server_name.name[ip_store], p_self->info.p_dns_system->p_dyndns_server_name);
+						p_self->info[i].dyndns_server_name.name=safe_malloc(len+1);
+        				strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
+					}				
 				}
-			}
 
-			if (!(p_self->info.dyndns_server_url)) 
-			{
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_url)))) {
+ 				/*ip server*/
+				if (!(p_self->info[i].ip_server_name.name))
+				{
+					p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_name)+1);
+					strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
+				
+					p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_url)+1);
+					strcpy(p_self->info[i].ip_server_name.url, p_self->info[i].p_dns_system->p_ip_server_url);				
+				}
 
-					p_self->info.dyndns_server_url=safe_malloc(len+1);
-      				strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+
+				if (!(p_self->info[i].dyndns_server_name.url)) 
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_url)))) {
+
+						p_self->info[i].dyndns_server_name.url=safe_malloc(len+1);
+    					strcpy(p_self->info[i].dyndns_server_name.url, p_self->info[i].p_dns_system->p_dyndns_server_url);
+					}
 				}
 			}
 		}
 
 		/*check if the neccessary params have been provided*/
-		if ((!(p_self->info.dyndns_server_name.name[ip_store])) || (!(p_self->info.ip_server_name.name[ip_store]))
-			|| (!(p_self->info.dyndns_server_url)) || (p_self->alias_info.count == 0))
+		if ((!(p_self->info[0].dyndns_server_name.name)) || (!(p_self->info[0].ip_server_name.name))
+			|| (!(p_self->info[0].dyndns_server_name.url)) || (p_self->info[0].alias_info.count == 0))
 
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
diff -ur inadyn-mt.v.02.24.36/src/lang.c inadyn-mt.v.02.24.36-pid-new/src/lang.c
--- src/lang.c	2011-03-31 17:18:47.000000000 -0400
+++ src/lang.c	2011-04-02 17:02:59.741006185 -0400
@@ -659,14 +659,20 @@
 	RC_TYPE				rc=RC_OK;
 
 
-	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
-
 	memset(langFile,0,7);
 
+	lang_code(langFile,szLocale);
+
+	if (szLocale)
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
+	else
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale NULL.  Will use language code:  %s...\n",langFile));
+
 
 	/*pass to langFile function, 2 character language code, with appended, .lng*/
 
-	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(lang_code(langFile,szLocale),".lng"));
+	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(langFile,".lng"));
 
 
 	rc=do_init_lang_strings(pLOG_FILE,lang_file_and_path);
diff -ur inadyn-mt.v.02.24.36/src/path.c inadyn-mt.v.02.24.36-pid-new/src/path.c
--- src/path.c	2011-03-31 17:18:47.000000000 -0400
+++ src/path.c	2011-04-02 17:02:59.807003867 -0400
@@ -635,7 +635,7 @@
 	FILE    *fp=NULL;
 
 
-	if (!(root_dir))
+	if (!(root_dir) || !(in_dir))
 
 		return NULL;
 
@@ -768,11 +768,16 @@
 
 	*dest=NULL;
 
+	if (!(cross_platform_cwd(&cwd))) {
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "cwd giving NULL in searchedProgFile...\n"));
+
+		return NULL;
+	}
+
 	normed_path=safe_malloc(strlen(path)+2);
 	strcat(strcpy(normed_path,path),DIR_DELIM_STR);
 
-	cross_platform_cwd(&cwd);
-
 #ifdef _WIN32
 
 	if (!(progMetaFile(pLOG_FILE,dest,normed_path,path_len,langFileName,str_to_lwr(ancestor_path(&a_path,root,cwd)),cwd))) {
