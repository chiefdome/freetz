#!/bin/sh

[ -r /mod/etc/conf/mod.cfg ] && . /mod/etc/conf/mod.cfg

# Global result
IP=""

helpmsg() {
cat << EOF
get_ip - determine external IP address"

Usage: $0 [option]
    -a, --all      - use all methods (order: dsld, webcm, route, extquery, ostat) [recommended]
    -d, --dsld     - use showdsldstat method (use only with kernel 2.6 firmwares)
    -e, --extquery - use external site query method (checkip.dyndns.org)
    -o, --ostat    - use onlinestat method (since firmware 04.87)
    -r, --route    - use routing table
    -w, --webcm    - use webcm CGI handler / ctlmgr_ctl method
    -?, --help     - print this help message

  current default method: $MOD_GET_IP_METHOD

EOF
}

# Detect private (RFC 1918) or link-local (RFC 5735) IPs
# Returns 0 for public IP, 1 for private IP, 2 if IP == ""
ip_public()
{
	[ "$1" ] || return 2
	local ip=$1
	# 10.0.0.0/8 (private), 192.168.0.0/16 (private), 169.254.0.0/16 (link-local)
	(
		[ "$ip" != "${ip#10.}" ] ||
		[ "$ip" != "${ip#192.168.}" ] ||
		[ "$ip" != "${ip#169.254.}" ]
	) && return 1
	# 172.16.0.0/12 (private)
	[ "$ip" == "${ip#172.}" ] && return 0
	ip=$(echo $ip | cut -d '.' -f 2)
	[ $ip -ge 16  ] && [ $ip -le 31 ] && return 1 || return 0
}

via_dsld() {
	# Firmware ca. 04.68 and newer should be safe, but some boxes had it since 04.31
	IP="$(/sbin/showdsldstat 2>/dev/null | sed -nr 's/0: ip ([0-9.]+).*/\1/p')"
	ip_public "$IP" || return 1
}

via_route() {
	if [ -f /sbin/showroutes ]; then
		# Firmware ca. 04.67/68 (Fritz!Box) / 04.57 (Speedport) and newer
		IP="$(/sbin/showroutes | sed -nr 's/(.*)\/32 .* iface$/\1/p')"
		ip_public "$IP" || return 1
	else
		# Older firmware
		# Commented version works without Busybox "route" applet, but emulates
		# it. Keep it for now (even though it looks ugly) - just in case...
		#for ip in $(cat /proc/net/route | sed -nr 's/^dsl[[:blank:]]+([[:xdigit:]][[:xdigit:]])([[:xdigit:]][[:xdigit:]])([[:xdigit:]][[:xdigit:]])([[:xdigit:]][[:xdigit:]]).*FFFFFFFF.*/0x\4 0x\3 0x\2 0x\1/p' | xargs printf '%u.%u.%u.%u\n'); do
		for ip in $(route -n | sed -nr 's/^([1-9][0-9]*\.[0-9]+\.[0-9]+\.[0-9]+) +.* +dsl$/\1/p'); do
			ip_public "$ip" && IP="$ip" && return 0
		done
		return 1
	fi
}

via_extquery() {
	# Read cache file (max. age 1 minute)
	IP=$(find /tmp/ -name get_ip.cache -maxdepth 1 -mmin 0 -exec cat {} ';')
	[ "$IP" ] && return 0
	# If supported by wget(-gnu), don't wait forever
	SHORTWAIT="-t 1"
	if which wget-gnu >/dev/null; then
		WGET="wget-gnu $SHORTWAIT"
	else
		wget --version >/dev/null 2>&1 && WGET="wget $SHORTWAIT" || WGET="wget"
	fi
	# Get IP from external web site, max. 3 tries
	for turn in 1 2 3; do
		IP="$($WGET -T 30 -q -O - http://checkip.dyndns.org | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')"
		[ $? -eq 0 ] && [ "$IP" ] && echo "$IP" > /tmp/get_ip.cache && return 0
	done
	return 1
}

via_ostat() {
	IP="$(cat /var/run/onlinestat 2>/dev/null | sed -nr 's!^IPADDR ([0-9.]+)!\1!p')"
	ip_public "$IP" || return 1
}

via_webcm() {
	local queryfile="/usr/www/all/html/query.txt"
	local querystring=""
	if which ctlmgr_ctl >/dev/null; then
		# Firmware ca. 04.76 and newer
		IP=$(ctlmgr_ctl r connection0 pppoe:status/ip)
	else
		if [ "$(sed -n '/var:n\[/p' $queryfile)" ]; then
			# Firmware ca. 04.84 and newer (should never be used, see above)
			querystring="var:n[0]=connection0:pppoe:status/ip"
		else
			# Older firmware
			querystring="var:cnt=1&var:n0=connection0:pppoe:status/ip"
		fi
		IP="$(/usr/www/html/cgi-bin/webcm "getpage=${queryfile}&${querystring}")"
	fi
	# ctlmgr_ctl return values [box=val]: 7170=176, 7270=177, 7141=172
	# Caveat: must use "-o" instead of "||", otherwise "$?" would be reset
	[ $? -eq 0 -o $? -ge 170 ] && ip_public "$IP" && return 0 || return 1
}

# Set user-defined method (e.g. via web UI) if no argument is given
[ $# -eq 0 ] && method="$MOD_GET_IP_METHOD" || method="$1"

case $method in
	-a|--all|"")
		ext_last="extquery"
		# IP client -> make extquery the method to try first
		[ -r /var/run/ip_client ] && ext_first="extquery" && ext_last=""
		for mode in $ext_first dsld webcm route $ext_last ostat; do
			via_$mode
			if [ $? -eq 0 ]; then
				# IP client? -> set semaphore
				[ "$mode" == "extquery" ] && touch /var/run/ip_client
				break
			fi
		done
		;;
	-d|--dsld)
		via_dsld
		;;
	-r|--route)
		via_route
		;;
	-e|--extquery)
		via_extquery
		;;
	-o|--ostat)
		via_ostat
		;;
	-w|--webcm)
		via_webcm
		;;
	-?|-h|--help)
		helpmsg
		exit 0
		;;
	*)
		helpmsg >&2
		exit 1
		;;
esac

[ $? -ne 0 ] && echo "get_ip error" >&2 && exit 1
echo "$IP"
